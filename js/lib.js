(function() {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var keyPrefix = +new Date() + "";
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
    var templateCounter = 0;
    var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {
        leading: false,
        maxWait: 0,
        trailing: false
    };
    var descriptor = {
        configurable: false,
        enumerable: false,
        value: null,
        writable: false
    };
    var objectTypes = {
        "boolean": false,
        "function": true,
        object: true,
        number: false,
        string: false,
        undefined: false
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == "boolean" || value == null) {
            return cache[value] ? 0 : -1;
        }
        if (type != "number" && type != "string") {
            type = "object";
        }
        var key = type == "number" ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == "boolean" || value == null) {
            cache[value] = true;
        } else {
            if (type != "number" && type != "string") {
                type = "object";
            }
            var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == "object") {
                (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
                typeCache[key] = true;
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || typeof value == "undefined") {
                    return 1;
                }
                if (value < other || typeof other == "undefined") {
                    return -1;
                }
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
            return false;
        }
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index]);
        }
        return result;
    }
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": false,
            index: 0,
            "null": false,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": false,
            undefined: false,
            value: null
        };
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
            end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index];
        }
        return result;
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function() {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {}
            return result;
        }();
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
            return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == "string";
        lodash.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        function baseBind(bindData) {
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != "undefined") {
                    return result;
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className]) {
                    return value;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                  case boolClass:
                  case dateClass:
                    return new ctor(+value);

                  case numberClass:
                  case stringClass:
                    return new ctor(value);

                  case regexpClass:
                    result = ctor(value.source, reFlags.exec(value));
                    result.lastIndex = value.lastIndex;
                    return result;
                }
            } else {
                return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(value.length) : {};
            } else {
                result = isArr ? slice(value) : assign({}, value);
            }
            if (isArr) {
                if (hasOwnProperty.call(value, "index")) {
                    result.index = value.index;
                }
                if (hasOwnProperty.call(value, "input")) {
                    result.input = value.input;
                }
            }
            if (!isDeep) {
                return result;
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? forEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
            baseCreate = function() {
                function Object() {}
                return function(prototype) {
                    if (isObject(prototype)) {
                        Object.prototype = prototype;
                        var result = new Object();
                        Object.prototype = null;
                    }
                    return result || context.Object();
                };
            }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity;
            }
            if (typeof thisArg == "undefined" || !("prototype" in func)) {
                return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == "undefined") {
                if (support.funcNames) {
                    bindData = !func.name;
                }
                bindData = bindData || !support.funcDecomp;
                if (!bindData) {
                    var source = fnToString.call(func);
                    if (!support.funcNames) {
                        bindData = !reFuncName.test(source);
                    }
                    if (!bindData) {
                        bindData = reThis.test(source);
                        setBindData(func, bindData);
                    }
                }
            }
            if (bindData === false || bindData !== true && bindData[1] & 1) {
                return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 2:
                return function(a, b) {
                    return func.call(thisArg, a, b);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (partialRightArgs || isCurry) {
                    args || (args = slice(arguments));
                    if (partialRightArgs) {
                        push.apply(args, partialRightArgs);
                    }
                    if (isCurry && args.length < arity) {
                        bitmask |= 16 & ~32;
                        return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                    }
                }
                args || (args = arguments);
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                if (cache) {
                    indexOf = cacheIndexOf;
                    values = cache;
                } else {
                    isLarge = false;
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseObject(values);
            }
            return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isStrict);
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != "undefined") {
                    return !!result;
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b;
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false;
            }
            if (a == null || b == null) {
                return a === b;
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass;
            }
            if (otherClass == argsClass) {
                otherClass = objectClass;
            }
            if (className != otherClass) {
                return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                return +a == +b;

              case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

              case regexpClass:
              case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                if (aWrapped || bWrapped) {
                    return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                }
                if (className != objectClass) {
                    return false;
                }
                var ctorA = a.constructor, ctorB = b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                    return false;
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b;
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == length;
                if (result || isWhere) {
                    while (size--) {
                        var index = length, value = b[size];
                        if (isWhere) {
                            while (index--) {
                                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                            break;
                        }
                    }
                }
            } else {
                forIn(b, function(value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                    }
                });
                if (result && !isWhere) {
                    forIn(a, function(value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
            }
            stackA.pop();
            stackB.pop();
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break;
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != "undefined") {
                                value = result;
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB);
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == "undefined") {
                            result = source;
                        }
                    }
                    if (typeof result != "undefined") {
                        value = result;
                    }
                }
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf;
                seen = cache;
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen);
            } else if (callback) {
                releaseArray(seen);
            }
            return result;
        }
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                var index = -1, length = collection ? collection.length : 0;
                if (typeof length == "number") {
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection);
                    }
                } else {
                    forOwn(collection, function(value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError();
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
                bindData = slice(bindData);
                if (bindData[2]) {
                    bindData[2] = slice(bindData[2]);
                }
                if (bindData[3]) {
                    bindData[3] = slice(bindData[3]);
                }
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg;
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8;
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity;
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                }
                if (isPartialRight) {
                    unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                }
                bindData[1] |= bitmask;
                return createWrapper.apply(null, bindData);
            }
            var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
            return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return typeof value == "function" && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, "__bindData__", descriptor);
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
            isFunction(ctor) && !(ctor instanceof ctor))) {
                return false;
            }
            forIn(value, function(value, key) {
                result = key;
            });
            return typeof result == "undefined" || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function(object) {
            var index, iterable = object, result = [];
            if (!iterable) return result;
            if (!objectTypes[typeof object]) return result;
            for (index in iterable) {
                if (hasOwnProperty.call(iterable, index)) {
                    result.push(index);
                }
            }
            return result;
        };
        var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
                return [];
            }
            return nativeKeys(object);
        };
        var htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
        var assign = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
            if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
            } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                callback = args[--argsLength];
            }
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                    }
                }
            }
            return result;
        };
        function clone(value, isDeep, callback, thisArg) {
            if (typeof isDeep != "boolean" && isDeep != null) {
                thisArg = callback;
                callback = isDeep;
                isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        var defaults = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        if (typeof result[index] == "undefined") result[index] = iterable[index];
                    }
                }
            }
            return result;
        };
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        var forIn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            for (index in iterable) {
                if (callback(iterable[index], index, collection) === false) return result;
            }
            return result;
        };
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break;
                }
            }
            return object;
        }
        var forOwn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
            while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (callback(iterable[index], index, collection) === false) return result;
            }
            return result;
        };
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break;
                }
            }
            return object;
        }
        function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
                if (isFunction(value)) {
                    result.push(key);
                }
            });
            return result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
            return value && typeof value == "object" && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result;
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                return !length;
            }
            forOwn(value, function() {
                return result = false;
            });
            return result;
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return typeof value == "function";
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return value && typeof value == "object" && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
            return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
            return typeof value == "undefined";
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                result[key] = callback(value, key, object);
            });
            return result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object;
            }
            if (typeof args[2] != "number") {
                length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == "function") {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == "function") {
                callback = args[--length];
            }
            var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var props = [];
                forIn(object, function(value, key) {
                    props.push(key);
                });
                props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (!callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key];
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = [];
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = baseCreate(proto);
                }
            }
            if (callback) {
                callback = lodash.createCallback(callback, thisArg, 4);
                (isArr ? forEach : forOwn)(object, function(value, index, object) {
                    return callback(accumulator, value, index, object);
                });
            }
            return accumulator;
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            while (++index < length) {
                result[index] = collection[props[index]];
            }
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == "number") {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
                forOwn(collection, function(value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target);
                    }
                });
            }
            return result;
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    return result = !!callback(value, index, collection);
                });
            }
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                });
            }
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value;
                    }
                }
            } else {
                var result;
                forOwn(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false;
                    }
                });
                return result;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false;
                }
            });
            return result;
        }
        function forEach(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break;
                    }
                }
            } else {
                forOwn(collection, callback);
            }
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break;
                    }
                }
            } else {
                var props = keys(collection);
                length = props.length;
                forOwn(collection, function(value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(collection[key], key, collection);
                });
            }
            return collection;
        }
        var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (typeof length == "number") {
                var result = Array(length);
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection);
                }
            } else {
                result = [];
                forOwn(collection, function(value, key, collection) {
                    result[++index] = callback(value, key, collection);
                });
            }
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
            if (!collection) return accumulator;
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            var index = -1, length = collection.length;
            if (typeof length == "number") {
                if (noaccum) {
                    accumulator = collection[++index];
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection);
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                });
            }
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && typeof collection.length != "number") {
                collection = values(collection);
            }
            if (n == null || guard) {
                return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand];
                result[rand] = value;
            });
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == "number" ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function(value, index, collection) {
                    return !(result = callback(value, index, collection));
                });
            }
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            if (!isArr) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                if (isArr) {
                    object.criteria = map(callback, function(key) {
                        return value[key];
                    });
                } else {
                    (object.criteria = getArray())[0] = callback(value, key, collection);
                }
                object.index = index;
                object.value = value;
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                if (!isArr) {
                    releaseArray(object.criteria);
                }
                releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            if (collection && typeof collection.length == "number") {
                return slice(collection);
            }
            return values(collection);
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined;
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != "boolean" && isShallow != null) {
                thisArg = callback;
                callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                isShallow = false;
            }
            if (callback != null) {
                array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == "number") {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                }
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer: while (++index < length) {
                var cache = caches[0];
                value = array[index];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    argsIndex = argsLength;
                    (cache || seen).push(value);
                    while (--argsIndex) {
                        cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                            continue outer;
                        }
                    }
                    result.push(value);
                }
            }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache);
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined;
                }
            }
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--;
                    }
                }
            }
            return array;
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == "number" ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0;
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != "number" && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != "boolean" && isSorted != null) {
                thisArg = callback;
                callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                isSorted = false;
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                }
            }
            return result || [];
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index);
            }
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            if (!values && length && !isArray(keys[0])) {
                values = [];
            }
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError();
                }
            }
            return function() {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [ funcs[length].apply(this, args) ];
                }
                return args[0];
            };
        }
        function curry(func, arity) {
            arity = typeof arity == "number" ? arity : +arity || func.length;
            return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            var delayed = function() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            };
            var maxDelayed = function() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            };
            return function() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            memoized.cache = {};
            return memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (ran) {
                    return result;
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result;
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = "leading" in options ? options.leading : leading;
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [ value ]);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == "function") {
                return baseCreateCallback(func, thisArg, argCount);
            }
            if (type != "object") {
                return property(func);
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function(object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b);
                };
            }
            return function(object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break;
                    }
                }
                return result;
            };
        }
        function escape(string) {
            return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = true, methodNames = source && functions(source);
            if (!source || !options && !methodNames.length) {
                if (options == null) {
                    options = source;
                }
                ctor = lodashWrapper;
                source = object;
                object = lodash;
                methodNames = functions(source);
            }
            if (options === false) {
                chain = false;
            } else if (isObject(options) && "chain" in options) {
                chain = options.chain;
            }
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function(methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function() {
                        var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (chain || chainAll) {
                            if (value === result && isObject(result)) {
                                return this;
                            }
                            result = new ctor(result);
                            result.__chain__ = chainAll;
                        }
                        return result;
                    };
                }
            });
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {}
        var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        function property(key) {
            return function(object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == "boolean" && noMax) {
                    floating = min;
                    min = 1;
                } else if (!noMax && typeof max == "boolean") {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || "");
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = "obj";
                source = "with (" + variable + ") {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) {
                return result(data);
            }
            result.source = source;
            return result;
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index);
            }
            return result;
        }
        function unescape(string) {
            return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? "" : prefix) + id;
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
            var source = {};
            forOwn(lodash, function(func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== "sample";
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function(n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                };
            }
        });
        lodash.VERSION = "2.4.1";
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach([ "join", "pop", "shift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        });
        forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                func.apply(this.__wrapped__, arguments);
                return this;
            };
        });
        forEach([ "concat", "slice", "splice" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        });
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}).call(this);

!function(e, n) {
    "use strict";
    function r(e, n) {
        var r, t, u = e.toLowerCase();
        for (n = [].concat(n), r = 0; r < n.length; r += 1) if (t = n[r]) {
            if (t.test && t.test(e)) return !0;
            if (t.toLowerCase() === u) return !0;
        }
    }
    var t = n.prototype.trim, u = n.prototype.trimRight, i = n.prototype.trimLeft, l = function(e) {
        return 1 * e || 0;
    }, o = function(e, n) {
        if (1 > n) return "";
        for (var r = ""; n > 0; ) 1 & n && (r += e), n >>= 1, e += e;
        return r;
    }, a = [].slice, c = function(e) {
        return null == e ? "\\s" : e.source ? e.source : "[" + g.escapeRegExp(e) + "]";
    }, s = {
        lt: "<",
        gt: ">",
        quot: '"',
        amp: "&",
        apos: "'"
    }, f = {};
    for (var p in s) f[s[p]] = p;
    f["'"] = "#39";
    var h = function() {
        function e(e) {
            return Object.prototype.toString.call(e).slice(8, -1).toLowerCase();
        }
        var r = o, t = function() {
            return t.cache.hasOwnProperty(arguments[0]) || (t.cache[arguments[0]] = t.parse(arguments[0])), 
            t.format.call(null, t.cache[arguments[0]], arguments);
        };
        return t.format = function(t, u) {
            var i, l, o, a, c, s, f, p = 1, g = t.length, d = "", m = [];
            for (l = 0; g > l; l++) if (d = e(t[l]), "string" === d) m.push(t[l]); else if ("array" === d) {
                if (a = t[l], a[2]) for (i = u[p], o = 0; o < a[2].length; o++) {
                    if (!i.hasOwnProperty(a[2][o])) throw new Error(h('[_.sprintf] property "%s" does not exist', a[2][o]));
                    i = i[a[2][o]];
                } else i = a[1] ? u[a[1]] : u[p++];
                if (/[^s]/.test(a[8]) && "number" != e(i)) throw new Error(h("[_.sprintf] expecting number but found %s", e(i)));
                switch (a[8]) {
                  case "b":
                    i = i.toString(2);
                    break;

                  case "c":
                    i = n.fromCharCode(i);
                    break;

                  case "d":
                    i = parseInt(i, 10);
                    break;

                  case "e":
                    i = a[7] ? i.toExponential(a[7]) : i.toExponential();
                    break;

                  case "f":
                    i = a[7] ? parseFloat(i).toFixed(a[7]) : parseFloat(i);
                    break;

                  case "o":
                    i = i.toString(8);
                    break;

                  case "s":
                    i = (i = n(i)) && a[7] ? i.substring(0, a[7]) : i;
                    break;

                  case "u":
                    i = Math.abs(i);
                    break;

                  case "x":
                    i = i.toString(16);
                    break;

                  case "X":
                    i = i.toString(16).toUpperCase();
                }
                i = /[def]/.test(a[8]) && a[3] && i >= 0 ? "+" + i : i, s = a[4] ? "0" == a[4] ? "0" : a[4].charAt(1) : " ", 
                f = a[6] - n(i).length, c = a[6] ? r(s, f) : "", m.push(a[5] ? i + c : c + i);
            }
            return m.join("");
        }, t.cache = {}, t.parse = function(e) {
            for (var n = e, r = [], t = [], u = 0; n; ) {
                if (null !== (r = /^[^\x25]+/.exec(n))) t.push(r[0]); else if (null !== (r = /^\x25{2}/.exec(n))) t.push("%"); else {
                    if (null === (r = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(n))) throw new Error("[_.sprintf] huh?");
                    if (r[2]) {
                        u |= 1;
                        var i = [], l = r[2], o = [];
                        if (null === (o = /^([a-z_][a-z_\d]*)/i.exec(l))) throw new Error("[_.sprintf] huh?");
                        for (i.push(o[1]); "" !== (l = l.substring(o[0].length)); ) if (null !== (o = /^\.([a-z_][a-z_\d]*)/i.exec(l))) i.push(o[1]); else {
                            if (null === (o = /^\[(\d+)\]/.exec(l))) throw new Error("[_.sprintf] huh?");
                            i.push(o[1]);
                        }
                        r[2] = i;
                    } else u |= 2;
                    if (3 === u) throw new Error("[_.sprintf] mixing positional and named placeholders is not (yet) supported");
                    t.push(r);
                }
                n = n.substring(r[0].length);
            }
            return t;
        }, t;
    }(), g = {
        VERSION: "2.4.0",
        isBlank: function(e) {
            return null == e && (e = ""), /^\s*$/.test(e);
        },
        stripTags: function(e) {
            return null == e ? "" : n(e).replace(/<\/?[^>]+>/g, "");
        },
        capitalize: function(e) {
            return e = null == e ? "" : n(e), e.charAt(0).toUpperCase() + e.slice(1);
        },
        chop: function(e, r) {
            return null == e ? [] : (e = n(e), r = ~~r, r > 0 ? e.match(new RegExp(".{1," + r + "}", "g")) : [ e ]);
        },
        clean: function(e) {
            return g.strip(e).replace(/\s+/g, " ");
        },
        count: function(e, r) {
            if (null == e || null == r) return 0;
            e = n(e), r = n(r);
            for (var t = 0, u = 0, i = r.length; ;) {
                if (u = e.indexOf(r, u), -1 === u) break;
                t++, u += i;
            }
            return t;
        },
        chars: function(e) {
            return null == e ? [] : n(e).split("");
        },
        swapCase: function(e) {
            return null == e ? "" : n(e).replace(/\S/g, function(e) {
                return e === e.toUpperCase() ? e.toLowerCase() : e.toUpperCase();
            });
        },
        escapeHTML: function(e) {
            return null == e ? "" : n(e).replace(/[&<>"']/g, function(e) {
                return "&" + f[e] + ";";
            });
        },
        unescapeHTML: function(e) {
            return null == e ? "" : n(e).replace(/\&([^;]+);/g, function(e, r) {
                var t;
                return r in s ? s[r] : (t = r.match(/^#x([\da-fA-F]+)$/)) ? n.fromCharCode(parseInt(t[1], 16)) : (t = r.match(/^#(\d+)$/)) ? n.fromCharCode(~~t[1]) : e;
            });
        },
        escapeRegExp: function(e) {
            return null == e ? "" : n(e).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        },
        splice: function(e, n, r, t) {
            var u = g.chars(e);
            return u.splice(~~n, ~~r, t), u.join("");
        },
        insert: function(e, n, r) {
            return g.splice(e, n, 0, r);
        },
        include: function(e, r) {
            return "" === r ? !0 : null == e ? !1 : -1 !== n(e).indexOf(r);
        },
        join: function() {
            var e = a.call(arguments), n = e.shift();
            return null == n && (n = ""), e.join(n);
        },
        lines: function(e) {
            return null == e ? [] : n(e).split("\n");
        },
        reverse: function(e) {
            return g.chars(e).reverse().join("");
        },
        startsWith: function(e, r) {
            return "" === r ? !0 : null == e || null == r ? !1 : (e = n(e), r = n(r), e.length >= r.length && e.slice(0, r.length) === r);
        },
        endsWith: function(e, r) {
            return "" === r ? !0 : null == e || null == r ? !1 : (e = n(e), r = n(r), e.length >= r.length && e.slice(e.length - r.length) === r);
        },
        succ: function(e) {
            return null == e ? "" : (e = n(e), e.slice(0, -1) + n.fromCharCode(e.charCodeAt(e.length - 1) + 1));
        },
        titleize: function(e) {
            return null == e ? "" : (e = n(e).toLowerCase(), e.replace(/(?:^|\s|-)\S/g, function(e) {
                return e.toUpperCase();
            }));
        },
        camelize: function(e) {
            return g.trim(e).replace(/[-_\s]+(.)?/g, function(e, n) {
                return n ? n.toUpperCase() : "";
            });
        },
        underscored: function(e) {
            return g.trim(e).replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
        },
        dasherize: function(e) {
            return g.trim(e).replace(/([A-Z])/g, "-$1").replace(/[-_\s]+/g, "-").toLowerCase();
        },
        classify: function(e) {
            return g.capitalize(g.camelize(n(e).replace(/[\W_]/g, " ")).replace(/\s/g, ""));
        },
        humanize: function(e) {
            return g.capitalize(g.underscored(e).replace(/_id$/, "").replace(/_/g, " "));
        },
        trim: function(e, r) {
            return null == e ? "" : !r && t ? t.call(e) : (r = c(r), n(e).replace(new RegExp("^" + r + "+|" + r + "+$", "g"), ""));
        },
        ltrim: function(e, r) {
            return null == e ? "" : !r && i ? i.call(e) : (r = c(r), n(e).replace(new RegExp("^" + r + "+"), ""));
        },
        rtrim: function(e, r) {
            return null == e ? "" : !r && u ? u.call(e) : (r = c(r), n(e).replace(new RegExp(r + "+$"), ""));
        },
        truncate: function(e, r, t) {
            return null == e ? "" : (e = n(e), t = t || "...", r = ~~r, e.length > r ? e.slice(0, r) + t : e);
        },
        prune: function(e, r, t) {
            if (null == e) return "";
            if (e = n(e), r = ~~r, t = null != t ? n(t) : "...", e.length <= r) return e;
            var u = function(e) {
                return e.toUpperCase() !== e.toLowerCase() ? "A" : " ";
            }, i = e.slice(0, r + 1).replace(/.(?=\W*\w*$)/g, u);
            return i = i.slice(i.length - 2).match(/\w\w/) ? i.replace(/\s*\S+$/, "") : g.rtrim(i.slice(0, i.length - 1)), 
            (i + t).length > e.length ? e : e.slice(0, i.length) + t;
        },
        words: function(e, n) {
            return g.isBlank(e) ? [] : g.trim(e, n).split(n || /\s+/);
        },
        pad: function(e, r, t, u) {
            e = null == e ? "" : n(e), r = ~~r;
            var i = 0;
            switch (t ? t.length > 1 && (t = t.charAt(0)) : t = " ", u) {
              case "right":
                return i = r - e.length, e + o(t, i);

              case "both":
                return i = r - e.length, o(t, Math.ceil(i / 2)) + e + o(t, Math.floor(i / 2));

              default:
                return i = r - e.length, o(t, i) + e;
            }
        },
        lpad: function(e, n, r) {
            return g.pad(e, n, r);
        },
        rpad: function(e, n, r) {
            return g.pad(e, n, r, "right");
        },
        lrpad: function(e, n, r) {
            return g.pad(e, n, r, "both");
        },
        sprintf: h,
        vsprintf: function(e, n) {
            return n.unshift(e), h.apply(null, n);
        },
        toNumber: function(e, n) {
            return e ? (e = g.trim(e), e.match(/^-?\d+(?:\.\d+)?$/) ? l(l(e).toFixed(~~n)) : 0 / 0) : 0;
        },
        numberFormat: function(e, n, r, t) {
            if (isNaN(e) || null == e) return "";
            e = e.toFixed(~~n), t = "string" == typeof t ? t : ",";
            var u = e.split("."), i = u[0], l = u[1] ? (r || ".") + u[1] : "";
            return i.replace(/(\d)(?=(?:\d{3})+$)/g, "$1" + t) + l;
        },
        strRight: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.indexOf(r) : -1;
            return ~t ? e.slice(t + r.length, e.length) : e;
        },
        strRightBack: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.lastIndexOf(r) : -1;
            return ~t ? e.slice(t + r.length, e.length) : e;
        },
        strLeft: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.indexOf(r) : -1;
            return ~t ? e.slice(0, t) : e;
        },
        strLeftBack: function(e, n) {
            if (null == e) return "";
            e += "", n = null != n ? "" + n : n;
            var r = e.lastIndexOf(n);
            return ~r ? e.slice(0, r) : e;
        },
        toSentence: function(e, n, r, t) {
            n = n || ", ", r = r || " and ";
            var u = e.slice(), i = u.pop();
            return e.length > 2 && t && (r = g.rtrim(n) + r), u.length ? u.join(n) + r + i : i;
        },
        toSentenceSerial: function() {
            var e = a.call(arguments);
            return e[3] = !0, g.toSentence.apply(g, e);
        },
        slugify: function(e) {
            if (null == e) return "";
            var r = "ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź", t = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz", u = new RegExp(c(r), "g");
            return e = n(e).toLowerCase().replace(u, function(e) {
                var n = r.indexOf(e);
                return t.charAt(n) || "-";
            }), g.dasherize(e.replace(/[^\w\s-]/g, ""));
        },
        surround: function(e, n) {
            return [ n, e, n ].join("");
        },
        quote: function(e, n) {
            return g.surround(e, n || '"');
        },
        unquote: function(e, n) {
            return n = n || '"', e[0] === n && e[e.length - 1] === n ? e.slice(1, e.length - 1) : e;
        },
        exports: function() {
            var e = {};
            for (var n in this) this.hasOwnProperty(n) && !n.match(/^(?:include|contains|reverse)$/) && (e[n] = this[n]);
            return e;
        },
        repeat: function(e, r, t) {
            if (null == e) return "";
            if (r = ~~r, null == t) return o(n(e), r);
            for (var u = []; r > 0; u[--r] = e) ;
            return u.join(t);
        },
        naturalCmp: function(e, r) {
            if (e == r) return 0;
            if (!e) return -1;
            if (!r) return 1;
            for (var t = /(\.\d+)|(\d+)|(\D+)/g, u = n(e).toLowerCase().match(t), i = n(r).toLowerCase().match(t), l = Math.min(u.length, i.length), o = 0; l > o; o++) {
                var a = u[o], c = i[o];
                if (a !== c) {
                    var s = parseInt(a, 10);
                    if (!isNaN(s)) {
                        var f = parseInt(c, 10);
                        if (!isNaN(f) && s - f) return s - f;
                    }
                    return c > a ? -1 : 1;
                }
            }
            return u.length === i.length ? u.length - i.length : r > e ? -1 : 1;
        },
        levenshtein: function(e, r) {
            if (null == e && null == r) return 0;
            if (null == e) return n(r).length;
            if (null == r) return n(e).length;
            e = n(e), r = n(r);
            for (var t, u, i = [], l = 0; l <= r.length; l++) for (var o = 0; o <= e.length; o++) u = l && o ? e.charAt(o - 1) === r.charAt(l - 1) ? t : Math.min(i[o], i[o - 1], t) + 1 : l + o, 
            t = i[o], i[o] = u;
            return i.pop();
        },
        toBoolean: function(e, n, t) {
            return "number" == typeof e && (e = "" + e), "string" != typeof e ? !!e : (e = g.trim(e), 
            r(e, n || [ "true", "1" ]) ? !0 : r(e, t || [ "false", "0" ]) ? !1 : void 0);
        }
    };
    g.strip = g.trim, g.lstrip = g.ltrim, g.rstrip = g.rtrim, g.center = g.lrpad, g.rjust = g.lpad, 
    g.ljust = g.rpad, g.contains = g.include, g.q = g.quote, g.toBool = g.toBoolean, 
    "undefined" != typeof exports && ("undefined" != typeof module && module.exports && (module.exports = g), 
    exports._s = g), "function" == typeof define && define.amd && define("underscore.string", [], function() {
        return g;
    }), e._ = e._ || {}, e._.string = e._.str = g;
}(this, String);

(function(window, document, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [ "", "webkit", "moz", "MS", "ms", "o" ];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [ "x", "y" ];
    var PROPS_CLIENT_XY = [ "clientX", "clientY" ];
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [ manager ])) {
                self.handler(ev);
            }
        };
        this.init();
    }
    Input.prototype = {
        handler: function() {},
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true;
        this.pressed = false;
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }
            if (!this.pressed || !this.allow) {
                return;
            }
            if (eventType & INPUT_END) {
                this.pressed = false;
            }
            this.callback(this.manager, eventType, {
                pointers: [ ev ],
                changedPointers: [ ev ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    if (window.MSPointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }
            if (storeIndex < 0) {
                return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ ev ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) {
                store.splice(storeIndex, 1);
            }
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START) {
                this.started = true;
            }
            if (!this.started) {
                return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [ all, changed ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [ allTouches, allTouches ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [ uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true), changedTargetTouches ];
    }
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }
    inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isTouch) {
                this.mouse.allow = false;
            } else if (isMouse && !this.mouse.allow) {
                return;
            }
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                this.mouse.allow = true;
            }
            this.callback(manager, inputEvent, inputData);
        },
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation";
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        update: function() {
            this.set(this.manager.options.touchAction);
        },
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [ recognizer ])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(" "));
        },
        preventDefaults: function(input) {
            if (NATIVE_TOUCH_ACTION) {
                return;
            }
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                return this.preventSrc(srcEvent);
            }
        },
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + " " + TOUCH_ACTION_PAN_Y;
        }
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        defaults: {},
        set: function(options) {
            extend(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
        },
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        emit: function(input) {
            var self = this;
            var state = this.state;
            function emit(withState) {
                self.manager.emit(self.options.event + (withState ? stateStr(state) : ""), input);
            }
            if (state < STATE_ENDED) {
                emit(true);
            }
            emit();
            if (state >= STATE_ENDED) {
                emit(true);
            }
        },
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            this.state = STATE_FAILED;
        },
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },
        recognize: function(inputData) {
            var inputDataClone = extend({}, inputData);
            if (!boolOrFn(this.options.enable, [ this, inputDataClone ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },
        process: function(inputData) {},
        getTouchAction: function() {},
        reset: function() {}
    };
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return "cancel";
        } else if (state & STATE_ENDED) {
            return "end";
        } else if (state & STATE_CHANGED) {
            return "move";
        } else if (state & STATE_BEGAN) {
            return "start";
        }
        return "";
    }
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return "down";
        } else if (direction == DIRECTION_UP) {
            return "up";
        } else if (direction == DIRECTION_LEFT) {
            return "left";
        } else if (direction == DIRECTION_RIGHT) {
            return "right";
        }
        return "";
    }
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        defaults: {
            pointers: 1
        },
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this._super.emit.call(this, input);
        }
    });
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            this._super.emit.call(this, input);
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                this.manager.emit(this.options.event + inOut, input);
            }
        }
    });
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        defaults: {
            event: "press",
            pointers: 1,
            time: 500,
            threshold: 5
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_AUTO ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }
            if (input && input.eventType & INPUT_END) {
                this.manager.emit(this.options.event + "up", input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
            event: "swipe",
            threshold: 10,
            velocity: .65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.velocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.velocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.velocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
        }
    });
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 2,
            posThreshold: 10
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_MANIPULATION ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
                return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    Hammer.VERSION = "2.0.4";
    Hammer.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [ [ RotateRecognizer, {
            enable: false
        } ], [ PinchRecognizer, {
            enable: false
        }, [ "rotate" ] ], [ SwipeRecognizer, {
            direction: DIRECTION_HORIZONTAL
        } ], [ PanRecognizer, {
            direction: DIRECTION_HORIZONTAL
        }, [ "swipe" ] ], [ TapRecognizer ], [ TapRecognizer, {
            event: "doubletap",
            taps: 2
        }, [ "tap" ] ], [ PressRecognizer ] ],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        set: function(options) {
            extend(this.options, options);
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
                return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
                return this;
            }
            var recognizers = this.recognizers;
            recognizer = this.get(recognizer);
            recognizers.splice(inArray(recognizers, recognizer), 1);
            this.touchAction.update();
            return this;
        },
        on: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        off: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },
        emit: function(event, data) {
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },
        destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function(value, name) {
            element.style[prefixed(element.style, name)] = add ? value : "";
        });
    }
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    extend(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    if (typeof define == TYPE_FUNCTION && define.amd) {
        define(function() {
            return Hammer;
        });
    } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }
})(window, document, "Hammer");

(function(undefined) {
    var moment, VERSION = "2.8.4", globalScope = typeof global !== "undefined" ? global : this, oldGlobalMoment, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.localeData().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.localeData().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        x: function() {
            return this.valueOf();
        },
        X: function() {
            return this.unix();
        },
        Q: function() {
            return this.quarter();
        }
    }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ];
    function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return a != null ? a : b;

          case 3:
            return a != null ? a : b != null ? b : c;

          default:
            throw new Error("Implement me");
        }
    }
    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    function Locale() {}
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble();
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = from._pf;
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day";
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month";
        } else {
            return;
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "");
            };
            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 || m._a[SECOND] !== 0 || m._a[MILLISECOND] !== 0) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            m._pf.overflow = overflow;
        }
    }
    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0 && m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require("./locale/" + name);
                moment.locale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res;
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }
    extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName, format, strict) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                mom = moment.utc([ 2e3, i ]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                    this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([ 2e3, 1 ]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        isPM: function(input) {
            return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom, now) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom, [ now ]) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            doy: 6
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    });
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;

          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;

          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;

          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;

          case "S":
            if (strict) {
                return parseTokenOneDigit;
            }

          case "SS":
            if (strict) {
                return parseTokenTwoDigits;
            }

          case "SSS":
            if (strict) {
                return parseTokenThreeDigits;
            }

          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return config._locale._meridiemParse;

          case "x":
            return parseTokenOffsetMs;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;

          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          case "Do":
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;

          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
    }
    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? -minutes : minutes;
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;

          case "M":
          case "MM":
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;

          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input, token, config._strict);
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;

          case "D":
          case "DD":
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;

          case "Do":
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10));
            }
            break;

          case "DDD":
          case "DDDD":
            if (input != null) {
                config._dayOfYear = toInt(input);
            }
            break;

          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;

          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          case "a":
          case "A":
            config._isPm = config._locale.isPM(input);
            break;

          case "h":
          case "hh":
            config._pf.bigHour = true;

          case "H":
          case "HH":
            datePartArray[HOUR] = toInt(input);
            break;

          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;

          case "x":
            config._d = new Date(toInt(input));
            break;

          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          case "Z":
          case "ZZ":
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;

          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input);
            if (a != null) {
                config._w = config._w || {};
                config._w["d"] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);

          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;

          case "gg":
          case "GG":
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
            return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
            return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
    }
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            currentScore += tempConfig._pf.charsLeftOver;
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof input === "object") {
            dateFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }
    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function parseWeekday(input, locale) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function makeMoment(config) {
        var input = config._i, format = config._f, res;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") {
            return moment.invalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        res = new Moment(config);
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c);
    };
    moment.suppressDeprecationWarnings = false;
    moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    };
    moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    };
    moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc();
    };
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    moment.duration = function(input, key) {
        var duration = input, match = null, sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.ISO_8601 = function() {};
    moment.momentProperties = momentProperties;
    moment.updateOffset = function() {};
    moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };
    moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
    });
    moment.locale = function(key, values) {
        var data;
        if (key) {
            if (typeof values !== "undefined") {
                data = moment.defineLocale(key, values);
            } else {
                data = moment.localeData(key);
            }
            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }
        return moment._locale._abbr;
    };
    moment.defineLocale = function(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);
            moment.locale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    };
    moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
    });
    moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return moment._locale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    };
    moment.isMoment = function(obj) {
        return obj instanceof Moment || obj != null && hasOwnProp(obj, "_isAMomentObject");
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }
        return m;
    };
    moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
    };
    moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d + (this._offset || 0) * 6e4;
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ("function" === typeof Date.prototype.toISOString) {
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                }
            } else {
                return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }
            return false;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;
                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), "m");
                }
            }
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var that = makeAs(input, this), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output, daysAdjust;
            units = normalizeUnits(units);
            if (units === "year" || units === "month") {
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
                output = (this.year() - that.year()) * 12 + (this.month() - that.month());
                daysAdjust = this - moment(this).startOf("month") - (that - moment(that).startOf("month"));
                daysAdjust -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, "d");
            } else {
                return day;
            }
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
            units = normalizeUnits(units);
            switch (units) {
              case "year":
                this.month(0);

              case "quarter":
              case "month":
                this.date(1);

              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            if (units === "week") {
                this.weekday(0);
            } else if (units === "isoWeek") {
                this.isoWeekday(1);
            }
            if (units === "quarter") {
                this.month(Math.floor(this.month() / 3) * 3);
            }
            return this;
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            if (units === undefined || units === "millisecond") {
                return this;
            }
            return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },
        isBefore: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },
        isSame: function(input, units) {
            var inputMs;
            units = normalizeUnits(units || "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
            }
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        }),
        zone: function(input, keepLocalTime) {
            var offset = this._offset || 0, localAdjust;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, "m");
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === "string") {
                this.zone(this._i);
            }
            return this;
        },
        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).zone();
            }
            return (this.zone() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add(input - year, "y");
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },
        set: function(units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                this[units](value);
            }
            return this;
        },
        locale: function(key) {
            var newLocaleData;
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }),
        localeData: function() {
            return this._locale;
        },
        _dateTzOffset: function() {
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });
    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function rawSetter(mom, unit, value) {
        if (unit === "Month") {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
    }
    function makeAccessor(unit, keepTime) {
        return function(value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
    moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
    moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
    moment.fn.date = makeAccessor("Date", true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
    moment.fn.year = makeAccessor("FullYear", true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;
    moment.fn.toJSON = moment.fn.toISOString;
    function daysToYears(days) {
        return days * 400 / 146097;
    }
    function yearsToDays(years) {
        return years * 146097 / 400;
    }
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
            data.milliseconds = milliseconds % 1e3;
            seconds = absRound(milliseconds / 1e3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));
            months += absRound(days / 30);
            days %= 30;
            years += absRound(months / 12);
            months %= 12;
            data.days = days;
            data.months = months;
            data.years = years;
        },
        abs: function() {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);
            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);
            return this;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }
            return this.localeData().postformat(output);
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this;
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            var days, months;
            units = normalizeUnits(units);
            if (units === "month" || units === "year") {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === "month" ? months : months / 12;
            } else {
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                  case "week":
                    return days / 7 + this._milliseconds / 6048e5;

                  case "day":
                    return days + this._milliseconds / 864e5;

                  case "hour":
                    return days * 24 + this._milliseconds / 36e5;

                  case "minute":
                    return days * 24 * 60 + this._milliseconds / 6e4;

                  case "second":
                    return days * 24 * 60 * 60 + this._milliseconds / 1e3;

                  case "millisecond":
                    return Math.floor(days * 24 * 60 * 60 * 1e3) + this._milliseconds;

                  default:
                    throw new Error("Unknown unit " + units);
                }
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
            return this.toISOString();
        }),
        toISOString: function() {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            if (!this.asSeconds()) {
                return "P0D";
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        },
        localeData: function() {
            return this._locale;
        }
    });
    moment.duration.fn.toString = moment.duration.fn.toISOString;
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
    };
    moment.duration.fn.asSeconds = function() {
        return this.as("s");
    };
    moment.duration.fn.asMinutes = function() {
        return this.as("m");
    };
    moment.duration.fn.asHours = function() {
        return this.as("h");
    };
    moment.duration.fn.asDays = function() {
        return this.as("d");
    };
    moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
    };
    moment.duration.fn.asMonths = function() {
        return this.as("M");
    };
    moment.duration.fn.asYears = function() {
        return this.as("y");
    };
    moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        } else {
            globalScope.moment = moment;
        }
    }
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", function(require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                globalScope.moment = oldGlobalMoment;
            }
            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

(function() {
    var root = this;
    var PIXI = PIXI || {};
    PIXI.WEBGL_RENDERER = 0;
    PIXI.CANVAS_RENDERER = 1;
    PIXI.VERSION = "v1.6.1";
    PIXI.blendModes = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
    };
    PIXI.scaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
    };
    PIXI._UID = 0;
    if (typeof Float32Array != "undefined") {
        PIXI.Float32Array = Float32Array;
        PIXI.Uint16Array = Uint16Array;
    } else {
        PIXI.Float32Array = Array;
        PIXI.Uint16Array = Array;
    }
    PIXI.INTERACTION_FREQUENCY = 30;
    PIXI.AUTO_PREVENT_DEFAULT = true;
    PIXI.RAD_TO_DEG = 180 / Math.PI;
    PIXI.DEG_TO_RAD = Math.PI / 180;
    PIXI.dontSayHello = false;
    PIXI.sayHello = function(type) {
        if (PIXI.dontSayHello) return;
        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            var args = [ "%c %c %c Pixi.js " + PIXI.VERSION + " - " + type + "  %c " + " %c " + " http://www.pixijs.com/  %c %c ♥%c♥%c♥ ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff" ];
            console.log.apply(console, args);
        } else if (window["console"]) {
            console.log("Pixi.js " + PIXI.VERSION + " - http://www.pixijs.com/");
        }
        PIXI.dontSayHello = true;
    };
    PIXI.Matrix = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
    };
    PIXI.Matrix.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    };
    PIXI.Matrix.prototype.toArray = function(transpose) {
        if (!this.array) this.array = new Float32Array(9);
        var array = this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = 0;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = this.tx;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    };
    PIXI.Matrix.prototype.apply = function(pos, newPos) {
        newPos = newPos || new PIXI.Point();
        newPos.x = this.a * pos.x + this.b * pos.y + this.tx;
        newPos.y = this.c * pos.x + this.d * pos.y + this.ty;
        return newPos;
    };
    PIXI.Matrix.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new PIXI.Point();
        var id = 1 / (this.a * this.d + this.b * -this.c);
        newPos.x = this.d * id * pos.x - this.b * id * pos.y + (this.ty * this.b - this.tx * this.d) * id;
        newPos.y = this.a * id * pos.y - this.c * id * pos.x + (this.tx * this.c - this.ty * this.a) * id;
        return newPos;
    };
    PIXI.identityMatrix = new PIXI.Matrix();
    PIXI.determineMatrixArrayType = function() {
        return typeof Float32Array !== "undefined" ? Float32Array : Array;
    };
    PIXI.Matrix2 = PIXI.determineMatrixArrayType();
    PIXI.DisplayObject = function() {
        this.position = new PIXI.Point();
        this.scale = new PIXI.Point(1, 1);
        this.pivot = new PIXI.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.buttonMode = false;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this._interactive = false;
        this.defaultCursor = "pointer";
        this.worldTransform = new PIXI.Matrix();
        this.color = [];
        this.dynamic = true;
        this._sr = 0;
        this._cr = 1;
        this.filterArea = null;
        this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
        this._currentBounds = null;
        this._mask = null;
        this._cacheAsBitmap = false;
        this._cacheIsDirty = false;
    };
    PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;
    PIXI.DisplayObject.prototype.setInteractive = function(interactive) {
        this.interactive = interactive;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive;
        },
        set: function(value) {
            this._interactive = value;
            if (this.stage) this.stage.dirty = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var item = this;
            do {
                if (!item.visible) return false;
                item = item.parent;
            } while (item);
            return true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(value) {
            if (this._mask) this._mask.isMask = false;
            this._mask = value;
            if (this._mask) this._mask.isMask = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters;
        },
        set: function(value) {
            if (value) {
                var passes = [];
                for (var i = 0; i < value.length; i++) {
                    var filterPasses = value[i].passes;
                    for (var j = 0; j < filterPasses.length; j++) {
                        passes.push(filterPasses[j]);
                    }
                }
                this._filterBlock = {
                    target: this,
                    filterPasses: passes
                };
            }
            this._filters = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            if (this._cacheAsBitmap === value) return;
            if (value) {
                this._generateCachedSprite();
            } else {
                this._destroyCachedSprite();
            }
            this._cacheAsBitmap = value;
        }
    });
    PIXI.DisplayObject.prototype.updateTransform = function() {
        if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
        }
        var parentTransform = this.parent.worldTransform;
        var worldTransform = this.worldTransform;
        var px = this.pivot.x;
        var py = this.pivot.y;
        var a00 = this._cr * this.scale.x, a01 = -this._sr * this.scale.y, a10 = this._sr * this.scale.x, a11 = this._cr * this.scale.y, a02 = this.position.x - a00 * px - py * a01, a12 = this.position.y - a11 * py - px * a10, b00 = parentTransform.a, b01 = parentTransform.b, b10 = parentTransform.c, b11 = parentTransform.d;
        worldTransform.a = b00 * a00 + b01 * a10;
        worldTransform.b = b00 * a01 + b01 * a11;
        worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;
        worldTransform.c = b10 * a00 + b11 * a10;
        worldTransform.d = b10 * a01 + b11 * a11;
        worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
    };
    PIXI.DisplayObject.prototype.getBounds = function(matrix) {
        matrix = matrix;
        return PIXI.EmptyRectangle;
    };
    PIXI.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(PIXI.identityMatrix);
    };
    PIXI.DisplayObject.prototype.setStageReference = function(stage) {
        this.stage = stage;
        if (this._interactive) this.stage.dirty = true;
    };
    PIXI.DisplayObject.prototype.generateTexture = function(renderer) {
        var bounds = this.getLocalBounds();
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);
        renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y));
        return renderTexture;
    };
    PIXI.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite();
    };
    PIXI.DisplayObject.prototype.toGlobal = function(pos) {
        this.updateTransform();
        return this.worldTransform.apply(pos);
    };
    PIXI.DisplayObject.prototype.toLocal = function(pos, from) {
        if (from) {
            pos = from.toGlobal(pos);
        }
        this.updateTransform();
        return this.worldTransform.applyInverse(pos);
    };
    PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession) {
        this._cachedSprite.worldAlpha = this.worldAlpha;
        if (renderSession.gl) {
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
        } else {
            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
        }
    };
    PIXI.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = false;
        var bounds = this.getLocalBounds();
        if (!this._cachedSprite) {
            var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);
            this._cachedSprite = new PIXI.Sprite(renderTexture);
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);
        }
        var tempFilters = this._filters;
        this._filters = null;
        this._cachedSprite.filters = tempFilters;
        this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y));
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._filters = tempFilters;
        this._cacheAsBitmap = true;
    };
    PIXI.DisplayObject.prototype._destroyCachedSprite = function() {
        if (!this._cachedSprite) return;
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.DisplayObject.prototype._renderWebGL = function(renderSession) {
        renderSession = renderSession;
    };
    PIXI.DisplayObject.prototype._renderCanvas = function(renderSession) {
        renderSession = renderSession;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    PIXI.DisplayObjectContainer = function() {
        PIXI.DisplayObject.call(this);
        this.children = [];
    };
    PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype);
    PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
            var width = this.getLocalBounds().width;
            if (width !== 0) {
                this.scale.x = value / (width / this.scale.x);
            } else {
                this.scale.x = 1;
            }
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
            var height = this.getLocalBounds().height;
            if (height !== 0) {
                this.scale.y = value / (height / this.scale.y);
            } else {
                this.scale.y = 1;
            }
            this._height = value;
        }
    });
    PIXI.DisplayObjectContainer.prototype.addChild = function(child) {
        return this.addChildAt(child, this.children.length);
    };
    PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index) {
        if (index >= 0 && index <= this.children.length) {
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.children.splice(index, 0, child);
            if (this.stage) child.setStageReference(this.stage);
            return child;
        } else {
            throw new Error(child + " The index " + index + " supplied is out of bounds " + this.children.length);
        }
    };
    PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.children.indexOf(child);
        var index2 = this.children.indexOf(child2);
        if (index1 < 0 || index2 < 0) {
            throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
        }
        this.children[index1] = child2;
        this.children[index2] = child;
    };
    PIXI.DisplayObjectContainer.prototype.getChildAt = function(index) {
        if (index >= 0 && index < this.children.length) {
            return this.children[index];
        } else {
            throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeChild = function(child) {
        return this.removeChildAt(this.children.indexOf(child));
    };
    PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        if (this.stage) child.removeStageReference();
        child.parent = undefined;
        this.children.splice(index, 1);
        return child;
    };
    PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex) {
        var begin = beginIndex || 0;
        var end = typeof endIndex === "number" ? endIndex : this.children.length;
        var range = end - begin;
        if (range > 0 && range <= end) {
            var removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; i++) {
                var child = removed[i];
                if (this.stage) child.removeStageReference();
                child.parent = undefined;
            }
            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return [];
        } else {
            throw new Error("Range Error, numeric values are outside the acceptable range");
        }
    };
    PIXI.DisplayObjectContainer.prototype.updateTransform = function() {
        if (!this.visible) return;
        PIXI.DisplayObject.prototype.updateTransform.call(this);
        if (this._cacheAsBitmap) return;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
    };
    PIXI.DisplayObjectContainer.prototype.getBounds = function(matrix) {
        if (this.children.length === 0) return PIXI.EmptyRectangle;
        if (matrix) {
            var matrixCache = this.worldTransform;
            this.worldTransform = matrix;
            this.updateTransform();
            this.worldTransform = matrixCache;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var childBounds;
        var childMaxX;
        var childMaxY;
        var childVisible = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            childVisible = true;
            childBounds = this.children[i].getBounds(matrix);
            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;
            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;
            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }
        if (!childVisible) return PIXI.EmptyRectangle;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var matrixCache = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        var bounds = this.getBounds();
        this.worldTransform = matrixCache;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage) {
        this.stage = stage;
        if (this._interactive) this.stage.dirty = true;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child.setStageReference(stage);
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child.removeStageReference();
        }
        if (this._interactive) this.stage.dirty = true;
        this.stage = null;
    };
    PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        var i, j;
        if (this._mask || this._filters) {
            if (this._filters) {
                renderSession.spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                renderSession.spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                renderSession.spriteBatch.start();
            }
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            renderSession.spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            renderSession.spriteBatch.start();
        } else {
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
        }
    };
    PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Sprite = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.anchor = new PIXI.Point();
        this.texture = texture;
        this._width = 0;
        this._height = 0;
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
        if (texture.baseTexture.hasLoaded) {
            this.onTextureUpdate();
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind);
        }
        this.renderable = true;
    };
    PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Sprite.prototype.constructor = PIXI.Sprite;
    Object.defineProperty(PIXI.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Sprite.prototype.setTexture = function(texture) {
        this.texture = texture;
        this.cachedTint = 16777215;
    };
    PIXI.Sprite.prototype.onTextureUpdate = function() {
        if (this._width) this.scale.x = this._width / this.texture.frame.width;
        if (this._height) this.scale.y = this._height / this.texture.frame.height;
    };
    PIXI.Sprite.prototype.getBounds = function(matrix) {
        var width = this.texture.frame.width;
        var height = this.texture.frame.height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.Sprite.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        var i, j;
        if (this._mask || this._filters) {
            var spriteBatch = renderSession.spriteBatch;
            if (this._filters) {
                spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                spriteBatch.start();
            }
            spriteBatch.render(this);
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            spriteBatch.start();
        } else {
            renderSession.spriteBatch.render(this);
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
        }
    };
    PIXI.Sprite.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.texture.crop.width <= 0 || this.texture.crop.height <= 0) return;
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        if (this.texture.valid) {
            renderSession.context.globalAlpha = this.worldAlpha;
            if (renderSession.roundPixels) {
                renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx | 0, this.worldTransform.ty | 0);
            } else {
                renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx, this.worldTransform.ty);
            }
            if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {
                renderSession.scaleMode = this.texture.baseTexture.scaleMode;
                renderSession.context[renderSession.smoothProperty] = renderSession.scaleMode === PIXI.scaleModes.LINEAR;
            }
            var dx = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
            var dy = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
            if (this.tint !== 16777215) {
                if (this.cachedTint !== this.tint) {
                    this.cachedTint = this.tint;
                    this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
                }
                renderSession.context.drawImage(this.tintedTexture, 0, 0, this.texture.crop.width, this.texture.crop.height, dx, dy, this.texture.crop.width, this.texture.crop.height);
            } else {
                renderSession.context.drawImage(this.texture.baseTexture.source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, dx, dy, this.texture.crop.width, this.texture.crop.height);
            }
        }
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Sprite.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
        return new PIXI.Sprite(texture);
    };
    PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode) {
        var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
        return new PIXI.Sprite(texture);
    };
    PIXI.SpriteBatch = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.textureThing = texture;
        this.ready = false;
    };
    PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.SpriteBatch.constructor = PIXI.SpriteBatch;
    PIXI.SpriteBatch.prototype.initWebGL = function(gl) {
        this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);
        this.ready = true;
    };
    PIXI.SpriteBatch.prototype.updateTransform = function() {
        PIXI.DisplayObject.prototype.updateTransform.call(this);
    };
    PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0 || !this.children.length) return;
        if (!this.ready) this.initWebGL(renderSession.gl);
        renderSession.spriteBatch.stop();
        renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);
        this.fastSpriteBatch.begin(this, renderSession);
        this.fastSpriteBatch.render(this);
        renderSession.spriteBatch.start();
    };
    PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession) {
        var context = renderSession.context;
        context.globalAlpha = this.worldAlpha;
        PIXI.DisplayObject.prototype.updateTransform.call(this);
        var transform = this.worldTransform;
        var isRotated = true;
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            var texture = child.texture;
            var frame = texture.frame;
            context.globalAlpha = this.worldAlpha * child.alpha;
            if (child.rotation % (Math.PI * 2) === 0) {
                if (isRotated) {
                    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
                    isRotated = false;
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * (-frame.width * child.scale.x) + child.position.x + .5 | 0, child.anchor.y * (-frame.height * child.scale.y) + child.position.y + .5 | 0, frame.width * child.scale.x, frame.height * child.scale.y);
            } else {
                if (!isRotated) isRotated = true;
                PIXI.DisplayObject.prototype.updateTransform.call(child);
                var childTransform = child.worldTransform;
                if (renderSession.roundPixels) {
                    context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
                } else {
                    context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width + .5 | 0, child.anchor.y * -frame.height + .5 | 0, frame.width, frame.height);
            }
        }
    };
    PIXI.AbstractFilter = function(fragmentSrc, uniforms) {
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = uniforms || {};
        this.fragmentSrc = fragmentSrc || [];
    };
    PIXI.FilterBlock = function() {
        this.visible = true;
        this.renderable = true;
    };
    PIXI.Text = function(text, style) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));
        this.setText(text);
        this.setStyle(style);
    };
    PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.Text.prototype.constructor = PIXI.Text;
    Object.defineProperty(PIXI.Text.prototype, "width", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Text.prototype, "height", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        style.dropShadow = style.dropShadow || false;
        style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
        style.dropShadowDistance = style.dropShadowDistance || 4;
        style.dropShadowColor = style.dropShadowColor || "black";
        this.style = style;
        this.dirty = true;
    };
    PIXI.Text.prototype.setText = function(text) {
        this.text = text.toString() || " ";
        this.dirty = true;
    };
    PIXI.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) outputText = this.wordWrap(this.text);
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = [];
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width;
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + this.style.strokeThickness;
        if (this.style.dropShadow) width += this.style.dropShadowDistance;
        this.canvas.width = width + this.context.lineWidth;
        var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
        var height = lineHeight * lines.length;
        if (this.style.dropShadow) height += this.style.dropShadowDistance;
        this.canvas.height = height;
        if (navigator.isCocoonJS) this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.textBaseline = "top";
        var linePositionX;
        var linePositionY;
        if (this.style.dropShadow) {
            this.context.fillStyle = this.style.dropShadowColor;
            var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            for (i = 0; i < lines.length; i++) {
                linePositionX = this.style.strokeThickness / 2;
                linePositionY = this.style.strokeThickness / 2 + i * lineHeight;
                if (this.style.align === "right") {
                    linePositionX += maxLineWidth - lineWidths[i];
                } else if (this.style.align === "center") {
                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;
                }
                if (this.style.fill) {
                    this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
                }
            }
        }
        this.context.fillStyle = this.style.fill;
        for (i = 0; i < lines.length; i++) {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;
            if (this.style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(lines[i], linePositionX, linePositionY);
            }
            if (this.style.fill) {
                this.context.fillText(lines[i], linePositionX, linePositionY);
            }
        }
        this.updateTexture();
    };
    PIXI.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.crop.width = this.texture.frame.width = this.canvas.width;
        this.texture.crop.height = this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        this.requiresUpdate = true;
    };
    PIXI.Text.prototype._renderWebGL = function(renderSession) {
        if (this.requiresUpdate) {
            this.requiresUpdate = false;
            PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);
        }
        PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
    };
    PIXI.Text.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.Sprite.prototype.updateTransform.call(this);
    };
    PIXI.Text.prototype.determineFontHeight = function(fontStyle) {
        var result = PIXI.Text.heightCache[fontStyle];
        if (!result) {
            var body = document.getElementsByTagName("body")[0];
            var dummy = document.createElement("div");
            var dummyText = document.createTextNode("M");
            dummy.appendChild(dummyText);
            dummy.setAttribute("style", fontStyle + ";position:absolute;top:0;left:0");
            body.appendChild(dummy);
            result = dummy.offsetHeight;
            PIXI.Text.heightCache[fontStyle] = result;
            body.removeChild(dummy);
        }
        return result;
    };
    PIXI.Text.prototype.wordWrap = function(text) {
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = this.style.wordWrapWidth;
            var words = lines[i].split(" ");
            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;
                var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                        result += "\n";
                    }
                    result += words[j];
                    spaceLeft = this.style.wordWrapWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += " " + words[j];
                }
            }
            if (i < lines.length - 1) {
                result += "\n";
            }
        }
        return result;
    };
    PIXI.Text.prototype.destroy = function(destroyBaseTexture) {
        this.context = null;
        this.canvas = null;
        this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
    };
    PIXI.Text.heightCache = {};
    PIXI.BitmapText = function(text, style) {
        PIXI.DisplayObjectContainer.call(this);
        this._pool = [];
        this.setText(text);
        this.setStyle(style);
        this.updateText();
        this.dirty = false;
    };
    PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;
    PIXI.BitmapText.prototype.setText = function(text) {
        this.text = text || " ";
        this.dirty = true;
    };
    PIXI.BitmapText.prototype.setStyle = function(style) {
        style = style || {};
        style.align = style.align || "left";
        this.style = style;
        var font = style.font.split(" ");
        this.fontName = font[font.length - 1];
        this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;
        this.dirty = true;
        this.tint = style.tint;
    };
    PIXI.BitmapText.prototype.updateText = function() {
        var data = PIXI.BitmapText.fonts[this.fontName];
        var pos = new PIXI.Point();
        var prevCharCode = null;
        var chars = [];
        var maxLineWidth = 0;
        var lineWidths = [];
        var line = 0;
        var scale = this.fontSize / data.size;
        for (var i = 0; i < this.text.length; i++) {
            var charCode = this.text.charCodeAt(i);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) {
                lineWidths.push(pos.x);
                maxLineWidth = Math.max(maxLineWidth, pos.x);
                line++;
                pos.x = 0;
                pos.y += data.lineHeight;
                prevCharCode = null;
                continue;
            }
            var charData = data.chars[charCode];
            if (!charData) continue;
            if (prevCharCode && charData[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }
            chars.push({
                texture: charData.texture,
                line: line,
                charCode: charCode,
                position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
            });
            pos.x += charData.xAdvance;
            prevCharCode = charCode;
        }
        lineWidths.push(pos.x);
        maxLineWidth = Math.max(maxLineWidth, pos.x);
        var lineAlignOffsets = [];
        for (i = 0; i <= line; i++) {
            var alignOffset = 0;
            if (this.style.align === "right") {
                alignOffset = maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                alignOffset = (maxLineWidth - lineWidths[i]) / 2;
            }
            lineAlignOffsets.push(alignOffset);
        }
        var lenChildren = this.children.length;
        var lenChars = chars.length;
        var tint = this.tint || 16777215;
        for (i = 0; i < lenChars; i++) {
            var c = i < lenChildren ? this.children[i] : this._pool.pop();
            if (c) c.setTexture(chars[i].texture); else c = new PIXI.Sprite(chars[i].texture);
            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
            c.position.y = chars[i].position.y * scale;
            c.scale.x = c.scale.y = scale;
            c.tint = tint;
            if (!c.parent) this.addChild(c);
        }
        while (this.children.length > lenChars) {
            var child = this.getChildAt(this.children.length - 1);
            this._pool.push(child);
            this.removeChild(child);
        }
        this.textWidth = maxLineWidth * scale;
        this.textHeight = (pos.y + data.lineHeight) * scale;
    };
    PIXI.BitmapText.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.BitmapText.fonts = {};
    PIXI.Stage = function(backgroundColor) {
        PIXI.DisplayObjectContainer.call(this);
        this.worldTransform = new PIXI.Matrix();
        this.interactive = true;
        this.interactionManager = new PIXI.InteractionManager(this);
        this.dirty = true;
        this.stage = this;
        this.stage.hitArea = new PIXI.Rectangle(0, 0, 1e5, 1e5);
        this.setBackgroundColor(backgroundColor);
    };
    PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Stage.prototype.constructor = PIXI.Stage;
    PIXI.Stage.prototype.setInteractionDelegate = function(domElement) {
        this.interactionManager.setTargetDomElement(domElement);
    };
    PIXI.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        if (this.dirty) {
            this.dirty = false;
            this.interactionManager.dirty = true;
        }
        if (this.interactive) this.interactionManager.update();
    };
    PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        this.backgroundColor = backgroundColor || 0;
        this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
        var hex = this.backgroundColor.toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;
        this.backgroundColorString = "#" + hex;
    };
    PIXI.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global;
    };
    (function(window) {
        var lastTime = 0;
        var vendors = [ "ms", "moz", "webkit", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
        window.requestAnimFrame = window.requestAnimationFrame;
    })(this);
    PIXI.hex2rgb = function(hex) {
        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255 ];
    };
    PIXI.rgb2hex = function(rgb) {
        return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
    };
    if (typeof Function.prototype.bind !== "function") {
        Function.prototype.bind = function() {
            return function(thisArg) {
                var target = this, i = arguments.length - 1, boundArgs = [];
                if (i > 0) {
                    boundArgs.length = i;
                    while (i--) boundArgs[i] = arguments[i + 1];
                }
                if (typeof target !== "function") throw new TypeError();
                function bound() {
                    var i = arguments.length, args = new Array(i);
                    while (i--) args[i] = arguments[i];
                    args = boundArgs.concat(args);
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    if (proto) F.prototype = proto;
                    if (!(this instanceof F)) return new F();
                }(target.prototype);
                return bound;
            };
        }();
    }
    PIXI.AjaxRequest = function() {
        var activexmodes = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP" ];
        if (window.ActiveXObject) {
            for (var i = 0; i < activexmodes.length; i++) {
                try {
                    return new window.ActiveXObject(activexmodes[i]);
                } catch (e) {}
            }
        } else if (window.XMLHttpRequest) {
            return new window.XMLHttpRequest();
        } else {
            return false;
        }
    };
    PIXI.canUseNewCanvasBlendModes = function() {
        if (typeof document === "undefined") return false;
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        var context = canvas.getContext("2d");
        context.fillStyle = "#000";
        context.fillRect(0, 0, 1, 1);
        context.globalCompositeOperation = "multiply";
        context.fillStyle = "#fff";
        context.fillRect(0, 0, 1, 1);
        return context.getImageData(0, 0, 1, 1).data[0] === 0;
    };
    PIXI.getNextPowerOfTwo = function(number) {
        if (number > 0 && (number & number - 1) === 0) return number; else {
            var result = 1;
            while (result < number) result <<= 1;
            return result;
        }
    };
    PIXI.EventTarget = function() {
        var listeners = {};
        this.addEventListener = this.on = function(type, listener) {
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].unshift(listener);
            }
        };
        this.dispatchEvent = this.emit = function(event) {
            if (!listeners[event.type] || !listeners[event.type].length) {
                return;
            }
            for (var i = listeners[event.type].length - 1; i >= 0; i--) {
                listeners[event.type][i](event);
            }
        };
        this.removeEventListener = this.off = function(type, listener) {
            if (listeners[type] === undefined) return;
            var index = listeners[type].indexOf(listener);
            if (index !== -1) {
                listeners[type].splice(index, 1);
            }
        };
        this.removeAllEventListeners = function(type) {
            var a = listeners[type];
            if (a) a.length = 0;
        };
    };
    PIXI.PolyK = {};
    PIXI.PolyK.Triangulate = function(p) {
        var sign = true;
        var n = p.length >> 1;
        if (n < 3) return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++) avl.push(i);
        i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi === i0 || vi === i1 || vi === i2) continue;
                    if (PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0, i1, i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            } else if (i++ > 3 * al) {
                if (sign) {
                    tgs = [];
                    avl = [];
                    for (i = 0; i < n; i++) avl.push(i);
                    i = 0;
                    al = n;
                    sign = false;
                } else {
                    window.console.log("PIXI Warning: shape too complex to fill");
                    return [];
                }
            }
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    };
    PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
    };
    PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 === sign;
    };
    PIXI.initDefaultShaders = function() {};
    PIXI.CompileVertexShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
    };
    PIXI.CompileFragmentShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
    };
    PIXI._CompileShader = function(gl, shaderSrc, shaderType) {
        var src = shaderSrc.join("\n");
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            window.console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    };
    PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc) {
        var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
        var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            window.console.log("Could not initialise shaders");
        }
        return shaderProgram;
    };
    PIXI.PixiShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.textureCount = 0;
        this.attributes = [];
        this.init();
    };
    PIXI.PixiShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
        for (var key in this.uniforms) {
            this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
        }
        this.initUniforms();
        this.program = program;
    };
    PIXI.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var gl = this.gl;
        var uniform;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            var type = uniform.type;
            if (type === "sampler2D") {
                uniform._init = false;
                if (uniform.value !== null) {
                    this.initSampler2D(uniform);
                }
            } else if (type === "mat2" || type === "mat3" || type === "mat4") {
                uniform.glMatrix = true;
                uniform.glValueLength = 1;
                if (type === "mat2") {
                    uniform.glFunc = gl.uniformMatrix2fv;
                } else if (type === "mat3") {
                    uniform.glFunc = gl.uniformMatrix3fv;
                } else if (type === "mat4") {
                    uniform.glFunc = gl.uniformMatrix4fv;
                }
            } else {
                uniform.glFunc = gl["uniform" + type];
                if (type === "2f" || type === "2i") {
                    uniform.glValueLength = 2;
                } else if (type === "3f" || type === "3i") {
                    uniform.glValueLength = 3;
                } else if (type === "4f" || type === "4i") {
                    uniform.glValueLength = 4;
                } else {
                    uniform.glValueLength = 1;
                }
            }
        }
    };
    PIXI.PixiShader.prototype.initSampler2D = function(uniform) {
        if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded) {
            return;
        }
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + this.textureCount]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);
        if (uniform.textureData) {
            var data = uniform.textureData;
            var magFilter = data.magFilter ? data.magFilter : gl.LINEAR;
            var minFilter = data.minFilter ? data.minFilter : gl.LINEAR;
            var wrapS = data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE;
            var wrapT = data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE;
            var format = data.luminance ? gl.LUMINANCE : gl.RGBA;
            if (data.repeat) {
                wrapS = gl.REPEAT;
                wrapT = gl.REPEAT;
            }
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
            if (data.width) {
                var width = data.width ? data.width : 512;
                var height = data.height ? data.height : 2;
                var border = data.border ? data.border : 0;
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
        }
        gl.uniform1i(uniform.uniformLocation, this.textureCount);
        uniform._init = true;
        this.textureCount++;
    };
    PIXI.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var uniform;
        var gl = this.gl;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            if (uniform.glValueLength === 1) {
                if (uniform.glMatrix === true) {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
                } else {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
                }
            } else if (uniform.glValueLength === 2) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
            } else if (uniform.glValueLength === 3) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
            } else if (uniform.glValueLength === 4) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
            } else if (uniform.type === "sampler2D") {
                if (uniform._init) {
                    gl.activeTexture(gl["TEXTURE" + this.textureCount]);
                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(uniform.value.baseTexture, gl));
                    gl.uniform1i(uniform.uniformLocation, this.textureCount);
                    this.textureCount++;
                } else {
                    this.initSampler2D(uniform);
                }
            }
        }
    };
    PIXI.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}" ];
    PIXI.PixiFastShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ];
        this.textureCount = 0;
        this.init();
    };
    PIXI.PixiFastShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.uMatrix = gl.getUniformLocation(program, "uMatrix");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aPositionCoord = gl.getAttribLocation(program, "aPositionCoord");
        this.aScale = gl.getAttribLocation(program, "aScale");
        this.aRotation = gl.getAttribLocation(program, "aRotation");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ];
        this.program = program;
    };
    PIXI.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.StripShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ];
        this.init();
    };
    PIXI.StripShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.attributes = [ this.aVertexPosition, this.aTextureCoord ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.PrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ];
        this.init();
    };
    PIXI.PrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.ComplexPrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ];
        this.init();
    };
    PIXI.ComplexPrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.color = gl.getUniformLocation(program, "color");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.WebGLGraphics = function() {};
    PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader, webGLData;
        if (graphics.dirty) {
            PIXI.WebGLGraphics.updateGraphics(graphics, gl);
        }
        var webGL = graphics._webGL[gl.id];
        for (var i = 0; i < webGL.data.length; i++) {
            if (webGL.data[i].mode === 1) {
                webGLData = webGL.data[i];
                renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);
            } else {
                webGLData = webGL.data[i];
                renderSession.shaderManager.setShader(shader);
                shader = renderSession.shaderManager.primitiveShader;
                gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
                gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
                gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
                gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
                gl.uniform1f(shader.alpha, graphics.worldAlpha);
                gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
                gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
                gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            }
        }
    };
    PIXI.WebGLGraphics.updateGraphics = function(graphics, gl) {
        var webGL = graphics._webGL[gl.id];
        if (!webGL) webGL = graphics._webGL[gl.id] = {
            lastIndex: 0,
            data: [],
            gl: gl
        };
        graphics.dirty = false;
        var i;
        if (graphics.clearDirty) {
            graphics.clearDirty = false;
            for (i = 0; i < webGL.data.length; i++) {
                var graphicsData = webGL.data[i];
                graphicsData.reset();
                PIXI.WebGLGraphics.graphicsDataPool.push(graphicsData);
            }
            webGL.data = [];
            webGL.lastIndex = 0;
        }
        var webGLData;
        for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            if (data.type === PIXI.Graphics.POLY) {
                if (data.fill) {
                    if (data.points.length > 6) {
                        if (data.points.length > 5 * 2) {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                            PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                        } else {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                            PIXI.WebGLGraphics.buildPoly(data, webGLData);
                        }
                    }
                }
                if (data.lineWidth > 0) {
                    webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                    PIXI.WebGLGraphics.buildLine(data, webGLData);
                }
            } else {
                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                if (data.type === PIXI.Graphics.RECT) {
                    PIXI.WebGLGraphics.buildRectangle(data, webGLData);
                } else if (data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP) {
                    PIXI.WebGLGraphics.buildCircle(data, webGLData);
                } else if (data.type === PIXI.Graphics.RREC) {
                    PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
                }
            }
            webGL.lastIndex++;
        }
        for (i = 0; i < webGL.data.length; i++) {
            webGLData = webGL.data[i];
            if (webGLData.dirty) webGLData.upload();
        }
    };
    PIXI.WebGLGraphics.switchMode = function(webGL, type) {
        var webGLData;
        if (!webGL.data.length) {
            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        } else {
            webGLData = webGL.data[webGL.data.length - 1];
            if (webGLData.mode !== type || type === 1) {
                webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
                webGLData.mode = type;
                webGL.data.push(webGLData);
            }
        }
        webGLData.dirty = true;
        return webGLData;
    };
    PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vertPos = verts.length / 6;
            verts.push(x, y);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y);
            verts.push(r, g, b, alpha);
            verts.push(x, y + height);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);
            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [ x, y, x + width, y, x + width, y + height, x, y + height, x, y ];
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        var x = points[0];
        var y = points[1];
        var width = points[2];
        var height = points[3];
        var radius = points[4];
        var recPoints = [];
        recPoints.push(x, y + radius);
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            var triangles = PIXI.PolyK.Triangulate(recPoints);
            var i = 0;
            for (i = 0; i < triangles.length; i += 3) {
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i + 1] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
            }
            for (i = 0; i < recPoints.length; i++) {
                verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
            }
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = recPoints;
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
        var xa, ya, xb, yb, x, y, n = 20, points = [];
        function getPt(n1, n2, perc) {
            var diff = n2 - n1;
            return n1 + diff * perc;
        }
        var j = 0;
        for (var i = 0; i <= n; i++) {
            j = i / n;
            xa = getPt(fromX, cpX, j);
            ya = getPt(fromY, cpY, j);
            xb = getPt(cpX, toX, j);
            yb = getPt(cpY, toY, j);
            x = getPt(xa, xb, j);
            y = getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    };
    PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        var totalSegs = 40;
        var seg = Math.PI * 2 / totalSegs;
        var i = 0;
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            indices.push(vecPos);
            for (i = 0; i < totalSegs + 1; i++) {
                verts.push(x, y, r, g, b, alpha);
                verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
                indices.push(vecPos++, vecPos++);
            }
            indices.push(vecPos - 1);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [];
            for (i = 0; i < totalSegs + 1; i++) {
                graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
            }
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) {
        var i = 0;
        var points = graphicsData.points;
        if (points.length === 0) return;
        if (graphicsData.lineWidth % 2) {
            for (i = 0; i < points.length; i++) {
                points[i] += .5;
            }
        }
        var firstPoint = new PIXI.Point(points[0], points[1]);
        var lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
            points = points.slice();
            points.pop();
            points.pop();
            lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
            var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * .5;
            var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * .5;
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
        var width = graphicsData.lineWidth / 2;
        var color = PIXI.hex2rgb(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
        var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
        var a1, b1, c1, a2, b2, c2;
        var denom, pdist, dist;
        p1x = points[0];
        p1y = points[1];
        p2x = points[2];
        p2y = points[3];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
        for (i = 1; i < length - 1; i++) {
            p1x = points[(i - 1) * 2];
            p1y = points[(i - 1) * 2 + 1];
            p2x = points[i * 2];
            p2y = points[i * 2 + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[(i + 1) * 2 + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            a1 = -perpy + p1y - (-perpy + p2y);
            b1 = -perpx + p2x - (-perpx + p1x);
            c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
            a2 = -perp2y + p3y - (-perp2y + p2y);
            b2 = -perp2x + p2x - (-perp2x + p3x);
            c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
            denom = a1 * b2 - a2 * b1;
            if (Math.abs(denom) < .1) {
                denom += 10.1;
                verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
                verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);
                continue;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
            if (pdist > 140 * 140) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x + perp3x, p2y + perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                indexCount++;
            } else {
                verts.push(px, py);
                verts.push(r, g, b, alpha);
                verts.push(p2x - (px - p2x), p2y - (py - p2y));
                verts.push(r, g, b, alpha);
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
        indices.push(indexStart);
        for (i = 0; i < indexCount; i++) {
            indices.push(indexStart++);
        }
        indices.push(indexStart - 1);
    };
    PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points.slice();
        if (points.length < 6) return;
        var indices = webGLData.indices;
        webGLData.points = points;
        webGLData.alpha = graphicsData.fillAlpha;
        webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var x, y;
        for (var i = 0; i < points.length; i += 2) {
            x = points[i];
            y = points[i + 1];
            minX = x < minX ? x : minX;
            maxX = x > maxX ? x : maxX;
            minY = y < minY ? y : minY;
            maxY = y > maxY ? y : maxY;
        }
        points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY);
        var length = points.length / 2;
        for (i = 0; i < length; i++) {
            indices.push(i);
        }
    };
    PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        if (points.length < 6) return;
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var triangles = PIXI.PolyK.Triangulate(points);
        var vertPos = verts.length / 6;
        var i = 0;
        for (i = 0; i < triangles.length; i += 3) {
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i + 1] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
        }
        for (i = 0; i < length; i++) {
            verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha);
        }
    };
    PIXI.WebGLGraphics.graphicsDataPool = [];
    PIXI.WebGLGraphicsData = function(gl) {
        this.gl = gl;
        this.color = [ 0, 0, 0 ];
        this.points = [];
        this.indices = [];
        this.lastIndex = 0;
        this.buffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.mode = 1;
        this.alpha = 1;
        this.dirty = true;
    };
    PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [];
        this.indices = [];
        this.lastIndex = 0;
    };
    PIXI.WebGLGraphicsData.prototype.upload = function() {
        var gl = this.gl;
        this.glPoints = new Float32Array(this.points);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);
        this.glIndicies = new Uint16Array(this.indices);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);
        this.dirty = false;
    };
    PIXI.glContexts = [];
    PIXI.WebGLRenderer = function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
        if (!PIXI.defaultRenderer) {
            PIXI.sayHello("webGL");
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.WEBGL_RENDERER;
        this.transparent = !!transparent;
        this.preserveDrawingBuffer = preserveDrawingBuffer;
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        this.contextLost = this.handleContextLost.bind(this);
        this.contextRestoredLost = this.handleContextRestored.bind(this);
        this.view.addEventListener("webglcontextlost", this.contextLost, false);
        this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, false);
        this.options = {
            alpha: this.transparent,
            antialias: !!antialias,
            premultipliedAlpha: !!transparent && transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: preserveDrawingBuffer
        };
        var gl = null;
        [ "experimental-webgl", "webgl" ].forEach(function(name) {
            try {
                gl = gl || this.view.getContext(name, this.options);
            } catch (e) {}
        }, this);
        if (!gl) {
            throw new Error("This browser does not support webGL. Try using the canvas renderer" + this);
        }
        this.gl = gl;
        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;
        PIXI.glContexts[this.glContextId] = gl;
        if (!PIXI.blendModesWebGL) {
            PIXI.blendModesWebGL = [];
            PIXI.blendModesWebGL[PIXI.blendModes.NORMAL] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.ADD] = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY] = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SCREEN] = [ gl.SRC_ALPHA, gl.ONE ];
            PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DARKEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HUE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SATURATION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        }
        this.projection = new PIXI.Point();
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
        this.offset = new PIXI.Point(0, 0);
        this.resize(this.width, this.height);
        this.contextLost = false;
        this.shaderManager = new PIXI.WebGLShaderManager(gl);
        this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);
        this.maskManager = new PIXI.WebGLMaskManager(gl);
        this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent);
        this.stencilManager = new PIXI.WebGLStencilManager(gl);
        this.blendModeManager = new PIXI.WebGLBlendModeManager(gl);
        this.renderSession = {};
        this.renderSession.gl = this.gl;
        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.blendModeManager = this.blendModeManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.stencilManager = this.stencilManager;
        this.renderSession.renderer = this;
        gl.useProgram(this.shaderManager.defaultShader.program);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.colorMask(true, true, true, this.transparent);
    };
    PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;
    PIXI.WebGLRenderer.prototype.render = function(stage) {
        if (this.contextLost) return;
        if (this.__stage !== stage) {
            if (stage.interactive) stage.interactionManager.removeEvents();
            this.__stage = stage;
        }
        PIXI.WebGLRenderer.updateTextures();
        stage.updateTransform();
        if (stage._interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        var gl = this.gl;
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (this.transparent) {
            gl.clearColor(0, 0, 0, 0);
        } else {
            gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.renderDisplayObject(stage, this.projection);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        } else {
            if (stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = false;
                stage.interactionManager.setTarget(this);
            }
        }
    };
    PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer) {
        this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);
        this.renderSession.drawCount = 0;
        this.renderSession.currentBlendMode = 9999;
        this.renderSession.projection = projection;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, buffer);
        displayObject._renderWebGL(this.renderSession);
        this.spriteBatch.end();
    };
    PIXI.WebGLRenderer.updateTextures = function() {
        var i = 0;
        for (i = 0; i < PIXI.Texture.frameUpdates.length; i++) PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);
        for (i = 0; i < PIXI.texturesToDestroy.length; i++) PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);
        PIXI.texturesToUpdate.length = 0;
        PIXI.texturesToDestroy.length = 0;
        PIXI.Texture.frameUpdates.length = 0;
    };
    PIXI.WebGLRenderer.destroyTexture = function(texture) {
        for (var i = texture._glTextures.length - 1; i >= 0; i--) {
            var glTexture = texture._glTextures[i];
            var gl = PIXI.glContexts[i];
            if (gl && glTexture) {
                gl.deleteTexture(glTexture);
            }
        }
        texture._glTextures.length = 0;
    };
    PIXI.WebGLRenderer.updateTextureFrame = function(texture) {
        texture._updateWebGLuvs();
    };
    PIXI.WebGLRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
        this.gl.viewport(0, 0, this.width, this.height);
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
    };
    PIXI.createWebGLTexture = function(texture, gl) {
        if (texture.hasLoaded) {
            texture._glTextures[gl.id] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            if (!texture._powerOf2) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
            texture._dirty[gl.id] = false;
        }
        return texture._glTextures[gl.id];
    };
    PIXI.updateWebGLTexture = function(texture, gl) {
        if (texture._glTextures[gl.id]) {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            if (!texture._powerOf2) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            texture._dirty[gl.id] = false;
        }
    };
    PIXI.WebGLRenderer.prototype.handleContextLost = function(event) {
        event.preventDefault();
        this.contextLost = true;
    };
    PIXI.WebGLRenderer.prototype.handleContextRestored = function() {
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options);
        } catch (e) {
            try {
                this.gl = this.view.getContext("webgl", this.options);
            } catch (e2) {
                throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this);
            }
        }
        PIXI.glContexts[this.glContextId] = null;
        var gl = this.gl;
        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;
        PIXI.glContexts[this.glContextId] = gl;
        this.shaderManager.setContext(gl);
        this.spriteBatch.setContext(gl);
        this.maskManager.setContext(gl);
        this.filterManager.setContext(gl);
        this.renderSession.gl = this.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.colorMask(true, true, true, this.transparent);
        this.gl.viewport(0, 0, this.width, this.height);
        for (var key in PIXI.TextureCache) {
            var texture = PIXI.TextureCache[key].baseTexture;
            texture._glTextures = [];
        }
        this.contextLost = false;
    };
    PIXI.WebGLRenderer.prototype.destroy = function() {
        this.view.removeEventListener("webglcontextlost", this.contextLost);
        this.view.removeEventListener("webglcontextrestored", this.contextRestoredLost);
        PIXI.glContexts[this.glContextId] = null;
        this.projection = null;
        this.offset = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();
        this.shaderManager = null;
        this.spriteBatch = null;
        this.maskManager = null;
        this.filterManager = null;
        this.gl = null;
        this.renderSession = null;
    };
    PIXI.WebGLRenderer.glContextId = 0;
    PIXI.WebGLBlendModeManager = function(gl) {
        this.gl = gl;
        this.currentBlendMode = 99999;
    };
    PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode) {
        if (this.currentBlendMode === blendMode) return false;
        this.currentBlendMode = blendMode;
        var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        return true;
    };
    PIXI.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLMaskManager = function(gl) {
        this.setContext(gl);
    };
    PIXI.WebGLMaskManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession) {
        var gl = renderSession.gl;
        if (maskData.dirty) {
            PIXI.WebGLGraphics.updateGraphics(maskData, gl);
        }
        if (!maskData._webGL[gl.id].data.length) return;
        renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession) {
        var gl = this.gl;
        renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLStencilManager = function(gl) {
        this.stencilStack = [];
        this.setContext(gl);
        this.reverse = true;
        this.count = 0;
    };
    PIXI.WebGLStencilManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.bindGraphics(graphics, webGLData, renderSession);
        if (this.stencilStack.length === 0) {
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            this.reverse = true;
            this.count = 0;
        }
        this.stencilStack.push(webGLData);
        var level = this.count;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.ALWAYS, 0, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
        if (webGLData.mode === 1) {
            gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
            this.reverse = !this.reverse;
        } else {
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
        }
        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        this.count++;
    };
    PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession) {
        this._currentGraphics = graphics;
        var gl = this.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader;
        if (webGLData.mode === 1) {
            shader = renderSession.shaderManager.complexPrimitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform3fv(shader.color, webGLData.color);
            gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        } else {
            shader = renderSession.shaderManager.primitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform1f(shader.alpha, graphics.worldAlpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        }
    };
    PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.stencilStack.pop();
        this.count--;
        if (this.stencilStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            var level = this.count;
            this.bindGraphics(graphics, webGLData, renderSession);
            gl.colorMask(false, false, false, false);
            if (webGLData.mode === 1) {
                this.reverse = !this.reverse;
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                gl.stencilFunc(gl.ALWAYS, 0, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
                gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            } else {
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            }
            gl.colorMask(true, true, true, true);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
    };
    PIXI.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null;
        this.gl = null;
    };
    PIXI.WebGLShaderManager = function(gl) {
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var i = 0; i < this.maxAttibs; i++) {
            this.attribState[i] = false;
        }
        this.setContext(gl);
    };
    PIXI.WebGLShaderManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.primitiveShader = new PIXI.PrimitiveShader(gl);
        this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);
        this.defaultShader = new PIXI.PixiShader(gl);
        this.fastShader = new PIXI.PixiFastShader(gl);
        this.stripShader = new PIXI.StripShader(gl);
        this.setShader(this.defaultShader);
    };
    PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs) {
        var i;
        for (i = 0; i < this.tempAttribState.length; i++) {
            this.tempAttribState[i] = false;
        }
        for (i = 0; i < attribs.length; i++) {
            var attribId = attribs[i];
            this.tempAttribState[attribId] = true;
        }
        var gl = this.gl;
        for (i = 0; i < this.attribState.length; i++) {
            if (this.attribState[i] !== this.tempAttribState[i]) {
                this.attribState[i] = this.tempAttribState[i];
                if (this.tempAttribState[i]) {
                    gl.enableVertexAttribArray(i);
                } else {
                    gl.disableVertexAttribArray(i);
                }
            }
        }
    };
    PIXI.WebGLShaderManager.prototype.setShader = function(shader) {
        if (this._currentId === shader._UID) return false;
        this._currentId = shader._UID;
        this.currentShader = shader;
        this.gl.useProgram(shader.program);
        this.setAttribs(shader.attributes);
        return true;
    };
    PIXI.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null;
        this.tempAttribState = null;
        this.primitiveShader.destroy();
        this.complexPrimitiveShader.destroy();
        this.defaultShader.destroy();
        this.fastShader.destroy();
        this.stripShader.destroy();
        this.gl = null;
    };
    PIXI.WebGLSpriteBatch = function(gl) {
        this.vertSize = 6;
        this.size = 2e3;
        var numVerts = this.size * 4 * this.vertSize;
        var numIndices = this.size * 6;
        this.vertices = new Float32Array(numVerts);
        this.indices = new Uint16Array(numIndices);
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.setContext(gl);
        this.dirty = true;
        this.textures = [];
        this.blendModes = [];
    };
    PIXI.WebGLSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
        this.currentBlendMode = 99999;
    };
    PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.defaultShader;
        this.start();
    };
    PIXI.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLSpriteBatch.prototype.render = function(sprite) {
        var texture = sprite.texture;
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        var uvs = texture._uvs;
        if (!uvs) return;
        var alpha = sprite.worldAlpha;
        var tint = sprite.tint;
        var verticies = this.vertices;
        var aX = sprite.anchor.x;
        var aY = sprite.anchor.y;
        var w0, w1, h0, h1;
        if (texture.trim) {
            var trim = texture.trim;
            w1 = trim.x - aX * trim.width;
            w0 = w1 + texture.crop.width;
            h1 = trim.y - aY * trim.height;
            h0 = h1 + texture.crop.height;
        } else {
            w0 = texture.frame.width * (1 - aX);
            w1 = texture.frame.width * -aX;
            h0 = texture.frame.height * (1 - aY);
            h1 = texture.frame.height * -aY;
        }
        var index = this.currentBatchSize * 4 * this.vertSize;
        var worldTransform = sprite.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        verticies[index++] = a * w1 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w1 + ty;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y0;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w0 + ty;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w0 + ty;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w1 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w1 + ty;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        this.textures[this.currentBatchSize] = sprite.texture.baseTexture;
        this.blendModes[this.currentBatchSize] = sprite.blendMode;
        this.currentBatchSize++;
    };
    PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite) {
        var texture = tilingSprite.tilingTexture;
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        if (!tilingSprite._uvs) tilingSprite._uvs = new PIXI.TextureUvs();
        var uvs = tilingSprite._uvs;
        tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;
        tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;
        var offsetX = tilingSprite.tilePosition.x / (texture.baseTexture.width * tilingSprite.tileScaleOffset.x);
        var offsetY = tilingSprite.tilePosition.y / (texture.baseTexture.height * tilingSprite.tileScaleOffset.y);
        var scaleX = tilingSprite.width / texture.baseTexture.width / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);
        var scaleY = tilingSprite.height / texture.baseTexture.height / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);
        uvs.x0 = 0 - offsetX;
        uvs.y0 = 0 - offsetY;
        uvs.x1 = 1 * scaleX - offsetX;
        uvs.y1 = 0 - offsetY;
        uvs.x2 = 1 * scaleX - offsetX;
        uvs.y2 = 1 * scaleY - offsetY;
        uvs.x3 = 0 - offsetX;
        uvs.y3 = 1 * scaleY - offsetY;
        var alpha = tilingSprite.worldAlpha;
        var tint = tilingSprite.tint;
        var verticies = this.vertices;
        var width = tilingSprite.width;
        var height = tilingSprite.height;
        var aX = tilingSprite.anchor.x;
        var aY = tilingSprite.anchor.y;
        var w0 = width * (1 - aX);
        var w1 = width * -aX;
        var h0 = height * (1 - aY);
        var h1 = height * -aY;
        var index = this.currentBatchSize * 4 * this.vertSize;
        var worldTransform = tilingSprite.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        verticies[index++] = a * w1 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w1 + ty;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y0;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w0 + ty;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w0 + ty;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w1 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w1 + ty;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        this.textures[this.currentBatchSize] = texture.baseTexture;
        this.blendModes[this.currentBatchSize] = tilingSprite.blendMode;
        this.currentBatchSize++;
    };
    PIXI.WebGLSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var gl = this.gl;
        this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader);
        if (this.dirty) {
            this.dirty = false;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var projection = this.renderSession.projection;
            gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);
            var stride = this.vertSize * 4;
            gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
            gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
            gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);
        }
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        var nextTexture, nextBlendMode;
        var batchSize = 0;
        var start = 0;
        var currentBaseTexture = null;
        var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;
        for (var i = 0, j = this.currentBatchSize; i < j; i++) {
            nextTexture = this.textures[i];
            nextBlendMode = this.blendModes[i];
            if (currentBaseTexture !== nextTexture || currentBlendMode !== nextBlendMode) {
                this.renderBatch(currentBaseTexture, batchSize, start);
                start = i;
                batchSize = 0;
                currentBaseTexture = nextTexture;
                currentBlendMode = nextBlendMode;
                this.renderSession.blendModeManager.setBlendMode(currentBlendMode);
            }
            batchSize++;
        }
        this.renderBatch(currentBaseTexture, batchSize, start);
        this.currentBatchSize = 0;
    };
    PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex) {
        if (size === 0) return;
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id] || PIXI.createWebGLTexture(texture, gl));
        if (texture._dirty[gl.id]) {
            PIXI.updateWebGLTexture(this.currentBaseTexture, gl);
        }
        gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLSpriteBatch.prototype.stop = function() {
        this.flush();
    };
    PIXI.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = true;
    };
    PIXI.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null;
        this.indices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.currentBaseTexture = null;
        this.gl = null;
    };
    PIXI.WebGLFastSpriteBatch = function(gl) {
        this.vertSize = 10;
        this.maxSize = 6e3;
        this.size = this.maxSize;
        var numVerts = this.size * 4 * this.vertSize;
        var numIndices = this.maxSize * 6;
        this.vertices = new Float32Array(numVerts);
        this.indices = new Uint16Array(numIndices);
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.currentBlendMode = 0;
        this.renderSession = null;
        this.shader = null;
        this.matrix = null;
        this.setContext(gl);
    };
    PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
    };
    PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = spriteBatch.worldTransform.toArray(true);
        this.start();
    };
    PIXI.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch) {
        var children = spriteBatch.children;
        var sprite = children[0];
        if (!sprite.texture._uvs) return;
        this.currentBaseTexture = sprite.texture.baseTexture;
        if (sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode) {
            this.flush();
            this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
        }
        for (var i = 0, j = children.length; i < j; i++) {
            this.renderSprite(children[i]);
        }
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite) {
        if (!sprite.visible) return;
        if (sprite.texture.baseTexture !== this.currentBaseTexture) {
            this.flush();
            this.currentBaseTexture = sprite.texture.baseTexture;
            if (!sprite.texture._uvs) return;
        }
        var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;
        uvs = sprite.texture._uvs;
        width = sprite.texture.frame.width;
        height = sprite.texture.frame.height;
        if (sprite.texture.trim) {
            var trim = sprite.texture.trim;
            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + sprite.texture.crop.width;
            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + sprite.texture.crop.height;
        } else {
            w0 = sprite.texture.frame.width * (1 - sprite.anchor.x);
            w1 = sprite.texture.frame.width * -sprite.anchor.x;
            h0 = sprite.texture.frame.height * (1 - sprite.anchor.y);
            h1 = sprite.texture.frame.height * -sprite.anchor.y;
        }
        index = this.currentBatchSize * 4 * this.vertSize;
        verticies[index++] = w1;
        verticies[index++] = h1;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y1;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w0;
        verticies[index++] = h1;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w0;
        verticies[index++] = h0;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w1;
        verticies[index++] = h0;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = sprite.alpha;
        this.currentBatchSize++;
        if (this.currentBatchSize >= this.size) {
            this.flush();
        }
    };
    PIXI.WebGLFastSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var gl = this.gl;
        if (!this.currentBaseTexture._glTextures[gl.id]) PIXI.createWebGLTexture(this.currentBaseTexture, gl);
        gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.start = function() {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var projection = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);
        gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);
        var stride = this.vertSize * 4;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
        gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
        gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);
    };
    PIXI.WebGLFilterManager = function(gl, transparent) {
        this.transparent = transparent;
        this.filterStack = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.setContext(gl);
    };
    PIXI.WebGLFilterManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.texturePool = [];
        this.initShaderBuffers();
    };
    PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer) {
        this.renderSession = renderSession;
        this.defaultShader = renderSession.shaderManager.defaultShader;
        var projection = this.renderSession.projection;
        this.width = projection.x * 2;
        this.height = -projection.y * 2;
        this.buffer = buffer;
    };
    PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock) {
        var gl = this.gl;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();
        this.filterStack.push(filterBlock);
        var filter = filterBlock.filterPasses[0];
        this.offsetX += filterBlock._filterArea.x;
        this.offsetY += filterBlock._filterArea.y;
        var texture = this.texturePool.pop();
        if (!texture) {
            texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        } else {
            texture.resize(this.width, this.height);
        }
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        var filterArea = filterBlock._filterArea;
        var padding = filter.padding;
        filterArea.x -= padding;
        filterArea.y -= padding;
        filterArea.width += padding * 2;
        filterArea.height += padding * 2;
        if (filterArea.x < 0) filterArea.x = 0;
        if (filterArea.width > this.width) filterArea.width = this.width;
        if (filterArea.y < 0) filterArea.y = 0;
        if (filterArea.height > this.height) filterArea.height = this.height;
        gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);
        gl.viewport(0, 0, filterArea.width, filterArea.height);
        projection.x = filterArea.width / 2;
        projection.y = -filterArea.height / 2;
        offset.x = -filterArea.x;
        offset.y = -filterArea.y;
        this.renderSession.shaderManager.setShader(this.defaultShader);
        gl.uniform2f(this.defaultShader.projectionVector, filterArea.width / 2, -filterArea.height / 2);
        gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        filterBlock._glFilterTexture = texture;
    };
    PIXI.WebGLFilterManager.prototype.popFilter = function() {
        var gl = this.gl;
        var filterBlock = this.filterStack.pop();
        var filterArea = filterBlock._filterArea;
        var texture = filterBlock._glFilterTexture;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        if (filterBlock.filterPasses.length > 1) {
            gl.viewport(0, 0, filterArea.width, filterArea.height);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            this.vertexArray[0] = 0;
            this.vertexArray[1] = filterArea.height;
            this.vertexArray[2] = filterArea.width;
            this.vertexArray[3] = filterArea.height;
            this.vertexArray[4] = 0;
            this.vertexArray[5] = 0;
            this.vertexArray[6] = filterArea.width;
            this.vertexArray[7] = 0;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            this.uvArray[2] = filterArea.width / this.width;
            this.uvArray[5] = filterArea.height / this.height;
            this.uvArray[6] = filterArea.width / this.width;
            this.uvArray[7] = filterArea.height / this.height;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
            var inputTexture = texture;
            var outputTexture = this.texturePool.pop();
            if (!outputTexture) outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
            outputTexture.resize(this.width, this.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.BLEND);
            for (var i = 0; i < filterBlock.filterPasses.length - 1; i++) {
                var filterPass = filterBlock.filterPasses[i];
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);
                this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);
                var temp = inputTexture;
                inputTexture = outputTexture;
                outputTexture = temp;
            }
            gl.enable(gl.BLEND);
            texture = inputTexture;
            this.texturePool.push(outputTexture);
        }
        var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1];
        this.offsetX -= filterArea.x;
        this.offsetY -= filterArea.y;
        var sizeX = this.width;
        var sizeY = this.height;
        var offsetX = 0;
        var offsetY = 0;
        var buffer = this.buffer;
        if (this.filterStack.length === 0) {
            gl.colorMask(true, true, true, true);
        } else {
            var currentFilter = this.filterStack[this.filterStack.length - 1];
            filterArea = currentFilter._filterArea;
            sizeX = filterArea.width;
            sizeY = filterArea.height;
            offsetX = filterArea.x;
            offsetY = filterArea.y;
            buffer = currentFilter._glFilterTexture.frameBuffer;
        }
        projection.x = sizeX / 2;
        projection.y = -sizeY / 2;
        offset.x = offsetX;
        offset.y = offsetY;
        filterArea = filterBlock._filterArea;
        var x = filterArea.x - offsetX;
        var y = filterArea.y - offsetY;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = x;
        this.vertexArray[1] = y + filterArea.height;
        this.vertexArray[2] = x + filterArea.width;
        this.vertexArray[3] = y + filterArea.height;
        this.vertexArray[4] = x;
        this.vertexArray[5] = y;
        this.vertexArray[6] = x + filterArea.width;
        this.vertexArray[7] = y;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = filterArea.width / this.width;
        this.uvArray[5] = filterArea.height / this.height;
        this.uvArray[6] = filterArea.width / this.width;
        this.uvArray[7] = filterArea.height / this.height;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
        gl.viewport(0, 0, sizeX, sizeY);
        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        this.applyFilterPass(filter, filterArea, sizeX, sizeY);
        this.renderSession.shaderManager.setShader(this.defaultShader);
        gl.uniform2f(this.defaultShader.projectionVector, sizeX / 2, -sizeY / 2);
        gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);
        this.texturePool.push(texture);
        filterBlock._glFilterTexture = null;
    };
    PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height) {
        var gl = this.gl;
        var shader = filter.shaders[gl.id];
        if (!shader) {
            shader = new PIXI.PixiShader(gl);
            shader.fragmentSrc = filter.fragmentSrc;
            shader.uniforms = filter.uniforms;
            shader.init();
            filter.shaders[gl.id] = shader;
        }
        this.renderSession.shaderManager.setShader(shader);
        gl.uniform2f(shader.projectionVector, width / 2, -height / 2);
        gl.uniform2f(shader.offsetVector, 0, 0);
        if (filter.uniforms.dimensions) {
            filter.uniforms.dimensions.value[0] = this.width;
            filter.uniforms.dimensions.value[1] = this.height;
            filter.uniforms.dimensions.value[2] = this.vertexArray[0];
            filter.uniforms.dimensions.value[3] = this.vertexArray[5];
        }
        shader.syncUniforms();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var gl = this.gl;
        this.vertexBuffer = gl.createBuffer();
        this.uvBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.vertexArray = new Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);
        this.uvArray = new Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);
        this.colorArray = new Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), gl.STATIC_DRAW);
    };
    PIXI.WebGLFilterManager.prototype.destroy = function() {
        var gl = this.gl;
        this.filterStack = null;
        this.offsetX = 0;
        this.offsetY = 0;
        for (var i = 0; i < this.texturePool.length; i++) {
            this.texturePool[i].destroy();
        }
        this.texturePool = null;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.uvBuffer);
        gl.deleteBuffer(this.colorBuffer);
        gl.deleteBuffer(this.indexBuffer);
    };
    PIXI.FilterTexture = function(gl, width, height, scaleMode) {
        this.gl = gl;
        this.frameBuffer = gl.createFramebuffer();
        this.texture = gl.createTexture();
        scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        this.renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
        this.resize(width, height);
    };
    PIXI.FilterTexture.prototype.clear = function() {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };
    PIXI.FilterTexture.prototype.resize = function(width, height) {
        if (this.width === width && this.height === height) return;
        this.width = width;
        this.height = height;
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    };
    PIXI.FilterTexture.prototype.destroy = function() {
        var gl = this.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        gl.deleteTexture(this.texture);
        this.frameBuffer = null;
        this.texture = null;
    };
    PIXI.CanvasMaskManager = function() {};
    PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context) {
        context.save();
        var cacheAlpha = maskData.alpha;
        var transform = maskData.worldTransform;
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);
        context.clip();
        maskData.worldAlpha = cacheAlpha;
    };
    PIXI.CanvasMaskManager.prototype.popMask = function(context) {
        context.restore();
    };
    PIXI.CanvasTinter = function() {};
    PIXI.CanvasTinter.getTintedTexture = function(sprite, color) {
        var texture = sprite.texture;
        color = PIXI.CanvasTinter.roundColor(color);
        var stringColor = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        texture.tintCache = texture.tintCache || {};
        if (texture.tintCache[stringColor]) return texture.tintCache[stringColor];
        var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
        PIXI.CanvasTinter.tintMethod(texture, color, canvas);
        if (PIXI.CanvasTinter.convertTintToImage) {
            var tintImage = new Image();
            tintImage.src = canvas.toDataURL();
            texture.tintCache[stringColor] = tintImage;
        } else {
            texture.tintCache[stringColor] = canvas;
            PIXI.CanvasTinter.canvas = null;
        }
        return canvas;
    };
    PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "multiply";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
    };
    PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.globalCompositeOperation = "copy";
        context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
    };
    PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.globalCompositeOperation = "copy";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
        var rgbValues = PIXI.hex2rgb(color);
        var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];
        var pixelData = context.getImageData(0, 0, frame.width, frame.height);
        var pixels = pixelData.data;
        for (var i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
        }
        context.putImageData(pixelData, 0, 0);
    };
    PIXI.CanvasTinter.roundColor = function(color) {
        var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;
        var rgbValues = PIXI.hex2rgb(color);
        rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
        rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
        rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
        return PIXI.rgb2hex(rgbValues);
    };
    PIXI.CanvasTinter.cacheStepsPerColorChannel = 8;
    PIXI.CanvasTinter.convertTintToImage = false;
    PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();
    PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel;
    PIXI.CanvasRenderer = function(width, height, view, transparent) {
        if (!PIXI.defaultRenderer) {
            PIXI.sayHello("Canvas");
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.CANVAS_RENDERER;
        this.clearBeforeRender = true;
        this.transparent = !!transparent;
        if (!PIXI.blendModesCanvas) {
            PIXI.blendModesCanvas = [];
            if (PIXI.canUseNewCanvasBlendModes()) {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "screen";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "overlay";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "darken";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "lighten";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "hue";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "color";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
            } else {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
            }
        }
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        });
        this.refresh = true;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0;
        this.maskManager = new PIXI.CanvasMaskManager();
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null,
            roundPixels: false
        };
        if ("imageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "imageSmoothingEnabled"; else if ("webkitImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "webkitImageSmoothingEnabled"; else if ("mozImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "mozImageSmoothingEnabled"; else if ("oImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "oImageSmoothingEnabled";
    };
    PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;
    PIXI.CanvasRenderer.prototype.render = function(stage) {
        PIXI.texturesToUpdate.length = 0;
        PIXI.texturesToDestroy.length = 0;
        stage.updateTransform();
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.globalAlpha = 1;
        if (navigator.isCocoonJS && this.view.screencanvas) {
            this.context.fillStyle = "black";
            this.context.clear();
        }
        if (!this.transparent && this.clearBeforeRender) {
            this.context.fillStyle = stage.backgroundColorString;
            this.context.fillRect(0, 0, this.width, this.height);
        } else if (this.transparent && this.clearBeforeRender) {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        this.renderDisplayObject(stage);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        if (PIXI.Texture.frameUpdates.length > 0) {
            PIXI.Texture.frameUpdates.length = 0;
        }
    };
    PIXI.CanvasRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
    };
    PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context) {
        this.renderSession.context = context || this.context;
        displayObject._renderCanvas(this.renderSession);
    };
    PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var length = verticies.length / 2;
        this.count++;
        context.beginPath();
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
        }
        context.fillStyle = "#FF0000";
        context.fill();
        context.closePath();
    };
    PIXI.CanvasRenderer.prototype.renderStrip = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width;
            var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height;
            context.save();
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
            context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
            context.drawImage(strip.texture.baseTexture.source, 0, 0);
            context.restore();
        }
    };
    PIXI.CanvasBuffer = function(width, height) {
        this.width = width;
        this.height = height;
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.canvas.width = width;
        this.canvas.height = height;
    };
    PIXI.CanvasBuffer.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height);
    };
    PIXI.CanvasBuffer.prototype.resize = function(width, height) {
        this.width = this.canvas.width = width;
        this.height = this.canvas.height = height;
    };
    PIXI.CanvasGraphics = function() {};
    PIXI.CanvasGraphics.renderGraphics = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        var color = "";
        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            context.strokeStyle = color = "#" + ("00000" + (data.lineColor | 0).toString(16)).substr(-6);
            context.lineWidth = data.lineWidth;
            if (data.type === PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(points[0], points[1], points[2], points[3]);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeRect(points[0], points[1], points[2], points[3]);
                }
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.ELIP) {
                var ellipseData = data.points;
                var w = ellipseData[2] * 2;
                var h = ellipseData[3] * 2;
                var x = ellipseData[0] - w / 2;
                var y = ellipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = points[0];
                var ry = points[1];
                var width = points[2];
                var height = points[3];
                var radius = points[4];
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            }
        }
    };
    PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) {
        var len = graphics.graphicsData.length;
        if (len === 0) return;
        if (len > 1) {
            len = 1;
            window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
        }
        for (var i = 0; i < 1; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            if (data.type === PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                context.beginPath();
                context.rect(points[0], points[1], points[2], points[3]);
                context.closePath();
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type === PIXI.Graphics.ELIP) {
                var ellipseData = data.points;
                var w = ellipseData[2] * 2;
                var h = ellipseData[3] * 2;
                var x = ellipseData[0] - w / 2;
                var y = ellipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = points[0];
                var ry = points[1];
                var width = points[2];
                var height = points[3];
                var radius = points[4];
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
            }
        }
    };
    PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.currentPath = {
            points: []
        };
        this._webGL = [];
        this.isMask = false;
        this.bounds = null;
        this.boundsPadding = 10;
        this.dirty = true;
    };
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Graphics.prototype.constructor = PIXI.Graphics;
    Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            this._cacheAsBitmap = value;
            if (this._cacheAsBitmap) {
                this._generateCachedSprite();
            } else {
                this.destroyCachedSprite();
                this.dirty = true;
            }
        }
    });
    PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.lineWidth = lineWidth || 0;
        this.lineColor = color || 0;
        this.lineAlpha = arguments.length < 3 ? 1 : alpha;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        return this;
    };
    PIXI.Graphics.prototype.moveTo = function(x, y) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.currentPath.points.push(x, y);
        this.graphicsData.push(this.currentPath);
        return this;
    };
    PIXI.Graphics.prototype.lineTo = function(x, y) {
        this.currentPath.points.push(x, y);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        if (this.currentPath.points.length === 0) this.moveTo(0, 0);
        var xa, ya, n = 20, points = this.currentPath.points;
        if (points.length === 0) this.moveTo(0, 0);
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; i++) {
            j = i / n;
            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;
            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath.points.length === 0) this.moveTo(0, 0);
        var n = 20, dt, dt2, dt3, t2, t3, points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i < n; i++) {
            j = i / n;
            dt = 1 - j;
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        if (this.currentPath.points.length === 0) this.moveTo(x1, y1);
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
            points.push(x1, y1);
        } else {
            var dd = a1 * a1 + b1 * b1;
            var cc = a2 * a2 + b2 * b2;
            var tt = a1 * a2 + b1 * b2;
            var k1 = radius * Math.sqrt(dd) / mm;
            var k2 = radius * Math.sqrt(cc) / mm;
            var j1 = k1 * tt / dd;
            var j2 = k2 * tt / cc;
            var cx = k1 * b2 + k2 * b1;
            var cy = k1 * a2 + k2 * a1;
            var px = b1 * (k2 + j1);
            var py = a1 * (k2 + j1);
            var qx = b2 * (k1 + j2);
            var qy = a2 * (k1 + j2);
            var startAngle = Math.atan2(py - cy, px - cx);
            var endAngle = Math.atan2(qy - cy, qx - cx);
            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var points = this.currentPath.points;
        if (points.length !== 0 && points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        if (startAngle === endAngle) return this;
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += Math.PI * 2;
        } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += Math.PI * 2;
        }
        var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle;
        var segs = Math.abs(sweep) / (Math.PI * 2) * 40;
        if (sweep === 0) return this;
        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = segs - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i = 0; i <= segMinus; i++) {
            var real = i + remainder * i;
            var angle = theta + startAngle + theta2 * real;
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawPath = function(path) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        this.currentPath.points = this.currentPath.points.concat(path);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.beginFill = function(color, alpha) {
        this.filling = true;
        this.fillColor = color || 0;
        this.fillAlpha = arguments.length < 2 ? 1 : alpha;
        return this;
    };
    PIXI.Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this;
    };
    PIXI.Graphics.prototype.drawRect = function(x, y, width, height) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height, radius ],
            type: PIXI.Graphics.RREC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawCircle = function(x, y, radius) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, radius, radius ],
            type: PIXI.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
        this.bounds = null;
        return this;
    };
    PIXI.Graphics.prototype.generateTexture = function() {
        var bounds = this.getBounds();
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
        canvasBuffer.context.translate(-bounds.x, -bounds.y);
        PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);
        return texture;
    };
    PIXI.Graphics.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        if (this._cacheAsBitmap) {
            if (this.dirty) {
                this._generateCachedSprite();
                PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);
                this.dirty = false;
            }
            this._cachedSprite.alpha = this.alpha;
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
            return;
        } else {
            renderSession.spriteBatch.stop();
            renderSession.blendModeManager.setBlendMode(this.blendMode);
            if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock);
            if (this.blendMode !== renderSession.spriteBatch.currentBlendMode) {
                renderSession.spriteBatch.currentBlendMode = this.blendMode;
                var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
                renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
            }
            PIXI.WebGLGraphics.renderGraphics(this, renderSession);
            if (this.children.length) {
                renderSession.spriteBatch.start();
                for (var i = 0, j = this.children.length; i < j; i++) {
                    this.children[i]._renderWebGL(renderSession);
                }
                renderSession.spriteBatch.stop();
            }
            if (this._filters) renderSession.filterManager.popFilter();
            if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession);
            renderSession.drawCount++;
            renderSession.spriteBatch.start();
        }
    };
    PIXI.Graphics.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        var context = renderSession.context;
        var transform = this.worldTransform;
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        PIXI.CanvasGraphics.renderGraphics(this, context);
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Graphics.prototype.getBounds = function(matrix) {
        if (!this.bounds) this.updateBounds();
        var w0 = this.bounds.x;
        var w1 = this.bounds.width + this.bounds.x;
        var h0 = this.bounds.y;
        var h1 = this.bounds.height + this.bounds.y;
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = x1;
        var maxY = y1;
        var minX = x1;
        var minY = y1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        return bounds;
    };
    PIXI.Graphics.prototype.updateBounds = function() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var points, x, y, w, h;
        for (var i = 0; i < this.graphicsData.length; i++) {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            points = data.points;
            if (type === PIXI.Graphics.RECT) {
                x = points[0] - lineWidth / 2;
                y = points[1] - lineWidth / 2;
                w = points[2] + lineWidth;
                h = points[3] + lineWidth;
                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;
                minY = y < minY ? x : minY;
                maxY = y + h > maxY ? y + h : maxY;
            } else if (type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP) {
                x = points[0];
                y = points[1];
                w = points[2] + lineWidth / 2;
                h = points[3] + lineWidth / 2;
                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;
                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            } else {
                for (var j = 0; j < points.length; j += 2) {
                    x = points[j];
                    y = points[j + 1];
                    minX = x - lineWidth < minX ? x - lineWidth : minX;
                    maxX = x + lineWidth > maxX ? x + lineWidth : maxX;
                    minY = y - lineWidth < minY ? y - lineWidth : minY;
                    maxY = y + lineWidth > maxY ? y + lineWidth : maxY;
                }
            }
        }
        var padding = this.boundsPadding;
        this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, maxX - minX + padding * 2, maxY - minY + padding * 2);
    };
    PIXI.Graphics.prototype._generateCachedSprite = function() {
        var bounds = this.getLocalBounds();
        if (!this._cachedSprite) {
            var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
            var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this._cachedSprite = new PIXI.Sprite(texture);
            this._cachedSprite.buffer = canvasBuffer;
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.buffer.resize(bounds.width, bounds.height);
        }
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y);
        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
        this._cachedSprite.alpha = this.alpha;
    };
    PIXI.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.Graphics.POLY = 0;
    PIXI.Graphics.RECT = 1;
    PIXI.Graphics.CIRC = 2;
    PIXI.Graphics.ELIP = 3;
    PIXI.Graphics.RREC = 4;
    PIXI.Strip = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.texture = texture;
        this.uvs = new PIXI.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]);
        this.verticies = new PIXI.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]);
        this.colors = new PIXI.Float32Array([ 1, 1, 1, 1 ]);
        this.indices = new PIXI.Uint16Array([ 0, 1, 2, 3 ]);
        this.dirty = true;
        this.padding = 0;
    };
    PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Strip.prototype.constructor = PIXI.Strip;
    PIXI.Strip.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        renderSession.spriteBatch.stop();
        if (!this._vertexBuffer) this._initWebGL(renderSession);
        renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);
        this._renderStrip(renderSession);
        renderSession.spriteBatch.start();
    };
    PIXI.Strip.prototype._initWebGL = function(renderSession) {
        var gl = renderSession.gl;
        this._vertexBuffer = gl.createBuffer();
        this._indexBuffer = gl.createBuffer();
        this._uvBuffer = gl.createBuffer();
        this._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
    };
    PIXI.Strip.prototype._renderStrip = function(renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));
        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
        gl.uniform1f(shader.alpha, 1);
        if (!this.dirty) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        } else {
            this.dirty = false;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        }
        gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0);
    };
    PIXI.Strip.prototype._renderCanvas = function(renderSession) {
        var context = renderSession.context;
        var transform = this.worldTransform;
        if (renderSession.roundPixels) {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);
        } else {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        }
        var strip = this;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        for (var i = 0; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            if (this.padding === 0) {
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt(normX * normX + normY * normY);
                x0 = centerX + normX / dist * (dist + 3);
                y0 = centerY + normY / dist * (dist + 3);
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt(normX * normX + normY * normY);
                x1 = centerX + normX / dist * (dist + 3);
                y1 = centerY + normY / dist * (dist + 3);
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt(normX * normX + normY * normY);
                x2 = centerX + normX / dist * (dist + 3);
                y2 = centerY + normY / dist * (dist + 3);
            }
            var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width;
            var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height;
            context.save();
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
            context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
            context.drawImage(strip.texture.baseTexture.source, 0, 0);
            context.restore();
        }
    };
    PIXI.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = true;
    };
    PIXI.Rope = function(texture, points) {
        PIXI.Strip.call(this, texture);
        this.points = points;
        this.verticies = new PIXI.Float32Array(points.length * 4);
        this.uvs = new PIXI.Float32Array(points.length * 4);
        this.colors = new PIXI.Float32Array(points.length * 2);
        this.indices = new PIXI.Uint16Array(points.length * 2);
        this.refresh();
    };
    PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype);
    PIXI.Rope.prototype.constructor = PIXI.Rope;
    PIXI.Rope.prototype.refresh = function() {
        var points = this.points;
        if (points.length < 1) return;
        var uvs = this.uvs;
        var lastPoint = points[0];
        var indices = this.indices;
        var colors = this.colors;
        this.count -= .2;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        colors[0] = 1;
        colors[1] = 1;
        indices[0] = 0;
        indices[1] = 1;
        var total = points.length, point, index, amount;
        for (var i = 1; i < total; i++) {
            point = points[i];
            index = i * 4;
            amount = i / (total - 1);
            if (i % 2) {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            } else {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            }
            index = i * 2;
            colors[index] = 1;
            colors[index + 1] = 1;
            index = i * 2;
            indices[index] = index;
            indices[index + 1] = index + 1;
            lastPoint = point;
        }
    };
    PIXI.Rope.prototype.updateTransform = function() {
        var points = this.points;
        if (points.length < 1) return;
        var lastPoint = points[0];
        var nextPoint;
        var perp = {
            x: 0,
            y: 0
        };
        this.count -= .2;
        var verticies = this.verticies;
        var total = points.length, point, index, ratio, perpLength, num;
        for (var i = 0; i < total; i++) {
            point = points[i];
            index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }
            perp.y = -(nextPoint.x - lastPoint.x);
            perp.x = nextPoint.y - lastPoint.y;
            ratio = (1 - i / (total - 1)) * 10;
            if (ratio > 1) ratio = 1;
            perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
            num = this.texture.height / 2;
            perp.x /= perpLength;
            perp.y /= perpLength;
            perp.x *= num;
            perp.y *= num;
            verticies[index] = point.x + perp.x;
            verticies[index + 1] = point.y + perp.y;
            verticies[index + 2] = point.x - perp.x;
            verticies[index + 3] = point.y - perp.y;
            lastPoint = point;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.Rope.prototype.setTexture = function(texture) {
        this.texture = texture;
    };
    PIXI.TilingSprite = function(texture, width, height) {
        PIXI.Sprite.call(this, texture);
        this._width = width || 100;
        this._height = height || 100;
        this.tileScale = new PIXI.Point(1, 1);
        this.tileScaleOffset = new PIXI.Point(1, 1);
        this.tilePosition = new PIXI.Point(0, 0);
        this.renderable = true;
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
    };
    PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;
    Object.defineProperty(PIXI.TilingSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(value) {
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.TilingSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(value) {
            this._height = value;
        }
    });
    PIXI.TilingSprite.prototype.setTexture = function(texture) {
        if (this.texture === texture) return;
        this.texture = texture;
        this.refreshTexture = true;
        this.cachedTint = 16777215;
    };
    PIXI.TilingSprite.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        var i, j;
        if (this._mask) {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }
        if (this._filters) {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }
        if (!this.tilingTexture || this.refreshTexture) {
            this.generateTilingTexture(true);
            if (this.tilingTexture && this.tilingTexture.needsUpdate) {
                PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);
                this.tilingTexture.needsUpdate = false;
            }
        } else {
            renderSession.spriteBatch.renderTilingSprite(this);
        }
        for (i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderWebGL(renderSession);
        }
        renderSession.spriteBatch.stop();
        if (this._filters) renderSession.filterManager.popFilter();
        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
        renderSession.spriteBatch.start();
    };
    PIXI.TilingSprite.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        var context = renderSession.context;
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, context);
        }
        context.globalAlpha = this.worldAlpha;
        var transform = this.worldTransform;
        var i, j;
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        if (!this.__tilePattern || this.refreshTexture) {
            this.generateTilingTexture(false);
            if (this.tilingTexture) {
                this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            } else {
                return;
            }
        }
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        var tilePosition = this.tilePosition;
        var tileScale = this.tileScale;
        tilePosition.x %= this.tilingTexture.baseTexture.width;
        tilePosition.y %= this.tilingTexture.baseTexture.height;
        context.scale(tileScale.x, tileScale.y);
        context.translate(tilePosition.x, tilePosition.y);
        context.fillStyle = this.__tilePattern;
        context.fillRect(-tilePosition.x + this.anchor.x * -this._width, -tilePosition.y + this.anchor.y * -this._height, this._width / tileScale.x, this._height / tileScale.y);
        context.scale(1 / tileScale.x, 1 / tileScale.y);
        context.translate(-tilePosition.x, -tilePosition.y);
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
        for (i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
    };
    PIXI.TilingSprite.prototype.getBounds = function() {
        var width = this._width;
        var height = this._height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.TilingSprite.prototype.onTextureUpdate = function() {};
    PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo) {
        if (!this.texture.baseTexture.hasLoaded) return;
        var texture = this.texture;
        var frame = texture.frame;
        var targetWidth, targetHeight;
        var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;
        var newTextureRequired = false;
        if (!forcePowerOfTwo) {
            if (isFrame) {
                targetWidth = frame.width;
                targetHeight = frame.height;
                newTextureRequired = true;
            }
        } else {
            targetWidth = PIXI.getNextPowerOfTwo(frame.width);
            targetHeight = PIXI.getNextPowerOfTwo(frame.height);
            if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true;
        }
        if (newTextureRequired) {
            var canvasBuffer;
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                canvasBuffer = this.tilingTexture.canvasBuffer;
                canvasBuffer.resize(targetWidth, targetHeight);
                this.tilingTexture.baseTexture.width = targetWidth;
                this.tilingTexture.baseTexture.height = targetHeight;
                this.tilingTexture.needsUpdate = true;
            } else {
                canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);
                this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
                this.tilingTexture.canvasBuffer = canvasBuffer;
                this.tilingTexture.isTiling = true;
            }
            canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, 0, 0, targetWidth, targetHeight);
            this.tileScaleOffset.x = frame.width / targetWidth;
            this.tileScaleOffset.y = frame.height / targetHeight;
        } else {
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                this.tilingTexture.destroy(true);
            }
            this.tileScaleOffset.x = 1;
            this.tileScaleOffset.y = 1;
            this.tilingTexture = texture;
        }
        this.refreshTexture = false;
        this.tilingTexture.baseTexture._powerOf2 = true;
    };
    PIXI.BaseTextureCache = {};
    PIXI.texturesToUpdate = [];
    PIXI.texturesToDestroy = [];
    PIXI.BaseTextureCacheIdGenerator = 0;
    PIXI.BaseTexture = function(source, scaleMode) {
        PIXI.EventTarget.call(this);
        this.width = 100;
        this.height = 100;
        this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.hasLoaded = false;
        this.source = source;
        this.id = PIXI.BaseTextureCacheIdGenerator++;
        this.premultipliedAlpha = true;
        this._glTextures = [];
        this._dirty = [];
        if (!source) return;
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
            this.hasLoaded = true;
            this.width = this.source.width;
            this.height = this.source.height;
            PIXI.texturesToUpdate.push(this);
        } else {
            var scope = this;
            this.source.onload = function() {
                scope.hasLoaded = true;
                scope.width = scope.source.width;
                scope.height = scope.source.height;
                for (var i = 0; i < scope._glTextures.length; i++) {
                    scope._dirty[i] = true;
                }
                scope.dispatchEvent({
                    type: "loaded",
                    content: scope
                });
            };
            this.source.onerror = function() {
                scope.dispatchEvent({
                    type: "error",
                    content: scope
                });
            };
        }
        this.imageUrl = null;
        this._powerOf2 = false;
    };
    PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;
    PIXI.BaseTexture.prototype.destroy = function() {
        if (this.imageUrl) {
            delete PIXI.BaseTextureCache[this.imageUrl];
            delete PIXI.TextureCache[this.imageUrl];
            this.imageUrl = null;
            this.source.src = null;
        } else if (this.source && this.source._pixiId) {
            delete PIXI.BaseTextureCache[this.source._pixiId];
        }
        this.source = null;
        PIXI.texturesToDestroy.push(this);
    };
    PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc) {
        this.hasLoaded = false;
        this.source.src = null;
        this.source.src = newSrc;
    };
    PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var baseTexture = PIXI.BaseTextureCache[imageUrl];
        if (crossorigin === undefined && imageUrl.indexOf("data:") === -1) crossorigin = true;
        if (!baseTexture) {
            var image = new Image();
            if (crossorigin) {
                image.crossOrigin = "";
            }
            image.src = imageUrl;
            baseTexture = new PIXI.BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;
            PIXI.BaseTextureCache[imageUrl] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode) {
        if (!canvas._pixiId) {
            canvas._pixiId = "canvas_" + PIXI.TextureCacheIdGenerator++;
        }
        var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];
        if (!baseTexture) {
            baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
            PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.TextureCache = {};
    PIXI.FrameCache = {};
    PIXI.TextureCacheIdGenerator = 0;
    PIXI.Texture = function(baseTexture, frame) {
        PIXI.EventTarget.call(this);
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new PIXI.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof PIXI.Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        this.baseTexture = baseTexture;
        this.frame = frame;
        this.trim = null;
        this.valid = false;
        this._uvs = null;
        this.width = 0;
        this.height = 0;
        this.crop = new PIXI.Rectangle(0, 0, 1, 1);
        if (baseTexture.hasLoaded) {
            if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            this.setFrame(frame);
        } else {
            baseTexture.addEventListener("loaded", this.onBaseTextureLoaded.bind(this));
        }
    };
    PIXI.Texture.prototype.constructor = PIXI.Texture;
    PIXI.Texture.prototype.onBaseTextureLoaded = function() {
        var baseTexture = this.baseTexture;
        baseTexture.removeEventListener("loaded", this.onLoaded);
        if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.setFrame(this.frame);
        this.dispatchEvent({
            type: "update",
            content: this
        });
    };
    PIXI.Texture.prototype.destroy = function(destroyBase) {
        if (destroyBase) this.baseTexture.destroy();
        this.valid = false;
    };
    PIXI.Texture.prototype.setFrame = function(frame) {
        this.noFrame = false;
        this.frame = frame;
        this.width = frame.width;
        this.height = frame.height;
        this.crop.x = frame.x;
        this.crop.y = frame.y;
        this.crop.width = frame.width;
        this.crop.height = frame.height;
        if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) {
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        }
        this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
        if (this.trim) {
            this.width = this.trim.width;
            this.height = this.trim.height;
            this.frame.width = this.trim.width;
            this.frame.height = this.trim.height;
        }
        if (this.valid) PIXI.Texture.frameUpdates.push(this);
    };
    PIXI.Texture.prototype._updateWebGLuvs = function() {
        if (!this._uvs) this._uvs = new PIXI.TextureUvs();
        var frame = this.crop;
        var tw = this.baseTexture.width;
        var th = this.baseTexture.height;
        this._uvs.x0 = frame.x / tw;
        this._uvs.y0 = frame.y / th;
        this._uvs.x1 = (frame.x + frame.width) / tw;
        this._uvs.y1 = frame.y / th;
        this._uvs.x2 = (frame.x + frame.width) / tw;
        this._uvs.y2 = (frame.y + frame.height) / th;
        this._uvs.x3 = frame.x / tw;
        this._uvs.y3 = (frame.y + frame.height) / th;
    };
    PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var texture = PIXI.TextureCache[imageUrl];
        if (!texture) {
            texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
            PIXI.TextureCache[imageUrl] = texture;
        }
        return texture;
    };
    PIXI.Texture.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
        return texture;
    };
    PIXI.Texture.fromCanvas = function(canvas, scaleMode) {
        var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);
        return new PIXI.Texture(baseTexture);
    };
    PIXI.Texture.addTextureToCache = function(texture, id) {
        PIXI.TextureCache[id] = texture;
    };
    PIXI.Texture.removeTextureFromCache = function(id) {
        var texture = PIXI.TextureCache[id];
        delete PIXI.TextureCache[id];
        delete PIXI.BaseTextureCache[id];
        return texture;
    };
    PIXI.Texture.frameUpdates = [];
    PIXI.TextureUvs = function() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.x3 = 0;
        this.y3 = 0;
    };
    PIXI.RenderTexture = function(width, height, renderer, scaleMode) {
        PIXI.EventTarget.call(this);
        this.width = width || 100;
        this.height = height || 100;
        this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);
        this.crop = new PIXI.Rectangle(0, 0, this.width, this.height);
        this.baseTexture = new PIXI.BaseTexture();
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTextures = [];
        this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.baseTexture.hasLoaded = true;
        this.renderer = renderer || PIXI.defaultRenderer;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);
            this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;
            this.render = this.renderWebGL;
            this.projection = new PIXI.Point(this.width / 2, -this.height / 2);
        } else {
            this.render = this.renderCanvas;
            this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);
            this.baseTexture.source = this.textureBuffer.canvas;
        }
        this.valid = true;
        PIXI.Texture.frameUpdates.push(this);
    };
    PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
    PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;
    PIXI.RenderTexture.prototype.resize = function(width, height, updateBase) {
        if (width === this.width && height === this.height) {
            return;
        }
        this.valid = width > 0 && height > 0;
        this.width = this.frame.width = this.crop.width = width;
        this.height = this.frame.height = this.crop.height = height;
        if (updateBase) {
            this.baseTexture.width = this.width;
            this.baseTexture.height = this.height;
        }
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.projection.x = this.width / 2;
            this.projection.y = -this.height / 2;
        }
        if (!this.valid) return;
        this.textureBuffer.resize(this.width, this.height);
    };
    PIXI.RenderTexture.prototype.clear = function() {
        if (!this.valid) return;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        }
        this.textureBuffer.clear();
    };
    PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear) {
        if (!this.valid) return;
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        if (clear) this.textureBuffer.clear();
        var children = displayObject.children;
        var originalWorldTransform = displayObject.worldTransform;
        displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
        displayObject.worldTransform.d = -1;
        displayObject.worldTransform.ty = this.projection.y * -2;
        if (position) {
            displayObject.worldTransform.tx = position.x;
            displayObject.worldTransform.ty -= position.y;
        }
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        PIXI.WebGLRenderer.updateTextures();
        this.renderer.spriteBatch.dirty = true;
        this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);
        displayObject.worldTransform = originalWorldTransform;
        this.renderer.spriteBatch.dirty = true;
    };
    PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear) {
        if (!this.valid) return;
        var children = displayObject.children;
        var originalWorldTransform = displayObject.worldTransform;
        displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
        if (position) {
            displayObject.worldTransform.tx = position.x;
            displayObject.worldTransform.ty = position.y;
        } else {
            displayObject.worldTransform.tx = 0;
            displayObject.worldTransform.ty = 0;
        }
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        if (clear) this.textureBuffer.clear();
        var context = this.textureBuffer.context;
        this.renderer.renderDisplayObject(displayObject, context);
        context.setTransform(1, 0, 0, 1, 0, 0);
        displayObject.worldTransform = originalWorldTransform;
    };
    PIXI.RenderTexture.prototype.getImage = function() {
        var image = new Image();
        image.src = this.getBase64();
        return image;
    };
    PIXI.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    };
    PIXI.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            var width = this.textureBuffer.width;
            var height = this.textureBuffer.height;
            var webGLPixels = new Uint8Array(4 * width * height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            var tempCanvas = new PIXI.CanvasBuffer(width, height);
            var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
            var canvasPixels = canvasData.data;
            for (var i = 0; i < webGLPixels.length; i += 4) {
                var alpha = webGLPixels[i + 3];
                canvasPixels[i] = webGLPixels[i] * alpha;
                canvasPixels[i + 1] = webGLPixels[i + 1] * alpha;
                canvasPixels[i + 2] = webGLPixels[i + 2] * alpha;
                canvasPixels[i + 3] = alpha;
            }
            tempCanvas.context.putImageData(canvasData, 0, 0);
            return tempCanvas.canvas;
        } else {
            return this.textureBuffer.canvas;
        }
    };
    PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== "undefined" && define.amd) {
        define("PIXI", function() {
            return root.PIXI = PIXI;
        }());
    } else {
        root.PIXI = PIXI;
    }
}).call(this);

(function() {
    var root = this;
    var Phaser = Phaser || {
        VERSION: "2.1.1",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        }
    };
    PIXI.InteractionManager = PIXI.InteractionManager || function() {};
    PIXI.dontSayHello = true;
    Phaser.Utils = {
        getProperty: function(obj, prop) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                return obj[last];
            } else {
                return null;
            }
        },
        setProperty: function(obj, prop, value) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                obj[last] = value;
            }
            return obj;
        },
        transposeArray: function(array) {
            var result = new Array(array[0].length);
            for (var i = 0; i < array[0].length; i++) {
                result[i] = new Array(array.length - 1);
                for (var j = array.length - 1; j > -1; j--) {
                    result[i][j] = array[j][i];
                }
            }
            return result;
        },
        rotateArray: function(matrix, direction) {
            if (typeof direction !== "string") {
                direction = (direction % 360 + 360) % 360;
            }
            if (direction === 90 || direction === -270 || direction === "rotateLeft") {
                matrix = Phaser.Utils.transposeArray(matrix);
                matrix = matrix.reverse();
            } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
                matrix = matrix.reverse();
                matrix = Phaser.Utils.transposeArray(matrix);
            } else if (Math.abs(direction) === 180 || direction === "rotate180") {
                for (var i = 0; i < matrix.length; i++) {
                    matrix[i].reverse();
                }
                matrix = matrix.reverse();
            }
            return matrix;
        },
        parseDimension: function(size, dimension) {
            var f = 0;
            var px = 0;
            if (typeof size === "string") {
                if (size.substr(-1) === "%") {
                    f = parseInt(size, 10) / 100;
                    if (dimension === 0) {
                        px = window.innerWidth * f;
                    } else {
                        px = window.innerHeight * f;
                    }
                } else {
                    px = parseInt(size, 10);
                }
            } else {
                px = size;
            }
            return px;
        },
        shuffle: function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        },
        pad: function(str, len, pad, dir) {
            if (typeof len == "undefined") {
                var len = 0;
            }
            if (typeof pad == "undefined") {
                var pad = " ";
            }
            if (typeof dir == "undefined") {
                var dir = 3;
            }
            var padlen = 0;
            if (len + 1 >= str.length) {
                switch (dir) {
                  case 1:
                    str = new Array(len + 1 - str.length).join(pad) + str;
                    break;

                  case 3:
                    var right = Math.ceil((padlen = len - str.length) / 2);
                    var left = padlen - right;
                    str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                    break;

                  default:
                    str = str + new Array(len + 1 - str.length).join(pad);
                    break;
                }
            }
            return str;
        },
        isPlainObject: function(obj) {
            if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
                return false;
            }
            try {
                if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            return true;
        },
        extend: function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i = 2;
            }
            if (length === i) {
                target = this;
                --i;
            }
            for (;i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue;
                        }
                        if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && Array.isArray(src) ? src : [];
                            } else {
                                clone = src && Phaser.Utils.isPlainObject(src) ? src : {};
                            }
                            target[name] = Phaser.Utils.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        },
        mixin: function(from, to) {
            if (!from || typeof from !== "object") {
                return to;
            }
            for (var key in from) {
                var o = from[key];
                if (o.childNodes || o.cloneNode) {
                    continue;
                }
                var type = typeof from[key];
                if (!from[key] || type !== "object") {
                    to[key] = from[key];
                } else {
                    if (typeof to[key] === type) {
                        to[key] = Phaser.Utils.mixin(from[key], to[key]);
                    } else {
                        to[key] = Phaser.Utils.mixin(from[key], new o.constructor());
                    }
                }
            }
            return to;
        }
    };
    if (typeof Function.prototype.bind != "function") {
        Function.prototype.bind = function() {
            var slice = Array.prototype.slice;
            return function(thisArg) {
                var target = this, boundArgs = slice.call(arguments, 1);
                if (typeof target != "function") {
                    throw new TypeError();
                }
                function bound() {
                    var args = boundArgs.concat(slice.call(arguments));
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    if (proto) {
                        F.prototype = proto;
                    }
                    if (!(this instanceof F)) {
                        return new F();
                    }
                }(target.prototype);
                return bound;
            };
        }();
    }
    if (!Array.isArray) {
        Array.isArray = function(arg) {
            return Object.prototype.toString.call(arg) == "[object Array]";
        };
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
            "use strict";
            if (this === void 0 || this === null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function") {
                throw new TypeError();
            }
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    fun.call(thisArg, t[i], i, t);
                }
            }
        };
    }
    if (typeof window.Uint32Array !== "function") {
        var CheapArray = function(type) {
            var proto = new Array();
            window[type] = function(arg) {
                if (typeof arg === "number") {
                    Array.call(this, arg);
                    this.length = arg;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = 0;
                    }
                } else {
                    Array.call(this, arg.length);
                    this.length = arg.length;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = arg[i];
                    }
                }
            };
            window[type].prototype = proto;
            window[type].constructor = window[type];
        };
        CheapArray("Uint32Array");
        CheapArray("Int16Array");
    }
    if (!window.console) {
        window.console = {};
        window.console.log = window.console.assert = function() {};
        window.console.warn = window.console.assert = function() {};
    }
    Phaser.Circle = function(x, y, diameter) {
        x = x || 0;
        y = y || 0;
        diameter = diameter || 0;
        this.x = x;
        this.y = y;
        this._diameter = diameter;
        if (diameter > 0) {
            this._radius = diameter * .5;
        } else {
            this._radius = 0;
        }
    };
    Phaser.Circle.prototype = {
        circumference: function() {
            return 2 * (Math.PI * this._radius);
        },
        setTo: function(x, y, diameter) {
            this.x = x;
            this.y = y;
            this._diameter = diameter;
            this._radius = diameter * .5;
            return this;
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.diameter);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.diameter = this._diameter;
            return dest;
        },
        distance: function(dest, round) {
            if (typeof round === "undefined") {
                round = false;
            }
            if (round) {
                return Phaser.Math.distanceRounded(this.x, this.y, dest.x, dest.y);
            } else {
                return Phaser.Math.distance(this.x, this.y, dest.x, dest.y);
            }
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Circle(this.x, this.y, this.diameter);
            } else {
                output.setTo(this.x, this.y, this.diameter);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Circle.contains(this, x, y);
        },
        circumferencePoint: function(angle, asDegrees, out) {
            return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);
        },
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        }
    };
    Phaser.Circle.prototype.constructor = Phaser.Circle;
    Object.defineProperty(Phaser.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter;
        },
        set: function(value) {
            if (value > 0) {
                this._diameter = value;
                this._radius = value * .5;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "radius", {
        get: function() {
            return this._radius;
        },
        set: function(value) {
            if (value > 0) {
                this._radius = value;
                this._diameter = value * 2;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius;
        },
        set: function(value) {
            if (value > this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.x - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius;
        },
        set: function(value) {
            if (value < this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius;
        },
        set: function(value) {
            if (value > this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.y - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius;
        },
        set: function(value) {
            if (value < this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "area", {
        get: function() {
            if (this._radius > 0) {
                return Math.PI * this._radius * this._radius;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "empty", {
        get: function() {
            return this._diameter === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0);
            }
        }
    });
    Phaser.Circle.contains = function(a, x, y) {
        if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom) {
            var dx = (a.x - x) * (a.x - x);
            var dy = (a.y - y) * (a.y - y);
            return dx + dy <= a.radius * a.radius;
        } else {
            return false;
        }
    };
    Phaser.Circle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.diameter == b.diameter;
    };
    Phaser.Circle.intersects = function(a, b) {
        return Phaser.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
    };
    Phaser.Circle.circumferencePoint = function(a, angle, asDegrees, out) {
        if (typeof asDegrees === "undefined") {
            asDegrees = false;
        }
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        if (asDegrees === true) {
            angle = Phaser.Math.degToRad(angle);
        }
        out.x = a.x + a.radius * Math.cos(angle);
        out.y = a.y + a.radius * Math.sin(angle);
        return out;
    };
    Phaser.Circle.intersectsRectangle = function(c, r) {
        var cx = Math.abs(c.x - r.x - r.halfWidth);
        var xDist = r.halfWidth + c.radius;
        if (cx > xDist) {
            return false;
        }
        var cy = Math.abs(c.y - r.y - r.halfHeight);
        var yDist = r.halfHeight + c.radius;
        if (cy > yDist) {
            return false;
        }
        if (cx <= r.halfWidth || cy <= r.halfHeight) {
            return true;
        }
        var xCornerDist = cx - r.halfWidth;
        var yCornerDist = cy - r.halfHeight;
        var xCornerDistSq = xCornerDist * xCornerDist;
        var yCornerDistSq = yCornerDist * yCornerDist;
        var maxCornerDistSq = c.radius * c.radius;
        return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
    };
    PIXI.Circle = Phaser.Circle;
    Phaser.Point = function(x, y) {
        x = x || 0;
        y = y || 0;
        this.x = x;
        this.y = y;
    };
    Phaser.Point.prototype = {
        copyFrom: function(source) {
            return this.setTo(source.x, source.y);
        },
        invert: function() {
            return this.setTo(this.y, this.x);
        },
        setTo: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        set: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        add: function(x, y) {
            this.x += x;
            this.y += y;
            return this;
        },
        subtract: function(x, y) {
            this.x -= x;
            this.y -= y;
            return this;
        },
        multiply: function(x, y) {
            this.x *= x;
            this.y *= y;
            return this;
        },
        divide: function(x, y) {
            this.x /= x;
            this.y /= y;
            return this;
        },
        clampX: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            return this;
        },
        clampY: function(min, max) {
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clamp: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Point(this.x, this.y);
            } else {
                output.setTo(this.x, this.y);
            }
            return output;
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            return dest;
        },
        distance: function(dest, round) {
            return Phaser.Point.distance(this, dest, round);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        angle: function(a, asDegrees) {
            if (typeof asDegrees === "undefined") {
                asDegrees = false;
            }
            if (asDegrees) {
                return Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x));
            } else {
                return Math.atan2(a.y - this.y, a.x - this.x);
            }
        },
        angleSq: function(a) {
            return this.subtract(a).angle(a.subtract(this));
        },
        rotate: function(x, y, angle, asDegrees, distance) {
            return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function(magnitude) {
            return this.normalize().multiply(magnitude, magnitude);
        },
        normalize: function() {
            if (!this.isZero()) {
                var m = this.getMagnitude();
                this.x /= m;
                this.y /= m;
            }
            return this;
        },
        isZero: function() {
            return this.x === 0 && this.y === 0;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        perp: function() {
            return this.setTo(-this.y, this.x);
        },
        rperp: function() {
            return this.setTo(this.y, -this.x);
        },
        normalRightHand: function() {
            return this.setTo(this.y * -1, this.x);
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        }
    };
    Phaser.Point.prototype.constructor = Phaser.Point;
    Phaser.Point.add = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        return out;
    };
    Phaser.Point.subtract = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        return out;
    };
    Phaser.Point.multiply = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        return out;
    };
    Phaser.Point.divide = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        return out;
    };
    Phaser.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };
    Phaser.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
    };
    Phaser.Point.angleSq = function(a, b) {
        return a.subtract(b).angle(b.subtract(a));
    };
    Phaser.Point.negative = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(-a.x, -a.y);
    };
    Phaser.Point.multiplyAdd = function(a, b, s, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + b.x * s, a.y + b.y * s);
    };
    Phaser.Point.interpolate = function(a, b, f, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);
    };
    Phaser.Point.perp = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(-a.y, a.x);
    };
    Phaser.Point.rperp = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.y, -a.x);
    };
    Phaser.Point.distance = function(a, b, round) {
        if (typeof round === "undefined") {
            round = false;
        }
        if (round) {
            return Phaser.Math.distanceRounded(a.x, a.y, b.x, b.y);
        } else {
            return Phaser.Math.distance(a.x, a.y, b.x, b.y);
        }
    };
    Phaser.Point.project = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var amt = a.dot(b) / b.getMagnitudeSq();
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.projectUnit = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var amt = a.dot(b);
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.normalRightHand = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.y * -1, a.x);
    };
    Phaser.Point.normalize = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var m = a.getMagnitude();
        if (m !== 0) {
            out.setTo(a.x / m, a.y / m);
        }
        return out;
    };
    Phaser.Point.rotate = function(a, x, y, angle, asDegrees, distance) {
        asDegrees = asDegrees || false;
        distance = distance || null;
        if (asDegrees) {
            angle = Phaser.Math.degToRad(angle);
        }
        if (distance === null) {
            distance = Math.sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y));
        }
        var requiredAngle = angle + Math.atan2(a.y - y, a.x - x);
        return a.setTo(x + distance * Math.cos(requiredAngle), y + distance * Math.sin(requiredAngle));
    };
    Phaser.Point.centroid = function(points, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        if (Object.prototype.toString.call(points) !== "[object Array]") {
            throw new Error("Phaser.Point. Parameter 'points' must be an array");
        }
        var pointslength = points.length;
        if (pointslength < 1) {
            throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        }
        if (pointslength === 1) {
            out.copyFrom(points[0]);
            return out;
        }
        for (var i = 0; i < pointslength; i++) {
            Phaser.Point.add(out, points[i], out);
        }
        out.divide(pointslength, pointslength);
        return out;
    };
    PIXI.Point = Phaser.Point;
    Phaser.Rectangle = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    };
    Phaser.Rectangle.prototype = {
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        centerOn: function(x, y) {
            this.centerX = x;
            this.centerY = y;
            return this;
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
        },
        floorAll: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height);
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        inflate: function(dx, dy) {
            return Phaser.Rectangle.inflate(this, dx, dy);
        },
        size: function(output) {
            return Phaser.Rectangle.size(this, output);
        },
        clone: function(output) {
            return Phaser.Rectangle.clone(this, output);
        },
        contains: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        containsRect: function(b) {
            return Phaser.Rectangle.containsRect(b, this);
        },
        equals: function(b) {
            return Phaser.Rectangle.equals(this, b);
        },
        intersection: function(b, out) {
            return Phaser.Rectangle.intersection(this, b, out);
        },
        intersects: function(b, tolerance) {
            return Phaser.Rectangle.intersects(this, b, tolerance);
        },
        intersectsRaw: function(left, right, top, bottom, tolerance) {
            return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);
        },
        union: function(b, out) {
            return Phaser.Rectangle.union(this, b, out);
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        }
    };
    Object.defineProperty(Phaser.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value <= this.y) {
                this.height = 0;
            } else {
                this.height = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new Phaser.Point(this.right, this.bottom);
        },
        set: function(value) {
            this.right = value.x;
            this.bottom = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            if (value >= this.right) {
                this.width = 0;
            } else {
                this.width = this.right - value;
            }
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value <= this.x) {
                this.width = 0;
            } else {
                this.width = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "perimeter", {
        get: function() {
            return this.width * 2 + this.height * 2;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth;
        },
        set: function(value) {
            this.x = value - this.halfWidth;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight;
        },
        set: function(value) {
            this.y = value - this.halfHeight;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            if (value >= this.bottom) {
                this.height = 0;
                this.y = value;
            } else {
                this.height = this.bottom - value;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topLeft", {
        get: function() {
            return new Phaser.Point(this.x, this.y);
        },
        set: function(value) {
            this.x = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topRight", {
        get: function() {
            return new Phaser.Point(this.x + this.width, this.y);
        },
        set: function(value) {
            this.right = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Rectangle.prototype.constructor = Phaser.Rectangle;
    Phaser.Rectangle.inflate = function(a, dx, dy) {
        a.x -= dx;
        a.width += 2 * dx;
        a.y -= dy;
        a.height += 2 * dy;
        return a;
    };
    Phaser.Rectangle.inflatePoint = function(a, point) {
        return Phaser.Rectangle.inflate(a, point.x, point.y);
    };
    Phaser.Rectangle.size = function(a, output) {
        if (typeof output === "undefined" || output === null) {
            output = new Phaser.Point(a.width, a.height);
        } else {
            output.setTo(a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.clone = function(a, output) {
        if (typeof output === "undefined" || output === null) {
            output = new Phaser.Rectangle(a.x, a.y, a.width, a.height);
        } else {
            output.setTo(a.x, a.y, a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        return x >= a.x && x <= a.right && y >= a.y && y <= a.bottom;
    };
    Phaser.Rectangle.containsRaw = function(rx, ry, rw, rh, x, y) {
        return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
    };
    Phaser.Rectangle.containsPoint = function(a, point) {
        return Phaser.Rectangle.contains(a, point.x, point.y);
    };
    Phaser.Rectangle.containsRect = function(a, b) {
        if (a.volume > b.volume) {
            return false;
        }
        return a.x >= b.x && a.y >= b.y && a.right <= b.right && a.bottom <= b.bottom;
    };
    Phaser.Rectangle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
    };
    Phaser.Rectangle.intersection = function(a, b, output) {
        if (typeof output === "undefined") {
            output = new Phaser.Rectangle();
        }
        if (Phaser.Rectangle.intersects(a, b)) {
            output.x = Math.max(a.x, b.x);
            output.y = Math.max(a.y, b.y);
            output.width = Math.min(a.right, b.right) - output.x;
            output.height = Math.min(a.bottom, b.bottom) - output.y;
        }
        return output;
    };
    Phaser.Rectangle.intersects = function(a, b) {
        if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) {
            return false;
        }
        return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    };
    Phaser.Rectangle.intersectsRaw = function(a, left, right, top, bottom, tolerance) {
        if (typeof tolerance === "undefined") {
            tolerance = 0;
        }
        return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);
    };
    Phaser.Rectangle.union = function(a, b, output) {
        if (typeof output === "undefined") {
            output = new Phaser.Rectangle();
        }
        return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
    };
    PIXI.Rectangle = Phaser.Rectangle;
    PIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0);
    Phaser.Line = function(x1, y1, x2, y2) {
        x1 = x1 || 0;
        y1 = y1 || 0;
        x2 = x2 || 0;
        y2 = y2 || 0;
        this.start = new Phaser.Point(x1, y1);
        this.end = new Phaser.Point(x2, y2);
    };
    Phaser.Line.prototype = {
        setTo: function(x1, y1, x2, y2) {
            this.start.setTo(x1, y1);
            this.end.setTo(x2, y2);
            return this;
        },
        fromSprite: function(startSprite, endSprite, useCenter) {
            if (typeof useCenter === "undefined") {
                useCenter = false;
            }
            if (useCenter) {
                return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y);
            } else {
                return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);
            }
        },
        intersects: function(line, asSegment, result) {
            return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);
        },
        pointOnLine: function(x, y) {
            return (x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y);
        },
        pointOnSegment: function(x, y) {
            var xMin = Math.min(this.start.x, this.end.x);
            var xMax = Math.max(this.start.x, this.end.x);
            var yMin = Math.min(this.start.y, this.end.y);
            var yMax = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax);
        },
        coordinatesOnLine: function(stepRate, results) {
            if (typeof stepRate === "undefined") {
                stepRate = 1;
            }
            if (typeof results === "undefined") {
                results = [];
            }
            var x1 = Math.round(this.start.x);
            var y1 = Math.round(this.start.y);
            var x2 = Math.round(this.end.x);
            var y2 = Math.round(this.end.y);
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            results.push([ x1, y1 ]);
            var i = 1;
            while (!(x1 == x2 && y1 == y2)) {
                var e2 = err << 1;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
                if (i % stepRate === 0) {
                    results.push([ x1, y1 ]);
                }
                i++;
            }
            return results;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y);
            } else {
                output.setTo(this.start.x, this.start.y, this.end.x, this.end.y);
            }
            return output;
        }
    };
    Object.defineProperty(Phaser.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y);
        }
    });
    Phaser.Line.intersectsPoints = function(a, b, e, f, asSegment, result) {
        if (typeof asSegment === "undefined") {
            asSegment = true;
        }
        if (typeof result === "undefined") {
            result = new Phaser.Point();
        }
        var a1 = b.y - a.y;
        var a2 = f.y - e.y;
        var b1 = a.x - b.x;
        var b2 = e.x - f.x;
        var c1 = b.x * a.y - a.x * b.y;
        var c2 = f.x * e.y - e.x * f.y;
        var denom = a1 * b2 - a2 * b1;
        if (denom === 0) {
            return null;
        }
        result.x = (b1 * c2 - b2 * c1) / denom;
        result.y = (a2 * c1 - a1 * c2) / denom;
        if (asSegment) {
            var uc = (f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y);
            var ua = ((f.x - e.x) * (a.y - e.y) - (f.y - e.y) * (a.x - e.x)) / uc;
            var ub = ((b.x - a.x) * (a.y - e.y) - (b.y - a.y) * (a.x - e.x)) / uc;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return result;
            } else {
                return null;
            }
        }
        return result;
    };
    Phaser.Line.intersects = function(a, b, asSegment, result) {
        return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);
    };
    Phaser.Ellipse = function(x, y, width, height) {
        this.type = Phaser.ELLIPSE;
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    };
    Phaser.Ellipse.prototype = {
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Ellipse(this.x, this.y, this.width, this.height);
            } else {
                output.setTo(this.x, this.y, this.width, this.height);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Ellipse.contains(this, x, y);
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        }
    };
    Phaser.Ellipse.prototype.constructor = Phaser.Ellipse;
    Object.defineProperty(Phaser.Ellipse.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value < this.x) {
                this.width = 0;
            } else {
                this.width = this.x + value;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            this.y = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value < this.y) {
                this.height = 0;
            } else {
                this.height = this.y + value;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "empty", {
        get: function() {
            return this.width === 0 || this.height === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Ellipse.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        var normx = (x - a.x) / a.width - .5;
        var normy = (y - a.y) / a.height - .5;
        normx *= normx;
        normy *= normy;
        return normx + normy < .25;
    };
    Phaser.Ellipse.prototype.getBounds = function() {
        return new Phaser.Rectangle(this.x, this.y, this.width, this.height);
    };
    PIXI.Ellipse = Phaser.Ellipse;
    Phaser.Polygon = function(points) {
        this.type = Phaser.POLYGON;
        this.points = points;
    };
    Phaser.Polygon.prototype = {
        clone: function(output) {
            var points = [];
            for (var i = 0; i < this.points.length; i++) {
                points.push(this.points[i].clone());
            }
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Polygon(points);
            } else {
                output.setTo(points);
            }
            return output;
        },
        contains: function(x, y) {
            var inside = false;
            for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
                var xi = this.points[i].x;
                var yi = this.points[i].y;
                var xj = this.points[j].x;
                var yj = this.points[j].y;
                var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                if (intersect) {
                    inside = !inside;
                }
            }
            return inside;
        },
        setTo: function(points) {
            this.points = points;
            return this;
        }
    };
    Phaser.Polygon.prototype.constructor = Phaser.Polygon;
    Object.defineProperty(Phaser.Polygon.prototype, "points", {
        get: function() {
            return this._points;
        },
        set: function(points) {
            if (!(points instanceof Array)) {
                points = Array.prototype.slice.call(arguments);
            }
            if (typeof points[0] === "number") {
                var p = [];
                for (var i = 0, len = points.length; i < len; i += 2) {
                    p.push(new Phaser.Point(points[i], points[i + 1]));
                }
                points = p;
            }
            this._points = points;
        }
    });
    Object.defineProperty(Phaser.Polygon.prototype, "area", {
        get: function() {
            var p1;
            var p2;
            var avgHeight;
            var width;
            var i;
            var y0 = Number.MAX_VALUE;
            var area = 0;
            for (i = 0; i < this.points.length; i++) {
                if (this.points[i].y < y0) {
                    y0 = this.points[i].y;
                }
            }
            for (i = 0; i < this.points.length; i++) {
                p1 = this.points[i];
                if (i === this.points.length - 1) {
                    p2 = this.points[0];
                } else {
                    p2 = this.points[i + 1];
                }
                avgHeight = (p1.y - y0 + (p2.y - y0)) / 2;
                width = p1.x - p2.x;
                area += avgHeight * width;
            }
            return area;
        }
    });
    PIXI.Polygon = Phaser.Polygon;
    Phaser.Camera = function(game, id, x, y, width, height) {
        this.game = game;
        this.world = game.world;
        this.id = 0;
        this.view = new Phaser.Rectangle(x, y, width, height);
        this.screenView = new Phaser.Rectangle(x, y, width, height);
        this.bounds = new Phaser.Rectangle(x, y, width, height);
        this.deadzone = null;
        this.visible = true;
        this.roundPx = true;
        this.atLimit = {
            x: false,
            y: false
        };
        this.target = null;
        this._edge = 0;
        this._position = new Phaser.Point();
        this.displayObject = null;
        this.scale = null;
    };
    Phaser.Camera.FOLLOW_LOCKON = 0;
    Phaser.Camera.FOLLOW_PLATFORMER = 1;
    Phaser.Camera.FOLLOW_TOPDOWN = 2;
    Phaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    Phaser.Camera.prototype = {
        follow: function(target, style) {
            if (typeof style === "undefined") {
                style = Phaser.Camera.FOLLOW_LOCKON;
            }
            this.target = target;
            var helper;
            switch (style) {
              case Phaser.Camera.FOLLOW_PLATFORMER:
                var w = this.width / 8;
                var h = this.height / 3;
                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * .25, w, h);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN:
                helper = Math.max(this.width, this.height) / 4;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:
                helper = Math.max(this.width, this.height) / 8;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_LOCKON:
                this.deadzone = null;
                break;

              default:
                this.deadzone = null;
                break;
            }
        },
        unfollow: function() {
            this.target = null;
        },
        focusOn: function(displayObject) {
            this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));
        },
        focusOnXY: function(x, y) {
            this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));
        },
        update: function() {
            if (this.target) {
                this.updateTarget();
            }
            if (this.bounds) {
                this.checkBounds();
            }
            if (this.roundPx) {
                this.view.floor();
            }
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y;
        },
        updateTarget: function() {
            if (this.deadzone) {
                this._edge = this.target.x - this.view.x;
                if (this._edge < this.deadzone.left) {
                    this.view.x = this.target.x - this.deadzone.left;
                } else if (this._edge > this.deadzone.right) {
                    this.view.x = this.target.x - this.deadzone.right;
                }
                this._edge = this.target.y - this.view.y;
                if (this._edge < this.deadzone.top) {
                    this.view.y = this.target.y - this.deadzone.top;
                } else if (this._edge > this.deadzone.bottom) {
                    this.view.y = this.target.y - this.deadzone.bottom;
                }
            } else {
                this.view.x = this.target.x - this.view.halfWidth;
                this.view.y = this.target.y - this.view.halfHeight;
            }
        },
        setBoundsToWorld: function() {
            if (this.bounds) {
                this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
            }
        },
        checkBounds: function() {
            this.atLimit.x = false;
            this.atLimit.y = false;
            if (this.view.x <= this.bounds.x) {
                this.atLimit.x = true;
                this.view.x = this.bounds.x;
            }
            if (this.view.right >= this.bounds.right) {
                this.atLimit.x = true;
                this.view.x = this.bounds.right - this.width;
            }
            if (this.view.y <= this.bounds.top) {
                this.atLimit.y = true;
                this.view.y = this.bounds.top;
            }
            if (this.view.bottom >= this.bounds.bottom) {
                this.atLimit.y = true;
                this.view.y = this.bounds.bottom - this.height;
            }
        },
        setPosition: function(x, y) {
            this.view.x = x;
            this.view.y = y;
            if (this.bounds) {
                this.checkBounds();
            }
        },
        setSize: function(width, height) {
            this.view.width = width;
            this.view.height = height;
        },
        reset: function() {
            this.target = null;
            this.view.x = 0;
            this.view.y = 0;
        }
    };
    Phaser.Camera.prototype.constructor = Phaser.Camera;
    Object.defineProperty(Phaser.Camera.prototype, "x", {
        get: function() {
            return this.view.x;
        },
        set: function(value) {
            this.view.x = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "y", {
        get: function() {
            return this.view.y;
        },
        set: function(value) {
            this.view.y = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "position", {
        get: function() {
            this._position.set(this.view.centerX, this.view.centerY);
            return this._position;
        },
        set: function(value) {
            if (typeof value.x !== "undefined") {
                this.view.x = value.x;
            }
            if (typeof value.y !== "undefined") {
                this.view.y = value.y;
            }
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "width", {
        get: function() {
            return this.view.width;
        },
        set: function(value) {
            this.view.width = value;
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "height", {
        get: function() {
            return this.view.height;
        },
        set: function(value) {
            this.view.height = value;
        }
    });
    Phaser.State = function() {
        this.game = null;
        this.add = null;
        this.make = null;
        this.camera = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.sound = null;
        this.scale = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.particles = null;
        this.physics = null;
        this.rnd = null;
    };
    Phaser.State.prototype = {
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    };
    Phaser.State.prototype.constructor = Phaser.State;
    Phaser.StateManager = function(game, pendingState) {
        this.game = game;
        this.states = {};
        this._pendingState = null;
        if (typeof pendingState !== "undefined" && pendingState !== null) {
            this._pendingState = pendingState;
        }
        this._clearWorld = false;
        this._clearCache = false;
        this._created = false;
        this._args = [];
        this.current = "";
        this.onInitCallback = null;
        this.onPreloadCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onResizeCallback = null;
        this.onPreRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onLoadRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
        this.onShutDownCallback = null;
    };
    Phaser.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this);
            this.game.onResume.add(this.resume, this);
            this.game.load.onLoadComplete.add(this.loadComplete, this);
            if (this._pendingState !== null) {
                if (typeof this._pendingState === "string") {
                    this.start(this._pendingState, false, false);
                } else {
                    this.add("default", this._pendingState, true);
                }
            }
        },
        add: function(key, state, autoStart) {
            if (typeof autoStart === "undefined") {
                autoStart = false;
            }
            var newState;
            if (state instanceof Phaser.State) {
                newState = state;
            } else if (typeof state === "object") {
                newState = state;
                newState.game = this.game;
            } else if (typeof state === "function") {
                newState = new state(this.game);
            }
            this.states[key] = newState;
            if (autoStart) {
                if (this.game.isBooted) {
                    this.start(key);
                } else {
                    this._pendingState = key;
                }
            }
            return newState;
        },
        remove: function(key) {
            if (this.current === key) {
                this.callbackContext = null;
                this.onInitCallback = null;
                this.onShutDownCallback = null;
                this.onPreloadCallback = null;
                this.onLoadRenderCallback = null;
                this.onLoadUpdateCallback = null;
                this.onCreateCallback = null;
                this.onUpdateCallback = null;
                this.onRenderCallback = null;
                this.onResizeCallback = null;
                this.onPausedCallback = null;
                this.onResumedCallback = null;
                this.onPauseUpdateCallback = null;
            }
            delete this.states[key];
        },
        start: function(key, clearWorld, clearCache) {
            if (typeof clearWorld === "undefined") {
                clearWorld = true;
            }
            if (typeof clearCache === "undefined") {
                clearCache = false;
            }
            if (this.checkState(key)) {
                this._pendingState = key;
                this._clearWorld = clearWorld;
                this._clearCache = clearCache;
                if (arguments.length > 3) {
                    this._args = Array.prototype.splice.call(arguments, 3);
                }
            }
        },
        restart: function(clearWorld, clearCache) {
            if (typeof clearWorld === "undefined") {
                clearWorld = true;
            }
            if (typeof clearCache === "undefined") {
                clearCache = false;
            }
            this._pendingState = this.current;
            this._clearWorld = clearWorld;
            this._clearCache = clearCache;
            if (arguments.length > 2) {
                this._args = Array.prototype.splice.call(arguments, 2);
            }
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                this.clearCurrentState();
                this.setCurrentState(this._pendingState);
                this._pendingState = null;
                if (this.onPreloadCallback) {
                    this.game.load.reset();
                    this.onPreloadCallback.call(this.callbackContext, this.game);
                    if (this.game.load.totalQueuedFiles() === 0 && this.game.load.totalQueuedPacks() === 0) {
                        this.loadComplete();
                    } else {
                        this.game.load.start();
                    }
                } else {
                    this.loadComplete();
                }
            }
        },
        clearCurrentState: function() {
            if (this.current) {
                if (this.onShutDownCallback) {
                    this.onShutDownCallback.call(this.callbackContext, this.game);
                }
                this.game.tweens.removeAll();
                this.game.camera.reset();
                this.game.input.reset(true);
                this.game.physics.clear();
                this.game.time.removeAll();
                this.game.scale.reset(this._clearWorld);
                if (this.game.debug) {
                    this.game.debug.reset();
                }
                if (this._clearWorld) {
                    this.game.world.shutdown();
                    if (this._clearCache === true) {
                        this.game.cache.destroy();
                    }
                }
            }
        },
        checkState: function(key) {
            if (this.states[key]) {
                var valid = false;
                if (this.states[key]["preload"]) {
                    valid = true;
                }
                if (this.states[key]["create"]) {
                    valid = true;
                }
                if (this.states[key]["update"]) {
                    valid = true;
                }
                if (this.states[key]["render"]) {
                    valid = true;
                }
                if (valid === false) {
                    console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render");
                    return false;
                }
                return true;
            } else {
                console.warn("Phaser.StateManager - No state found with the key: " + key);
                return false;
            }
        },
        link: function(key) {
            this.states[key].game = this.game;
            this.states[key].add = this.game.add;
            this.states[key].make = this.game.make;
            this.states[key].camera = this.game.camera;
            this.states[key].cache = this.game.cache;
            this.states[key].input = this.game.input;
            this.states[key].load = this.game.load;
            this.states[key].math = this.game.math;
            this.states[key].sound = this.game.sound;
            this.states[key].scale = this.game.scale;
            this.states[key].state = this;
            this.states[key].stage = this.game.stage;
            this.states[key].time = this.game.time;
            this.states[key].tweens = this.game.tweens;
            this.states[key].world = this.game.world;
            this.states[key].particles = this.game.particles;
            this.states[key].rnd = this.game.rnd;
            this.states[key].physics = this.game.physics;
        },
        setCurrentState: function(key) {
            this.callbackContext = this.states[key];
            this.link(key);
            this.onInitCallback = this.states[key]["init"] || this.dummy;
            this.onPreloadCallback = this.states[key]["preload"] || null;
            this.onLoadRenderCallback = this.states[key]["loadRender"] || null;
            this.onLoadUpdateCallback = this.states[key]["loadUpdate"] || null;
            this.onCreateCallback = this.states[key]["create"] || null;
            this.onUpdateCallback = this.states[key]["update"] || null;
            this.onPreRenderCallback = this.states[key]["preRender"] || null;
            this.onRenderCallback = this.states[key]["render"] || null;
            this.onResizeCallback = this.states[key]["resize"] || null;
            this.onPausedCallback = this.states[key]["paused"] || null;
            this.onResumedCallback = this.states[key]["resumed"] || null;
            this.onPauseUpdateCallback = this.states[key]["pauseUpdate"] || null;
            this.onShutDownCallback = this.states[key]["shutdown"] || this.dummy;
            this.current = key;
            this._created = false;
            this.onInitCallback.apply(this.callbackContext, this._args);
            this._args = [];
        },
        getCurrentState: function() {
            return this.states[this.current];
        },
        loadComplete: function() {
            if (this._created === false && this.onCreateCallback) {
                this._created = true;
                this.onCreateCallback.call(this.callbackContext, this.game);
            } else {
                this._created = true;
            }
        },
        pause: function() {
            if (this._created && this.onPausedCallback) {
                this.onPausedCallback.call(this.callbackContext, this.game);
            }
        },
        resume: function() {
            if (this._created && this.onResumedCallback) {
                this.onResumedCallback.call(this.callbackContext, this.game);
            }
        },
        update: function() {
            if (this._created && this.onUpdateCallback) {
                this.onUpdateCallback.call(this.callbackContext, this.game);
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        pauseUpdate: function() {
            if (this._created && this.onPauseUpdateCallback) {
                this.onPauseUpdateCallback.call(this.callbackContext, this.game);
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        preRender: function() {
            if (this.onPreRenderCallback) {
                this.onPreRenderCallback.call(this.callbackContext, this.game);
            }
        },
        resize: function(width, height) {
            if (this.onResizeCallback) {
                this.onResizeCallback.call(this.callbackContext, width, height);
            }
        },
        render: function() {
            if (this._created && this.onRenderCallback) {
                if (this.game.renderType === Phaser.CANVAS) {
                    this.game.context.save();
                    this.game.context.setTransform(1, 0, 0, 1, 0, 0);
                }
                this.onRenderCallback.call(this.callbackContext, this.game);
                if (this.game.renderType === Phaser.CANVAS) {
                    this.game.context.restore();
                }
            } else {
                if (this.onLoadRenderCallback) {
                    this.onLoadRenderCallback.call(this.callbackContext, this.game);
                }
            }
        },
        destroy: function() {
            this.clearCurrentState();
            this.callbackContext = null;
            this.onInitCallback = null;
            this.onShutDownCallback = null;
            this.onPreloadCallback = null;
            this.onLoadRenderCallback = null;
            this.onLoadUpdateCallback = null;
            this.onCreateCallback = null;
            this.onUpdateCallback = null;
            this.onRenderCallback = null;
            this.onPausedCallback = null;
            this.onResumedCallback = null;
            this.onPauseUpdateCallback = null;
            this.game = null;
            this.states = {};
            this._pendingState = null;
        }
    };
    Phaser.StateManager.prototype.constructor = Phaser.StateManager;
    Phaser.LinkedList = function() {
        this.next = null;
        this.prev = null;
        this.first = null;
        this.last = null;
        this.total = 0;
    };
    Phaser.LinkedList.prototype = {
        add: function(child) {
            if (this.total === 0 && this.first === null && this.last === null) {
                this.first = child;
                this.last = child;
                this.next = child;
                child.prev = this;
                this.total++;
                return child;
            }
            this.last.next = child;
            child.prev = this.last;
            this.last = child;
            this.total++;
            return child;
        },
        reset: function() {
            this.first = null;
            this.last = null;
            this.next = null;
            this.prev = null;
            this.total = 0;
        },
        remove: function(child) {
            if (this.total === 1) {
                this.reset();
                child.next = child.prev = null;
                return;
            }
            if (child === this.first) {
                this.first = this.first.next;
            } else if (child === this.last) {
                this.last = this.last.prev;
            }
            if (child.prev) {
                child.prev.next = child.next;
            }
            if (child.next) {
                child.next.prev = child.prev;
            }
            child.next = child.prev = null;
            if (this.first === null) {
                this.last = null;
            }
            this.total--;
        },
        callAll: function(callback) {
            if (!this.first || !this.last) {
                return;
            }
            var entity = this.first;
            do {
                if (entity && entity[callback]) {
                    entity[callback].call(entity);
                }
                entity = entity.next;
            } while (entity != this.last.next);
        }
    };
    Phaser.LinkedList.prototype.constructor = Phaser.LinkedList;
    Phaser.ArrayList = function() {
        this.total = 0;
        this.position = 0;
        this.list = [];
    };
    Phaser.ArrayList.prototype = {
        add: function(child) {
            if (!this.exists(child)) {
                this.list.push(child);
                this.total++;
            }
            return child;
        },
        getIndex: function(child) {
            return this.list.indexOf(child);
        },
        exists: function(child) {
            return this.list.indexOf(child) > -1;
        },
        reset: function() {
            this.list.length = 0;
            this.total = 0;
        },
        remove: function(child) {
            var idx = this.list.indexOf(child);
            if (idx > -1) {
                this.list.splice(idx, 1);
                this.total--;
                return child;
            }
        },
        setAll: function(key, value) {
            var i = this.list.length;
            while (i--) {
                if (this.list[i] && this.list[i][key]) {
                    this.list[i][key] = value;
                }
            }
        },
        callAll: function(callback) {
            var args = Array.prototype.splice.call(arguments, 1);
            var i = this.list.length;
            while (i--) {
                if (this.list[i] && this.list[i][callback]) {
                    this.list[i][callback].apply(this.list[i], args);
                }
            }
        }
    };
    Object.defineProperty(Phaser.ArrayList.prototype, "first", {
        get: function() {
            this.position = 0;
            if (this.total > 0) {
                return this.list[0];
            } else {
                return null;
            }
        }
    });
    Object.defineProperty(Phaser.ArrayList.prototype, "next", {
        get: function() {
            if (this.position < this.total) {
                this.position++;
                return this.list[this.position];
            } else {
                return null;
            }
        }
    });
    Phaser.ArrayList.prototype.constructor = Phaser.ArrayList;
    Phaser.Signal = function() {
        this._bindings = [];
        this._prevParams = null;
        var self = this;
        this.dispatch = function() {
            Phaser.Signal.prototype.dispatch.apply(self, arguments);
        };
    };
    Phaser.Signal.prototype = {
        memorize: false,
        _shouldPropagate: true,
        active: true,
        validateListener: function(listener, fnName) {
            if (typeof listener !== "function") {
                throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
            }
        },
        _registerListener: function(listener, isOnce, listenerContext, priority) {
            var prevIndex = this._indexOfListener(listener, listenerContext);
            var binding;
            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
                }
            } else {
                binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }
            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }
            return binding;
        },
        _addBinding: function(binding) {
            var n = this._bindings.length;
            do {
                n--;
            } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },
        _indexOfListener: function(listener, context) {
            var n = this._bindings.length;
            var cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },
        has: function(listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },
        add: function(listener, listenerContext, priority) {
            this.validateListener(listener, "add");
            return this._registerListener(listener, false, listenerContext, priority);
        },
        addOnce: function(listener, listenerContext, priority) {
            this.validateListener(listener, "addOnce");
            return this._registerListener(listener, true, listenerContext, priority);
        },
        remove: function(listener, context) {
            this.validateListener(listener, "remove");
            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy();
                this._bindings.splice(i, 1);
            }
            return listener;
        },
        removeAll: function(context) {
            if (typeof context === "undefined") {
                context = null;
            }
            var n = this._bindings.length;
            while (n--) {
                if (context) {
                    if (this._bindings[n].context === context) {
                        this._bindings[n]._destroy();
                        this._bindings.splice(n, 1);
                    }
                } else {
                    this._bindings[n]._destroy();
                }
            }
            if (!context) {
                this._bindings.length = 0;
            }
        },
        getNumListeners: function() {
            return this._bindings.length;
        },
        halt: function() {
            this._shouldPropagate = false;
        },
        dispatch: function() {
            if (!this.active) {
                return;
            }
            var paramsArr = Array.prototype.slice.call(arguments);
            var n = this._bindings.length;
            var bindings;
            if (this.memorize) {
                this._prevParams = paramsArr;
            }
            if (!n) {
                return;
            }
            bindings = this._bindings.slice();
            this._shouldPropagate = true;
            do {
                n--;
            } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },
        forget: function() {
            this._prevParams = null;
        },
        dispose: function() {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    };
    Phaser.Signal.prototype.constructor = Phaser.Signal;
    Phaser.SignalBinding = function(signal, listener, isOnce, listenerContext, priority) {
        this._listener = listener;
        this._isOnce = isOnce;
        this.context = listenerContext;
        this._signal = signal;
        this._priority = priority || 0;
    };
    Phaser.SignalBinding.prototype = {
        active: true,
        params: null,
        execute: function(paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    };
    Phaser.SignalBinding.prototype.constructor = Phaser.SignalBinding;
    Phaser.Filter = function(game, uniforms, fragmentSrc) {
        this.game = game;
        this.type = Phaser.WEBGL_FILTER;
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = {
            time: {
                type: "1f",
                value: 0
            },
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            }
        };
        this.fragmentSrc = fragmentSrc || [];
    };
    Phaser.Filter.prototype = {
        init: function() {},
        setResolution: function(width, height) {
            this.uniforms.resolution.value.x = width;
            this.uniforms.resolution.value.y = height;
        },
        update: function(pointer) {
            if (typeof pointer !== "undefined") {
                if (pointer.x > 0) {
                    this.uniforms.mouse.x = pointer.x.toFixed(2);
                }
                if (pointer.y > 0) {
                    this.uniforms.mouse.y = pointer.y.toFixed(2);
                }
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        destroy: function() {
            this.game = null;
        }
    };
    Phaser.Filter.prototype.constructor = Phaser.Filter;
    Object.defineProperty(Phaser.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x;
        },
        set: function(value) {
            this.uniforms.resolution.value.x = value;
        }
    });
    Object.defineProperty(Phaser.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y;
        },
        set: function(value) {
            this.uniforms.resolution.value.y = value;
        }
    });
    Phaser.Plugin = function(game, parent) {
        if (typeof parent === "undefined") {
            parent = null;
        }
        this.game = game;
        this.parent = parent;
        this.active = false;
        this.visible = false;
        this.hasPreUpdate = false;
        this.hasUpdate = false;
        this.hasPostUpdate = false;
        this.hasRender = false;
        this.hasPostRender = false;
    };
    Phaser.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null;
            this.parent = null;
            this.active = false;
            this.visible = false;
        }
    };
    Phaser.Plugin.prototype.constructor = Phaser.Plugin;
    Phaser.PluginManager = function(game) {
        this.game = game;
        this.plugins = [];
        this._len = 0;
        this._i = 0;
    };
    Phaser.PluginManager.prototype = {
        add: function(plugin) {
            var args = Array.prototype.splice.call(arguments, 1);
            var result = false;
            if (typeof plugin === "function") {
                plugin = new plugin(this.game, this);
            } else {
                plugin.game = this.game;
                plugin.parent = this;
            }
            if (typeof plugin["preUpdate"] === "function") {
                plugin.hasPreUpdate = true;
                result = true;
            }
            if (typeof plugin["update"] === "function") {
                plugin.hasUpdate = true;
                result = true;
            }
            if (typeof plugin["postUpdate"] === "function") {
                plugin.hasPostUpdate = true;
                result = true;
            }
            if (typeof plugin["render"] === "function") {
                plugin.hasRender = true;
                result = true;
            }
            if (typeof plugin["postRender"] === "function") {
                plugin.hasPostRender = true;
                result = true;
            }
            if (result) {
                if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate) {
                    plugin.active = true;
                }
                if (plugin.hasRender || plugin.hasPostRender) {
                    plugin.visible = true;
                }
                this._len = this.plugins.push(plugin);
                if (typeof plugin["init"] === "function") {
                    plugin.init.apply(plugin, args);
                }
                return plugin;
            } else {
                return null;
            }
        },
        remove: function(plugin) {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i] === plugin) {
                    plugin.destroy();
                    this.plugins.splice(this._i, 1);
                    this._len--;
                    return;
                }
            }
        },
        removeAll: function() {
            this._i = this._len;
            while (this._i--) {
                this.plugins[this._i].destroy();
            }
            this.plugins.length = 0;
            this._len = 0;
        },
        preUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) {
                    this.plugins[this._i].preUpdate();
                }
            }
        },
        update: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) {
                    this.plugins[this._i].update();
                }
            }
        },
        postUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) {
                    this.plugins[this._i].postUpdate();
                }
            }
        },
        render: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) {
                    this.plugins[this._i].render();
                }
            }
        },
        postRender: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) {
                    this.plugins[this._i].postRender();
                }
            }
        },
        destroy: function() {
            this.removeAll();
            this.game = null;
        }
    };
    Phaser.PluginManager.prototype.constructor = Phaser.PluginManager;
    Phaser.Stage = function(game) {
        this.game = game;
        PIXI.Stage.call(this, 0);
        this.name = "_stage_root";
        this.interactive = false;
        this.disableVisibilityChange = false;
        this.exists = true;
        this.currentRenderOrderID = 0;
        this._hiddenVar = "hidden";
        this._backgroundColor = 0;
        if (game.config) {
            this.parseConfig(game.config);
        }
    };
    Phaser.Stage.prototype = Object.create(PIXI.Stage.prototype);
    Phaser.Stage.prototype.constructor = Phaser.Stage;
    Phaser.Stage.prototype.parseConfig = function(config) {
        if (config["disableVisibilityChange"]) {
            this.disableVisibilityChange = config["disableVisibilityChange"];
        }
        if (config["backgroundColor"]) {
            this.backgroundColor = config["backgroundColor"];
        }
    };
    Phaser.Stage.prototype.boot = function() {
        Phaser.Canvas.getOffset(this.game.canvas, this.offset);
        var _this = this;
        this._onChange = function(event) {
            return _this.visibilityChange(event);
        };
        Phaser.Canvas.setUserSelect(this.game.canvas, "none");
        Phaser.Canvas.setTouchAction(this.game.canvas, "none");
        this.checkVisibility();
    };
    Phaser.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        var len = this.children.length;
        for (var i = 0; i < len; i++) {
            this.children[i].preUpdate();
        }
    };
    Phaser.Stage.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Stage.prototype.postUpdate = function() {
        if (this.game.world.camera.target) {
            this.game.world.camera.target.postUpdate();
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                if (this.children[i] !== this.game.world.camera.target) {
                    this.children[i].postUpdate();
                }
            }
        } else {
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                this.children[i].postUpdate();
            }
        }
    };
    Phaser.Stage.prototype.checkVisibility = function() {
        if (document.webkitHidden !== undefined) {
            this._hiddenVar = "webkitvisibilitychange";
        } else if (document.mozHidden !== undefined) {
            this._hiddenVar = "mozvisibilitychange";
        } else if (document.msHidden !== undefined) {
            this._hiddenVar = "msvisibilitychange";
        } else if (document.hidden !== undefined) {
            this._hiddenVar = "visibilitychange";
        } else {
            this._hiddenVar = null;
        }
        if (this._hiddenVar) {
            document.addEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onpagehide = this._onChange;
        window.onpageshow = this._onChange;
        window.onblur = this._onChange;
        window.onfocus = this._onChange;
        var _this = this;
        if (this.game.device.cocoonJSApp) {
            CocoonJS.App.onSuspended.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "pause"
                });
            });
            CocoonJS.App.onActivated.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "resume"
                });
            });
        }
    };
    Phaser.Stage.prototype.visibilityChange = function(event) {
        if (event.type === "pagehide" || event.type === "blur" || event.type === "pageshow" || event.type === "focus") {
            if (event.type === "pagehide" || event.type === "blur") {
                this.game.focusLoss(event);
            } else if (event.type === "pageshow" || event.type === "focus") {
                this.game.focusGain(event);
            }
            return;
        }
        if (this.disableVisibilityChange) {
            return;
        }
        if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || event.type === "pause") {
            this.game.gamePaused(event);
        } else {
            this.game.gameResumed(event);
        }
    };
    Phaser.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        if (typeof backgroundColor === "string") {
            var rgb = Phaser.Color.hexToColor(backgroundColor);
            this._backgroundColor = Phaser.Color.getColor(rgb.r, rgb.g, rgb.b);
        } else {
            var rgb = Phaser.Color.getRGB(backgroundColor);
            this._backgroundColor = backgroundColor;
        }
        this.backgroundColorSplit = [ rgb.r / 255, rgb.g / 255, rgb.b / 255 ];
        this.backgroundColorString = Phaser.Color.RGBtoString(rgb.r, rgb.g, rgb.b, 255, "#");
    };
    Phaser.Stage.prototype.destroy = function() {
        if (this._hiddenVar) {
            document.removeEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onpagehide = null;
        window.onpageshow = null;
        window.onblur = null;
        window.onfocus = null;
    };
    Object.defineProperty(Phaser.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor;
        },
        set: function(color) {
            if (!this.game.transparent) {
                this.setBackgroundColor(color);
            }
        }
    });
    Object.defineProperty(Phaser.Stage.prototype, "smoothed", {
        get: function() {
            return !PIXI.scaleModes.LINEAR;
        },
        set: function(value) {
            if (value) {
                PIXI.scaleModes.LINEAR = 0;
            } else {
                PIXI.scaleModes.LINEAR = 1;
            }
        }
    });
    Phaser.Group = function(game, parent, name, addToStage, enableBody, physicsBodyType) {
        if (typeof addToStage === "undefined") {
            addToStage = false;
        }
        if (typeof enableBody === "undefined") {
            enableBody = false;
        }
        if (typeof physicsBodyType === "undefined") {
            physicsBodyType = Phaser.Physics.ARCADE;
        }
        this.game = game;
        if (typeof parent === "undefined") {
            parent = game.world;
        }
        this.name = name || "group";
        PIXI.DisplayObjectContainer.call(this);
        if (addToStage) {
            this.game.stage.addChild(this);
        } else {
            if (parent) {
                parent.addChild(this);
            }
        }
        this.z = 0;
        this.type = Phaser.GROUP;
        this.alive = true;
        this.exists = true;
        this.classType = Phaser.Sprite;
        this.scale = new Phaser.Point(1, 1);
        this.cursor = null;
        this.cameraOffset = new Phaser.Point();
        this.enableBody = enableBody;
        this.enableBodyDebug = false;
        this.physicsBodyType = physicsBodyType;
        this.onDestroy = new Phaser.Signal();
        this._sortProperty = "z";
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 ];
    };
    Phaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    Phaser.Group.prototype.constructor = Phaser.Group;
    Phaser.Group.RETURN_NONE = 0;
    Phaser.Group.RETURN_TOTAL = 1;
    Phaser.Group.RETURN_CHILD = 2;
    Phaser.Group.SORT_ASCENDING = -1;
    Phaser.Group.SORT_DESCENDING = 1;
    Phaser.Group.prototype.add = function(child, silent) {
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (child.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(child, this.physicsBodyType);
            }
            this.addChild(child);
            child.z = this.children.length;
            if (!silent && child.events) {
                child.events.onAddedToGroup.dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.addMultiple = function(children, silent) {
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                this.add(children[i], silent);
            }
        }
        return children;
    };
    Phaser.Group.prototype.addAt = function(child, index, silent) {
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (child.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(child, this.physicsBodyType);
            }
            this.addChildAt(child, index);
            this.updateZ();
            if (!silent && child.events) {
                child.events.onAddedToGroup.dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.getAt = function(index) {
        if (index < 0 || index >= this.children.length) {
            return -1;
        } else {
            return this.getChildAt(index);
        }
    };
    Phaser.Group.prototype.create = function(x, y, key, frame, exists) {
        if (typeof exists === "undefined") {
            exists = true;
        }
        var child = new this.classType(this.game, x, y, key, frame);
        if (this.enableBody) {
            this.game.physics.enable(child, this.physicsBodyType, this.enableBodyDebug);
        }
        child.exists = exists;
        child.visible = exists;
        child.alive = exists;
        this.addChild(child);
        child.z = this.children.length;
        if (child.events) {
            child.events.onAddedToGroup.dispatch(child, this);
        }
        if (this.cursor === null) {
            this.cursor = child;
        }
        return child;
    };
    Phaser.Group.prototype.createMultiple = function(quantity, key, frame, exists) {
        if (typeof exists === "undefined") {
            exists = false;
        }
        for (var i = 0; i < quantity; i++) {
            this.create(0, 0, key, frame, exists);
        }
    };
    Phaser.Group.prototype.updateZ = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].z = i;
        }
    };
    Phaser.Group.prototype.resetCursor = function(index) {
        if (typeof index === "undefined") {
            index = 0;
        }
        if (index > this.children.length - 1) {
            index = 0;
        }
        if (this.cursor) {
            this._cache[8] = index;
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.next = function() {
        if (this.cursor) {
            if (this._cache[8] >= this.children.length - 1) {
                this._cache[8] = 0;
            } else {
                this._cache[8]++;
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.previous = function() {
        if (this.cursor) {
            if (this._cache[8] === 0) {
                this._cache[8] = this.children.length - 1;
            } else {
                this._cache[8]--;
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.swap = function(child1, child2) {
        this.swapChildren(child1, child2);
        this.updateZ();
    };
    Phaser.Group.prototype.bringToTop = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length) {
            this.remove(child, false, true);
            this.add(child, true);
        }
        return child;
    };
    Phaser.Group.prototype.sendToBack = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            this.remove(child, false, true);
            this.addAt(child, 0, true);
        }
        return child;
    };
    Phaser.Group.prototype.moveUp = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length - 1) {
            var a = this.getIndex(child);
            var b = this.getAt(a + 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.moveDown = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            var a = this.getIndex(child);
            var b = this.getAt(a - 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.xy = function(index, x, y) {
        if (index < 0 || index > this.children.length) {
            return -1;
        } else {
            this.getChildAt(index).x = x;
            this.getChildAt(index).y = y;
        }
    };
    Phaser.Group.prototype.reverse = function() {
        this.children.reverse();
        this.updateZ();
    };
    Phaser.Group.prototype.getIndex = function(child) {
        return this.children.indexOf(child);
    };
    Phaser.Group.prototype.replace = function(oldChild, newChild) {
        var index = this.getIndex(oldChild);
        if (index !== -1) {
            if (newChild.parent !== undefined) {
                newChild.events.onRemovedFromGroup.dispatch(newChild, this);
                newChild.parent.removeChild(newChild);
                if (newChild.parent instanceof Phaser.Group) {
                    newChild.parent.updateZ();
                }
            }
            var temp = oldChild;
            this.remove(temp);
            this.addAt(newChild, index);
            return temp;
        }
    };
    Phaser.Group.prototype.hasProperty = function(child, key) {
        var len = key.length;
        if (len === 1 && key[0] in child) {
            return true;
        } else if (len === 2 && key[0] in child && key[1] in child[key[0]]) {
            return true;
        } else if (len === 3 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]]) {
            return true;
        } else if (len === 4 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]]) {
            return true;
        }
        return false;
    };
    Phaser.Group.prototype.setProperty = function(child, key, value, operation, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        operation = operation || 0;
        if (!this.hasProperty(child, key) && (!force || operation > 0)) {
            return false;
        }
        var len = key.length;
        if (len === 1) {
            if (operation === 0) {
                child[key[0]] = value;
            } else if (operation == 1) {
                child[key[0]] += value;
            } else if (operation == 2) {
                child[key[0]] -= value;
            } else if (operation == 3) {
                child[key[0]] *= value;
            } else if (operation == 4) {
                child[key[0]] /= value;
            }
        } else if (len === 2) {
            if (operation === 0) {
                child[key[0]][key[1]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]] /= value;
            }
        } else if (len === 3) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]] /= value;
            }
        } else if (len === 4) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]][key[3]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]][key[3]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]][key[3]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]][key[3]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]][key[3]] /= value;
            }
        }
        return true;
    };
    Phaser.Group.prototype.checkProperty = function(child, key, value, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        if (!Phaser.Utils.getProperty(child, key) && force) {
            return false;
        }
        if (Phaser.Utils.getProperty(child, key) !== value) {
            return false;
        }
        return true;
    };
    Phaser.Group.prototype.set = function(child, key, value, checkAlive, checkVisible, operation, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        key = key.split(".");
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if ((checkAlive === false || checkAlive && child.alive) && (checkVisible === false || checkVisible && child.visible)) {
            return this.setProperty(child, key, value, operation, force);
        }
    };
    Phaser.Group.prototype.setAll = function(key, value, checkAlive, checkVisible, operation, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        key = key.split(".");
        operation = operation || 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                this.setProperty(this.children[i], key, value, operation, force);
            }
        }
    };
    Phaser.Group.prototype.setAllChildren = function(key, value, checkAlive, checkVisible, operation, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        operation = operation || 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (this.children[i] instanceof Phaser.Group) {
                    this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force);
                } else {
                    this.setProperty(this.children[i], key.split("."), value, operation, force);
                }
            }
        }
    };
    Phaser.Group.prototype.checkAll = function(key, value, checkAlive, checkVisible, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (!this.checkProperty(this.children[i], key, value, force)) {
                    return false;
                }
            }
        }
        return true;
    };
    Phaser.Group.prototype.addAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 1);
    };
    Phaser.Group.prototype.subAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 2);
    };
    Phaser.Group.prototype.multiplyAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 3);
    };
    Phaser.Group.prototype.divideAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 4);
    };
    Phaser.Group.prototype.callAllExists = function(callback, existsValue) {
        var args = Array.prototype.splice.call(arguments, 2);
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i].exists === existsValue && this.children[i][callback]) {
                this.children[i][callback].apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.callbackFromArray = function(child, callback, length) {
        if (length == 1) {
            if (child[callback[0]]) {
                return child[callback[0]];
            }
        } else if (length == 2) {
            if (child[callback[0]][callback[1]]) {
                return child[callback[0]][callback[1]];
            }
        } else if (length == 3) {
            if (child[callback[0]][callback[1]][callback[2]]) {
                return child[callback[0]][callback[1]][callback[2]];
            }
        } else if (length == 4) {
            if (child[callback[0]][callback[1]][callback[2]][callback[3]]) {
                return child[callback[0]][callback[1]][callback[2]][callback[3]];
            }
        } else {
            if (child[callback]) {
                return child[callback];
            }
        }
        return false;
    };
    Phaser.Group.prototype.callAll = function(method, context) {
        if (typeof method === "undefined") {
            return;
        }
        method = method.split(".");
        var methodLength = method.length;
        if (typeof context === "undefined" || context === null || context === "") {
            context = null;
        } else {
            if (typeof context === "string") {
                context = context.split(".");
                var contextLength = context.length;
            }
        }
        var args = Array.prototype.splice.call(arguments, 2);
        var callback = null;
        var callbackContext = null;
        for (var i = 0, len = this.children.length; i < len; i++) {
            callback = this.callbackFromArray(this.children[i], method, methodLength);
            if (context && callback) {
                callbackContext = this.callbackFromArray(this.children[i], context, contextLength);
                if (callback) {
                    callback.apply(callbackContext, args);
                }
            } else if (callback) {
                callback.apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.preUpdate = function() {
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Group.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Group.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.x = this.game.camera.view.x + this.cameraOffset.x;
            this.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Group.prototype.forEach = function(callback, callbackContext, checkExists) {
        if (typeof checkExists === "undefined") {
            checkExists = false;
        }
        var args = Array.prototype.splice.call(arguments, 3);
        args.unshift(null);
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (!checkExists || checkExists && this.children[i].exists) {
                args[0] = this.children[i];
                callback.apply(callbackContext, args);
            }
        }
    };
    Phaser.Group.prototype.forEachExists = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("exists", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachAlive = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("alive", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachDead = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("alive", false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.sort = function(index, order) {
        if (this.children.length < 2) {
            return;
        }
        if (typeof index === "undefined") {
            index = "z";
        }
        if (typeof order === "undefined") {
            order = Phaser.Group.SORT_ASCENDING;
        }
        this._sortProperty = index;
        if (order === Phaser.Group.SORT_ASCENDING) {
            this.children.sort(this.ascendingSortHandler.bind(this));
        } else {
            this.children.sort(this.descendingSortHandler.bind(this));
        }
        this.updateZ();
    };
    Phaser.Group.prototype.customSort = function(sortHandler, context) {
        if (this.children.length < 2) {
            return;
        }
        this.children.sort(sortHandler.bind(context));
        this.updateZ();
    };
    Phaser.Group.prototype.ascendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return -1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return 1;
        } else {
            if (a.z < b.z) {
                return -1;
            } else {
                return 1;
            }
        }
    };
    Phaser.Group.prototype.descendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return 1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return -1;
        } else {
            return 0;
        }
    };
    Phaser.Group.prototype.iterate = function(key, value, returnType, callback, callbackContext, args) {
        if (returnType === Phaser.Group.RETURN_TOTAL && this.children.length === 0) {
            return 0;
        }
        if (typeof callback === "undefined") {
            callback = false;
        }
        var total = 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][key] === value) {
                total++;
                if (callback) {
                    args[0] = this.children[i];
                    callback.apply(callbackContext, args);
                }
                if (returnType === Phaser.Group.RETURN_CHILD) {
                    return this.children[i];
                }
            }
        }
        if (returnType === Phaser.Group.RETURN_TOTAL) {
            return total;
        } else if (returnType === Phaser.Group.RETURN_CHILD) {
            return null;
        }
    };
    Phaser.Group.prototype.getFirstExists = function(state) {
        if (typeof state !== "boolean") {
            state = true;
        }
        return this.iterate("exists", state, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getTop = function() {
        if (this.children.length > 0) {
            return this.children[this.children.length - 1];
        }
    };
    Phaser.Group.prototype.getBottom = function() {
        if (this.children.length > 0) {
            return this.children[0];
        }
    };
    Phaser.Group.prototype.countLiving = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.countDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.getRandom = function(startIndex, length) {
        if (this.children.length === 0) {
            return null;
        }
        startIndex = startIndex || 0;
        length = length || this.children.length;
        return this.game.math.getRandom(this.children, startIndex, length);
    };
    Phaser.Group.prototype.remove = function(child, destroy, silent) {
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0 || this.children.indexOf(child) === -1) {
            return false;
        }
        if (!silent && child.events && !child.destroyPhase) {
            child.events.onRemovedFromGroup.dispatch(child, this);
        }
        var removed = this.removeChild(child);
        this.updateZ();
        if (this.cursor === child) {
            this.next();
        }
        if (destroy && removed) {
            removed.destroy(true);
        }
        return true;
    };
    Phaser.Group.prototype.removeAll = function(destroy, silent) {
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        do {
            if (!silent && this.children[0].events) {
                this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this);
            }
            var removed = this.removeChild(this.children[0]);
            if (destroy && removed) {
                removed.destroy(true);
            }
        } while (this.children.length > 0);
        this.cursor = null;
    };
    Phaser.Group.prototype.removeBetween = function(startIndex, endIndex, destroy, silent) {
        if (typeof endIndex === "undefined") {
            endIndex = this.children.length - 1;
        }
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length) {
            return false;
        }
        var i = endIndex;
        while (i >= startIndex) {
            if (!silent && this.children[i].events) {
                this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);
            }
            var removed = this.removeChild(this.children[i]);
            if (destroy && removed) {
                removed.destroy(true);
            }
            if (this.cursor === this.children[i]) {
                this.cursor = null;
            }
            i--;
        }
        this.updateZ();
    };
    Phaser.Group.prototype.destroy = function(destroyChildren, soft) {
        if (this.game === null) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        if (typeof soft === "undefined") {
            soft = false;
        }
        this.onDestroy.dispatch(this, destroyChildren, soft);
        this.removeAll(destroyChildren);
        this.cursor = null;
        this.filters = null;
        if (!soft) {
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this.game = null;
            this.exists = false;
        }
    };
    Object.defineProperty(Phaser.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", true, Phaser.Group.RETURN_TOTAL);
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "length", {
        get: function() {
            return this.children.length;
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Phaser.World = function(game) {
        Phaser.Group.call(this, game, null, "__world", false);
        this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height);
        this.camera = null;
        this._definedSize = false;
        this._width = game.width;
        this._height = game.height;
    };
    Phaser.World.prototype = Object.create(Phaser.Group.prototype);
    Phaser.World.prototype.constructor = Phaser.World;
    Phaser.World.prototype.boot = function() {
        this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this;
        this.camera.scale = this.scale;
        this.game.camera = this.camera;
        this.game.stage.addChild(this);
    };
    Phaser.World.prototype.setBounds = function(x, y, width, height) {
        this._definedSize = true;
        this._width = width;
        this._height = height;
        this.bounds.setTo(x, y, width, height);
        if (this.camera.bounds) {
            this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height));
        }
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.resize = function(width, height) {
        if (this._definedSize) {
            if (width < this._width) {
                width = this._width;
            }
            if (height < this._height) {
                height = this._height;
            }
        }
        this.bounds.width = width;
        this.bounds.height = height;
        this.game.camera.setBoundsToWorld();
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.shutdown = function() {
        this.destroy(true, true);
    };
    Phaser.World.prototype.wrap = function(sprite, padding, useBounds, horizontal, vertical) {
        if (typeof padding === "undefined") {
            padding = 0;
        }
        if (typeof useBounds === "undefined") {
            useBounds = false;
        }
        if (typeof horizontal === "undefined") {
            horizontal = true;
        }
        if (typeof vertical === "undefined") {
            vertical = true;
        }
        if (!useBounds) {
            if (horizontal && sprite.x + padding < this.bounds.x) {
                sprite.x = this.bounds.right + padding;
            } else if (horizontal && sprite.x - padding > this.bounds.right) {
                sprite.x = this.bounds.left - padding;
            }
            if (vertical && sprite.y + padding < this.bounds.top) {
                sprite.y = this.bounds.bottom + padding;
            } else if (vertical && sprite.y - padding > this.bounds.bottom) {
                sprite.y = this.bounds.top - padding;
            }
        } else {
            sprite.getBounds();
            if (horizontal) {
                if (sprite.x + sprite._currentBounds.width < this.bounds.x) {
                    sprite.x = this.bounds.right;
                } else if (sprite.x > this.bounds.right) {
                    sprite.x = this.bounds.left;
                }
            }
            if (vertical) {
                if (sprite.y + sprite._currentBounds.height < this.bounds.top) {
                    sprite.y = this.bounds.bottom;
                } else if (sprite.y > this.bounds.bottom) {
                    sprite.y = this.bounds.top;
                }
            }
        }
    };
    Object.defineProperty(Phaser.World.prototype, "width", {
        get: function() {
            return this.bounds.width;
        },
        set: function(value) {
            if (value < this.game.width) {
                value = this.game.width;
            }
            this.bounds.width = value;
            this._width = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "height", {
        get: function() {
            return this.bounds.height;
        },
        set: function(value) {
            if (value < this.game.height) {
                value = this.game.height;
            }
            this.bounds.height = value;
            this._height = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomX", {
        get: function() {
            if (this.bounds.x < 0) {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x));
            } else {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width);
            }
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomY", {
        get: function() {
            if (this.bounds.y < 0) {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y));
            } else {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height);
            }
        }
    });
    Phaser.FlexGrid = function(manager, width, height) {
        this.game = manager.game;
        this.manager = manager;
        this.width = width;
        this.height = height;
        this.boundsFluid = new Phaser.Rectangle(0, 0, width, height);
        this.boundsFull = new Phaser.Rectangle(0, 0, width, height);
        this.boundsNone = new Phaser.Rectangle(0, 0, width, height);
        this.positionFluid = new Phaser.Point(0, 0);
        this.positionFull = new Phaser.Point(0, 0);
        this.positionNone = new Phaser.Point(0, 0);
        this.scaleFluid = new Phaser.Point(1, 1);
        this.scaleFluidInversed = new Phaser.Point(1, 1);
        this.scaleFull = new Phaser.Point(1, 1);
        this.scaleNone = new Phaser.Point(1, 1);
        this.ratioH = width / height;
        this.ratioV = height / width;
        this.multiplier = 0;
        this.layers = [];
    };
    Phaser.FlexGrid.prototype = {
        setSize: function(width, height) {
            this.width = width;
            this.height = height;
            this.ratioH = width / height;
            this.ratioV = height / width;
            this.scaleNone = new Phaser.Point(1, 1);
            this.boundsNone.width = this.width;
            this.boundsNone.height = this.height;
            this.refresh();
        },
        createFluidLayer: function(children, addToWorld) {
            if (typeof addToWorld === "undefined") {
                addToWorld = true;
            }
            var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            if (addToWorld) {
                this.game.world.add(layer);
            }
            this.layers.push(layer);
            if (typeof children !== "undefined" && typeof children !== null) {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFullLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFixedLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        reset: function() {
            var i = this.layers.length;
            while (i--) {
                if (!this.layers[i].persist) {
                    this.layers[i].position = null;
                    this.layers[i].scale = null;
                    this.layers.slice(i, 1);
                }
            }
        },
        onResize: function(width, height) {
            this.refresh(width, height);
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width);
            this.boundsFluid.width = Math.round(this.width * this.multiplier);
            this.boundsFluid.height = Math.round(this.height * this.multiplier);
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height);
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height);
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height);
            this.boundsFull.width = this.manager.width * this.scaleFluidInversed.x;
            this.boundsFull.height = this.manager.height * this.scaleFluidInversed.y;
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y);
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        debug: function() {
            this.game.debug.text(this.boundsFull.width + " x " + this.boundsFull.height, this.boundsFull.x + 4, this.boundsFull.y + 16);
            this.game.debug.geom(this.boundsFull, "rgba(0,0,255,0.9", false);
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16);
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", false);
            this.game.debug.text(this.boundsNone.width + " x " + this.boundsNone.height, this.boundsNone.x + 4, this.boundsNone.y + 16);
            this.game.debug.geom(this.boundsNone, "rgba(0,255,0,0.9", false);
        }
    };
    Phaser.FlexGrid.prototype.constructor = Phaser.FlexGrid;
    Phaser.FlexLayer = function(manager, position, bounds, scale) {
        Phaser.Group.call(this, manager.game, null, "__flexLayer" + manager.game.rnd.uuid(), false);
        this.manager = manager.manager;
        this.grid = manager;
        this.persist = false;
        this.position = position;
        this.bounds = bounds;
        this.scale = scale;
        this.topLeft = bounds.topLeft;
        this.topMiddle = new Phaser.Point(bounds.halfWidth, 0);
        this.topRight = bounds.topRight;
        this.bottomLeft = bounds.bottomLeft;
        this.bottomMiddle = new Phaser.Point(bounds.halfWidth, bounds.bottom);
        this.bottomRight = bounds.bottomRight;
    };
    Phaser.FlexLayer.prototype = Object.create(Phaser.Group.prototype);
    Phaser.FlexLayer.prototype.constructor = Phaser.FlexLayer;
    Phaser.FlexLayer.prototype.resize = function() {};
    Phaser.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16);
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", false);
        this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    };
    Phaser.ScaleManager = function(game, width, height) {
        this.game = game;
        this.grid = null;
        this.width = 0;
        this.height = 0;
        this.minWidth = null;
        this.maxWidth = null;
        this.minHeight = null;
        this.maxHeight = null;
        this.offset = new Phaser.Point();
        this.forceLandscape = false;
        this.forcePortrait = false;
        this.incorrectOrientation = false;
        this.pageAlignHorizontally = false;
        this.pageAlignVertically = false;
        this.maxIterations = 5;
        this.enterLandscape = new Phaser.Signal();
        this.enterPortrait = new Phaser.Signal();
        this.enterIncorrectOrientation = new Phaser.Signal();
        this.leaveIncorrectOrientation = new Phaser.Signal();
        this.fullScreenTarget = null;
        this.enterFullScreen = new Phaser.Signal();
        this.leaveFullScreen = new Phaser.Signal();
        this.orientation = 0;
        if (window["orientation"]) {
            this.orientation = window["orientation"];
        } else {
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90;
            }
        }
        this.scaleFactor = new Phaser.Point(1, 1);
        this.scaleFactorInversed = new Phaser.Point(1, 1);
        this.margin = new Phaser.Point(0, 0);
        this.bounds = new Phaser.Rectangle();
        this.aspectRatio = 0;
        this.sourceAspectRatio = 0;
        this.event = null;
        this.fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;
        this.parentIsWindow = false;
        this.parentNode = null;
        this.parentScaleFactor = new Phaser.Point(1, 1);
        this.trackParentInterval = 2e3;
        this.onResize = null;
        this.onResizeContext = null;
        this._scaleMode = Phaser.ScaleManager.NO_SCALE;
        this._width = 0;
        this._height = 0;
        this._check = null;
        this._nextParentCheck = 0;
        this._parentBounds = null;
        if (game.config) {
            this.parseConfig(game.config);
        }
        this.setupScale(width, height);
    };
    Phaser.ScaleManager.EXACT_FIT = 0;
    Phaser.ScaleManager.NO_SCALE = 1;
    Phaser.ScaleManager.SHOW_ALL = 2;
    Phaser.ScaleManager.RESIZE = 3;
    Phaser.ScaleManager.prototype = {
        parseConfig: function(config) {
            if (config["scaleMode"]) {
                this.scaleMode = config["scaleMode"];
            }
            if (config["fullScreenScaleMode"]) {
                this.fullScreenScaleMode = config["fullScreenScaleMode"];
            }
            if (config["fullScreenTarget"]) {
                this.fullScreenTarget = config["fullScreenTarget"];
            }
        },
        setupScale: function(width, height) {
            var target;
            var rect = new Phaser.Rectangle();
            if (this.game.parent !== "") {
                if (typeof this.game.parent === "string") {
                    target = document.getElementById(this.game.parent);
                } else if (typeof this.game.parent === "object" && this.game.parent.nodeType === 1) {
                    target = this.game.parent;
                }
            }
            if (!target) {
                this.parentNode = null;
                this.parentIsWindow = true;
                rect.width = window.innerWidth;
                rect.height = window.innerHeight;
            } else {
                this.parentNode = target;
                this.parentIsWindow = false;
                this._parentBounds = this.parentNode.getBoundingClientRect();
                rect.width = this._parentBounds.width;
                rect.height = this._parentBounds.height;
                this.offset.set(this._parentBounds.left, this._parentBounds.top);
            }
            var newWidth = 0;
            var newHeight = 0;
            if (typeof width === "number") {
                newWidth = width;
            } else {
                this.parentScaleFactor.x = parseInt(width, 10) / 100;
                newWidth = rect.width * this.parentScaleFactor.x;
            }
            if (typeof height === "number") {
                newHeight = height;
            } else {
                this.parentScaleFactor.y = parseInt(height, 10) / 100;
                newHeight = rect.height * this.parentScaleFactor.y;
            }
            this.grid = new Phaser.FlexGrid(this, newWidth, newHeight);
            this.updateDimensions(newWidth, newHeight, false);
        },
        boot: function() {
            this.fullScreenTarget = this.game.canvas;
            var _this = this;
            this._checkOrientation = function(event) {
                return _this.checkOrientation(event);
            };
            this._checkResize = function(event) {
                return _this.checkResize(event);
            };
            this._fullScreenChange = function(event) {
                return _this.fullScreenChange(event);
            };
            window.addEventListener("orientationchange", this._checkOrientation, false);
            window.addEventListener("resize", this._checkResize, false);
            if (!this.game.device.cocoonJS) {
                document.addEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("fullscreenchange", this._fullScreenChange, false);
            }
            this.updateDimensions(this.width, this.height, true);
            Phaser.Canvas.getOffset(this.game.canvas, this.offset);
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
        },
        setResizeCallback: function(callback, context) {
            this.onResize = callback;
            this.onResizeContext = context;
        },
        setMinMax: function(minWidth, minHeight, maxWidth, maxHeight) {
            this.minWidth = minWidth;
            this.minHeight = minHeight;
            if (typeof maxWidth !== "undefined") {
                this.maxWidth = maxWidth;
            }
            if (typeof maxHeight !== "undefined") {
                this.maxHeight = maxHeight;
            }
        },
        preUpdate: function() {
            if (this.game.time.now < this._nextParentCheck) {
                return;
            }
            if (!this.parentIsWindow) {
                Phaser.Canvas.getOffset(this.game.canvas, this.offset);
                if (this._scaleMode === Phaser.ScaleManager.RESIZE) {
                    this._parentBounds = this.parentNode.getBoundingClientRect();
                    if (this._parentBounds.width !== this.width || this._parentBounds.height !== this.height) {
                        this.updateDimensions(this._parentBounds.width, this._parentBounds.height, true);
                    }
                }
            }
            this._nextParentCheck = this.game.time.now + this.trackParentInterval;
        },
        updateDimensions: function(width, height, resize) {
            this.width = width * this.parentScaleFactor.x;
            this.height = height * this.parentScaleFactor.y;
            this.game.width = this.width;
            this.game.height = this.height;
            this.sourceAspectRatio = this.width / this.height;
            this.bounds.width = this.width;
            this.bounds.height = this.height;
            if (resize) {
                this.game.renderer.resize(this.width, this.height);
                this.game.camera.setSize(this.width, this.height);
                this.game.world.resize(this.width, this.height);
            }
            this.grid.onResize(width, height);
            if (this.onResize) {
                this.onResize.call(this.onResizeContext, this.width, this.height);
            }
            this.game.state.resize(width, height);
        },
        forceOrientation: function(forceLandscape, forcePortrait) {
            if (typeof forcePortrait === "undefined") {
                forcePortrait = false;
            }
            this.forceLandscape = forceLandscape;
            this.forcePortrait = forcePortrait;
        },
        checkOrientationState: function() {
            if (this.incorrectOrientation) {
                if (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) {
                    this.incorrectOrientation = false;
                    this.leaveIncorrectOrientation.dispatch();
                    if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                        this.refresh();
                    }
                }
            } else {
                if (this.forceLandscape && window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) {
                    this.incorrectOrientation = true;
                    this.enterIncorrectOrientation.dispatch();
                    if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                        this.refresh();
                    }
                }
            }
        },
        checkOrientation: function(event) {
            this.event = event;
            this.orientation = window["orientation"];
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false);
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true);
            }
            if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                this.refresh();
            }
        },
        checkResize: function(event) {
            this.event = event;
            var wasLandscape = this.isLandscape;
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90;
            } else {
                this.orientation = 0;
            }
            if (wasLandscape && this.isPortrait) {
                this.enterPortrait.dispatch(this.orientation, false, true);
                if (this.forceLandscape) {
                    this.enterIncorrectOrientation.dispatch();
                } else if (this.forcePortrait) {
                    this.leaveIncorrectOrientation.dispatch();
                }
            } else if (!wasLandscape && this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false);
                if (this.forceLandscape) {
                    this.leaveIncorrectOrientation.dispatch();
                } else if (this.forcePortrait) {
                    this.enterIncorrectOrientation.dispatch();
                }
            }
            if (this._scaleMode === Phaser.ScaleManager.RESIZE && this.parentIsWindow) {
                this.updateDimensions(window.innerWidth, window.innerHeight, true);
            } else if (this._scaleMode === Phaser.ScaleManager.EXACT_FIT || this._scaleMode === Phaser.ScaleManager.SHOW_ALL) {
                this.refresh();
                this.checkOrientationState();
                if (this.onResize) {
                    this.onResize.call(this.onResizeContext, this.width, this.height);
                }
            }
        },
        refresh: function() {
            if (this.scaleMode === Phaser.ScaleManager.RESIZE) {
                return;
            }
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1);
                } else {
                    window.scrollTo(0, 0);
                }
            }
            if (this._check === null && this.maxIterations > 0) {
                this._iterations = this.maxIterations;
                var _this = this;
                this._check = window.setInterval(function() {
                    return _this.setScreenSize();
                }, 10);
                this.setScreenSize();
            }
        },
        setScreenSize: function(force) {
            if (this.scaleMode === Phaser.ScaleManager.RESIZE) {
                return;
            }
            if (typeof force === "undefined") {
                force = false;
            }
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1);
                } else {
                    window.scrollTo(0, 0);
                }
            }
            this._iterations--;
            if (force || this._iterations < 0) {
                document.documentElement["style"].minHeight = window.innerHeight + "px";
                if (this.incorrectOrientation) {
                    this.setMaximum();
                } else if (!this.isFullScreen) {
                    if (this.scaleMode === Phaser.ScaleManager.EXACT_FIT) {
                        this.setExactFit();
                    } else if (this.scaleMode === Phaser.ScaleManager.SHOW_ALL) {
                        this.setShowAll();
                    }
                } else {
                    if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) {
                        this.setExactFit();
                    } else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL) {
                        this.setShowAll();
                    }
                }
                this.setSize();
                clearInterval(this._check);
                this._check = null;
            }
        },
        setSize: function() {
            if (!this.incorrectOrientation) {
                if (this.maxWidth && this.width > this.maxWidth) {
                    this.width = this.maxWidth;
                }
                if (this.maxHeight && this.height > this.maxHeight) {
                    this.height = this.maxHeight;
                }
                if (this.minWidth && this.width < this.minWidth) {
                    this.width = this.minWidth;
                }
                if (this.minHeight && this.height < this.minHeight) {
                    this.height = this.minHeight;
                }
            }
            this.game.canvas.style.width = this.width + "px";
            this.game.canvas.style.height = this.height + "px";
            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
            if (this.pageAlignHorizontally) {
                if (this.width < window.innerWidth && !this.incorrectOrientation) {
                    this.margin.x = Math.round((window.innerWidth - this.width) / 2);
                    this.game.canvas.style.marginLeft = this.margin.x + "px";
                } else {
                    this.margin.x = 0;
                    this.game.canvas.style.marginLeft = "0px";
                }
            }
            if (this.pageAlignVertically) {
                if (this.height < window.innerHeight && !this.incorrectOrientation) {
                    this.margin.y = Math.round((window.innerHeight - this.height) / 2);
                    this.game.canvas.style.marginTop = this.margin.y + "px";
                } else {
                    this.margin.y = 0;
                    this.game.canvas.style.marginTop = "0px";
                }
            }
            Phaser.Canvas.getOffset(this.game.canvas, this.offset);
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
            this.aspectRatio = this.width / this.height;
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height;
            this.scaleFactorInversed.x = this.width / this.game.width;
            this.scaleFactorInversed.y = this.height / this.game.height;
            this.checkOrientationState();
        },
        reset: function(clearWorld) {
            if (clearWorld) {
                this.grid.reset();
            }
        },
        setMaximum: function() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
        },
        setShowAll: function() {
            var multiplier = Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
            this.width = Math.round(this.game.width * multiplier);
            this.height = Math.round(this.game.height * multiplier);
        },
        setExactFit: function() {
            var availableWidth = window.innerWidth;
            var availableHeight = window.innerHeight;
            if (this.maxWidth && availableWidth > this.maxWidth) {
                this.width = this.maxWidth;
            } else {
                this.width = availableWidth;
            }
            if (this.maxHeight && availableHeight > this.maxHeight) {
                this.height = this.maxHeight;
            } else {
                this.height = availableHeight;
            }
        },
        startFullScreen: function(antialias) {
            if (this.isFullScreen || !this.game.device.fullscreen) {
                return;
            }
            if (typeof antialias !== "undefined" && this.game.renderType === Phaser.CANVAS) {
                this.game.stage.smoothed = antialias;
            }
            this._width = this.width;
            this._height = this.height;
            if (this.game.device.fullscreenKeyboard) {
                this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
            } else {
                this.fullScreenTarget[this.game.device.requestFullscreen]();
            }
        },
        stopFullScreen: function() {
            document[this.game.device.cancelFullscreen]();
        },
        fullScreenChange: function(event) {
            this.event = event;
            if (this.isFullScreen) {
                if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) {
                    this.fullScreenTarget.style["width"] = "100%";
                    this.fullScreenTarget.style["height"] = "100%";
                    this.width = window.outerWidth;
                    this.height = window.outerHeight;
                    this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                    this.aspectRatio = this.width / this.height;
                    this.scaleFactor.x = this.game.width / this.width;
                    this.scaleFactor.y = this.game.height / this.height;
                    this.checkResize();
                } else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL) {
                    this.setShowAll();
                    this.refresh();
                }
                this.enterFullScreen.dispatch(this.width, this.height);
            } else {
                this.fullScreenTarget.style["width"] = this.game.width + "px";
                this.fullScreenTarget.style["height"] = this.game.height + "px";
                this.width = this._width;
                this.height = this._height;
                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                this.aspectRatio = this.width / this.height;
                this.scaleFactor.x = this.game.width / this.width;
                this.scaleFactor.y = this.game.height / this.height;
                this.leaveFullScreen.dispatch(this.width, this.height);
            }
        },
        destroy: function() {
            window.removeEventListener("orientationchange", this._checkOrientation, false);
            window.removeEventListener("resize", this._checkResize, false);
            if (!this.game.device.cocoonJS) {
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("fullscreenchange", this._fullScreenChange, false);
            }
        }
    };
    Phaser.ScaleManager.prototype.constructor = Phaser.ScaleManager;
    Object.defineProperty(Phaser.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode;
        },
        set: function(value) {
            if (value !== this._scaleMode) {
                this._scaleMode = value;
            }
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return document["fullscreenElement"] || document["mozFullScreenElement"] || document["webkitFullscreenElement"];
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return this.orientation === 0 || this.orientation === 180;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return this.orientation === 90 || this.orientation === -90;
        }
    });
    Phaser.Game = function(width, height, renderer, parent, state, transparent, antialias, physicsConfig) {
        this.id = Phaser.GAMES.push(this) - 1;
        this.config = null;
        this.physicsConfig = physicsConfig;
        this.parent = "";
        this.width = 800;
        this.height = 600;
        this.transparent = false;
        this.antialias = true;
        this.preserveDrawingBuffer = false;
        this.renderer = null;
        this.renderType = Phaser.AUTO;
        this.state = null;
        this.isBooted = false;
        this.isRunning = false;
        this.raf = null;
        this.add = null;
        this.make = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.net = null;
        this.scale = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.physics = null;
        this.rnd = null;
        this.device = null;
        this.camera = null;
        this.canvas = null;
        this.context = null;
        this.debug = null;
        this.particles = null;
        this.stepping = false;
        this.pendingStep = false;
        this.stepCount = 0;
        this.onPause = null;
        this.onResume = null;
        this.onBlur = null;
        this.onFocus = null;
        this._paused = false;
        this._codePaused = false;
        this._width = 800;
        this._height = 600;
        if (arguments.length === 1 && typeof arguments[0] === "object") {
            this.parseConfig(arguments[0]);
        } else {
            this.config = {
                enableDebug: true
            };
            if (typeof width !== "undefined") {
                this._width = width;
            }
            if (typeof height !== "undefined") {
                this._height = height;
            }
            if (typeof renderer !== "undefined") {
                this.renderType = renderer;
            }
            if (typeof parent !== "undefined") {
                this.parent = parent;
            }
            if (typeof transparent !== "undefined") {
                this.transparent = transparent;
            }
            if (typeof antialias !== "undefined") {
                this.antialias = antialias;
            }
            this.rnd = new Phaser.RandomDataGenerator([ (Date.now() * Math.random()).toString() ]);
            this.state = new Phaser.StateManager(this, state);
        }
        var _this = this;
        this._onBoot = function() {
            return _this.boot();
        };
        if (document.readyState === "complete" || document.readyState === "interactive") {
            window.setTimeout(this._onBoot, 0);
        } else if (typeof window.cordova !== "undefined") {
            document.addEventListener("deviceready", this._onBoot, false);
        } else {
            document.addEventListener("DOMContentLoaded", this._onBoot, false);
            window.addEventListener("load", this._onBoot, false);
        }
        return this;
    };
    Phaser.Game.prototype = {
        parseConfig: function(config) {
            this.config = config;
            if (typeof config["enableDebug"] === "undefined") {
                this.config.enableDebug = true;
            }
            if (config["width"]) {
                this._width = config["width"];
            }
            if (config["height"]) {
                this._height = config["height"];
            }
            if (config["renderer"]) {
                this.renderType = config["renderer"];
            }
            if (config["parent"]) {
                this.parent = config["parent"];
            }
            if (config["transparent"]) {
                this.transparent = config["transparent"];
            }
            if (config["antialias"]) {
                this.antialias = config["antialias"];
            }
            if (config["preserveDrawingBuffer"]) {
                this.preserveDrawingBuffer = config["preserveDrawingBuffer"];
            }
            if (config["physicsConfig"]) {
                this.physicsConfig = config["physicsConfig"];
            }
            var seed = [ (Date.now() * Math.random()).toString() ];
            if (config["seed"]) {
                seed = config["seed"];
            }
            this.rnd = new Phaser.RandomDataGenerator(seed);
            var state = null;
            if (config["state"]) {
                state = config["state"];
            }
            this.state = new Phaser.StateManager(this, state);
        },
        boot: function() {
            if (this.isBooted) {
                return;
            }
            if (!document.body) {
                window.setTimeout(this._onBoot, 20);
            } else {
                document.removeEventListener("DOMContentLoaded", this._onBoot);
                window.removeEventListener("load", this._onBoot);
                this.onPause = new Phaser.Signal();
                this.onResume = new Phaser.Signal();
                this.onBlur = new Phaser.Signal();
                this.onFocus = new Phaser.Signal();
                this.isBooted = true;
                this.device = new Phaser.Device(this);
                this.math = Phaser.Math;
                this.scale = new Phaser.ScaleManager(this, this._width, this._height);
                this.stage = new Phaser.Stage(this);
                this.setUpRenderer();
                this.device.checkFullScreenSupport();
                this.world = new Phaser.World(this);
                this.add = new Phaser.GameObjectFactory(this);
                this.make = new Phaser.GameObjectCreator(this);
                this.cache = new Phaser.Cache(this);
                this.load = new Phaser.Loader(this);
                this.time = new Phaser.Time(this);
                this.tweens = new Phaser.TweenManager(this);
                this.input = new Phaser.Input(this);
                this.sound = new Phaser.SoundManager(this);
                this.physics = new Phaser.Physics(this, this.physicsConfig);
                this.particles = new Phaser.Particles(this);
                this.plugins = new Phaser.PluginManager(this);
                this.net = new Phaser.Net(this);
                this.time.boot();
                this.stage.boot();
                this.world.boot();
                this.scale.boot();
                this.input.boot();
                this.sound.boot();
                this.state.boot();
                if (this.config["enableDebug"]) {
                    this.debug = new Phaser.Utils.Debug(this);
                    this.debug.boot();
                }
                this.showDebugHeader();
                this.isRunning = true;
                if (this.config && this.config["forceSetTimeOut"]) {
                    this.raf = new Phaser.RequestAnimationFrame(this, this.config["forceSetTimeOut"]);
                } else {
                    this.raf = new Phaser.RequestAnimationFrame(this, false);
                }
                this.raf.start();
            }
        },
        showDebugHeader: function() {
            var v = Phaser.VERSION;
            var r = "Canvas";
            var a = "HTML Audio";
            var c = 1;
            if (this.renderType === Phaser.WEBGL) {
                r = "WebGL";
                c++;
            } else if (this.renderType == Phaser.HEADLESS) {
                r = "Headless";
            }
            if (this.device.webAudio) {
                a = "WebAudio";
                c++;
            }
            if (this.device.chrome) {
                var args = [ "%c %c %c Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + "  %c %c " + " http://phaser.io  %c %c ♥%c♥%c♥ ", "background: #7a66a3", "background: #625186", "color: #ffffff; background: #43375b;", "background: #625186", "background: #ccb9f2", "background: #625186" ];
                for (var i = 0; i < 3; i++) {
                    if (i < c) {
                        args.push("color: #ff2424; background: #fff");
                    } else {
                        args.push("color: #959595; background: #fff");
                    }
                }
                console.log.apply(console, args);
            } else if (window["console"]) {
                console.log("Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + " | http://phaser.io");
            }
        },
        setUpRenderer: function() {
            if (this.device.trident) {
                this.renderType = Phaser.CANVAS;
            }
            if (this.config["canvasID"]) {
                this.canvas = Phaser.Canvas.create(this.width, this.height, this.config["canvasID"]);
            } else {
                this.canvas = Phaser.Canvas.create(this.width, this.height);
            }
            if (this.config["canvasStyle"]) {
                this.canvas.style = this.config["canvasStyle"];
            } else {
                this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
            }
            if (this.device.cocoonJS) {
                if (this.renderType === Phaser.CANVAS) {
                    this.canvas.screencanvas = true;
                } else {
                    this.canvas.screencanvas = false;
                }
            }
            if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || this.renderType === Phaser.AUTO && this.device.webGL === false) {
                if (this.device.canvas) {
                    if (this.renderType === Phaser.AUTO) {
                        this.renderType = Phaser.CANVAS;
                    }
                    this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent);
                    this.context = this.renderer.context;
                } else {
                    throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                }
            } else {
                this.renderType = Phaser.WEBGL;
                this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer);
                this.context = null;
            }
            if (this.renderType !== Phaser.HEADLESS) {
                this.stage.smoothed = this.antialias;
                Phaser.Canvas.addToDOM(this.canvas, this.parent, false);
                Phaser.Canvas.setTouchAction(this.canvas);
            }
        },
        update: function(time) {
            this.time.update(time);
            if (!this._paused && !this.pendingStep) {
                if (this.stepping) {
                    this.pendingStep = true;
                }
                this.scale.preUpdate();
                if (this.config["enableDebug"]) {
                    this.debug.preUpdate();
                }
                this.physics.preUpdate();
                this.state.preUpdate();
                this.plugins.preUpdate();
                this.stage.preUpdate();
                this.state.update();
                this.stage.update();
                this.tweens.update();
                this.sound.update();
                this.input.update();
                this.physics.update();
                this.particles.update();
                this.plugins.update();
                this.stage.postUpdate();
                this.plugins.postUpdate();
            } else {
                this.state.pauseUpdate();
                if (this.config["enableDebug"]) {
                    this.debug.preUpdate();
                }
            }
            if (this.renderType != Phaser.HEADLESS) {
                this.state.preRender();
                this.renderer.render(this.stage);
                this.plugins.render();
                this.state.render();
                this.plugins.postRender();
                if (this.device.cocoonJS && this.renderType === Phaser.CANVAS && this.stage.currentRenderOrderID === 1) {
                    this.context.fillRect(0, 0, 0, 0);
                }
            }
        },
        enableStep: function() {
            this.stepping = true;
            this.pendingStep = false;
            this.stepCount = 0;
        },
        disableStep: function() {
            this.stepping = false;
            this.pendingStep = false;
        },
        step: function() {
            this.pendingStep = false;
            this.stepCount++;
        },
        destroy: function() {
            this.raf.stop();
            this.state.destroy();
            this.sound.destroy();
            this.scale.destroy();
            this.stage.destroy();
            this.input.destroy();
            this.physics.destroy();
            this.state = null;
            this.cache = null;
            this.input = null;
            this.load = null;
            this.sound = null;
            this.stage = null;
            this.time = null;
            this.world = null;
            this.isBooted = false;
            Phaser.Canvas.removeFromDOM(this.canvas);
        },
        gamePaused: function(event) {
            if (!this._paused) {
                this._paused = true;
                this.time.gamePaused();
                this.sound.setMute();
                this.onPause.dispatch(event);
            }
        },
        gameResumed: function(event) {
            if (this._paused && !this._codePaused) {
                this._paused = false;
                this.time.gameResumed();
                this.input.reset();
                this.sound.unsetMute();
                this.onResume.dispatch(event);
            }
        },
        focusLoss: function(event) {
            this.onBlur.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gamePaused(event);
            }
        },
        focusGain: function(event) {
            this.onFocus.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gameResumed(event);
            }
        }
    };
    Phaser.Game.prototype.constructor = Phaser.Game;
    Object.defineProperty(Phaser.Game.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(value) {
            if (value === true) {
                if (this._paused === false) {
                    this._paused = true;
                    this.sound.setMute();
                    this.time.gamePaused();
                    this.onPause.dispatch(this);
                }
                this._codePaused = true;
            } else {
                if (this._paused) {
                    this._paused = false;
                    this.input.reset();
                    this.sound.unsetMute();
                    this.time.gameResumed();
                    this.onResume.dispatch(this);
                }
                this._codePaused = false;
            }
        }
    });
    Phaser.Input = function(game) {
        this.game = game;
        this.hitCanvas = null;
        this.hitContext = null;
        this.moveCallbacks = [];
        this.moveCallback = null;
        this.moveCallbackContext = this;
        this.pollRate = 0;
        this.disabled = false;
        this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE;
        this.position = null;
        this.speed = null;
        this.circle = null;
        this.scale = null;
        this.maxPointers = 10;
        this.currentPointers = 0;
        this.tapRate = 200;
        this.doubleTapRate = 300;
        this.holdRate = 2e3;
        this.justPressedRate = 200;
        this.justReleasedRate = 200;
        this.recordPointerHistory = false;
        this.recordRate = 100;
        this.recordLimit = 100;
        this.pointer1 = null;
        this.pointer2 = null;
        this.pointer3 = null;
        this.pointer4 = null;
        this.pointer5 = null;
        this.pointer6 = null;
        this.pointer7 = null;
        this.pointer8 = null;
        this.pointer9 = null;
        this.pointer10 = null;
        this.activePointer = null;
        this.mousePointer = null;
        this.mouse = null;
        this.keyboard = null;
        this.touch = null;
        this.mspointer = null;
        this.gamepad = null;
        this.resetLocked = false;
        this.onDown = null;
        this.onUp = null;
        this.onTap = null;
        this.onHold = null;
        this.minPriorityID = 0;
        this.interactiveItems = new Phaser.ArrayList();
        this._localPoint = new Phaser.Point();
        this._pollCounter = 0;
        this._oldPosition = null;
        this._x = 0;
        this._y = 0;
    };
    Phaser.Input.MOUSE_OVERRIDES_TOUCH = 0;
    Phaser.Input.TOUCH_OVERRIDES_MOUSE = 1;
    Phaser.Input.MOUSE_TOUCH_COMBINE = 2;
    Phaser.Input.prototype = {
        boot: function() {
            this.mousePointer = new Phaser.Pointer(this.game, 0);
            this.pointer1 = new Phaser.Pointer(this.game, 1);
            this.pointer2 = new Phaser.Pointer(this.game, 2);
            this.mouse = new Phaser.Mouse(this.game);
            this.keyboard = new Phaser.Keyboard(this.game);
            this.touch = new Phaser.Touch(this.game);
            this.mspointer = new Phaser.MSPointer(this.game);
            this.gamepad = new Phaser.Gamepad(this.game);
            this.onDown = new Phaser.Signal();
            this.onUp = new Phaser.Signal();
            this.onTap = new Phaser.Signal();
            this.onHold = new Phaser.Signal();
            this.scale = new Phaser.Point(1, 1);
            this.speed = new Phaser.Point();
            this.position = new Phaser.Point();
            this._oldPosition = new Phaser.Point();
            this.circle = new Phaser.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.currentPointers = 0;
            this.hitCanvas = document.createElement("canvas");
            this.hitCanvas.width = 1;
            this.hitCanvas.height = 1;
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.keyboard.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = true;
        },
        destroy: function() {
            this.mouse.stop();
            this.keyboard.stop();
            this.touch.stop();
            this.mspointer.stop();
            this.gamepad.stop();
            this.moveCallbacks = [];
        },
        addMoveCallback: function(callback, context) {
            return this.moveCallbacks.push({
                callback: callback,
                context: context
            }) - 1;
        },
        deleteMoveCallback: function(index) {
            if (this.moveCallbacks[index]) {
                this.moveCallbacks.splice(index, 1);
            }
        },
        addPointer: function() {
            var next = 0;
            for (var i = 10; i > 0; i--) {
                if (this["pointer" + i] === null) {
                    next = i;
                }
            }
            if (next === 0) {
                console.warn("You can only have 10 Pointer objects");
                return null;
            } else {
                this["pointer" + next] = new Phaser.Pointer(this.game, next);
                return this["pointer" + next];
            }
        },
        update: function() {
            this.keyboard.update();
            if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
                this._pollCounter++;
                return;
            }
            this.speed.x = this.position.x - this._oldPosition.x;
            this.speed.y = this.position.y - this._oldPosition.y;
            this._oldPosition.copyFrom(this.position);
            this.mousePointer.update();
            if (this.gamepad.active) {
                this.gamepad.update();
            }
            this.pointer1.update();
            this.pointer2.update();
            if (this.pointer3) {
                this.pointer3.update();
            }
            if (this.pointer4) {
                this.pointer4.update();
            }
            if (this.pointer5) {
                this.pointer5.update();
            }
            if (this.pointer6) {
                this.pointer6.update();
            }
            if (this.pointer7) {
                this.pointer7.update();
            }
            if (this.pointer8) {
                this.pointer8.update();
            }
            if (this.pointer9) {
                this.pointer9.update();
            }
            if (this.pointer10) {
                this.pointer10.update();
            }
            this._pollCounter = 0;
        },
        reset: function(hard) {
            if (!this.game.isBooted || this.resetLocked) {
                return;
            }
            if (typeof hard === "undefined") {
                hard = false;
            }
            this.keyboard.reset(hard);
            this.mousePointer.reset();
            this.gamepad.reset();
            for (var i = 1; i <= 10; i++) {
                if (this["pointer" + i]) {
                    this["pointer" + i].reset();
                }
            }
            this.currentPointers = 0;
            if (this.game.canvas.style.cursor !== "none") {
                this.game.canvas.style.cursor = "inherit";
            }
            if (hard) {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onTap.dispose();
                this.onHold.dispose();
                this.onDown = new Phaser.Signal();
                this.onUp = new Phaser.Signal();
                this.onTap = new Phaser.Signal();
                this.onHold = new Phaser.Signal();
                this.moveCallbacks = [];
            }
            this._pollCounter = 0;
        },
        resetSpeed: function(x, y) {
            this._oldPosition.setTo(x, y);
            this.speed.setTo(0, 0);
        },
        startPointer: function(event) {
            if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers) {
                return null;
            }
            if (this.pointer1.active === false) {
                return this.pointer1.start(event);
            } else if (this.pointer2.active === false) {
                return this.pointer2.start(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active === false) {
                        return this["pointer" + i].start(event);
                    }
                }
            }
            return null;
        },
        updatePointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier == event.identifier) {
                return this.pointer1.move(event);
            } else if (this.pointer2.active && this.pointer2.identifier == event.identifier) {
                return this.pointer2.move(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active && this["pointer" + i].identifier == event.identifier) {
                        return this["pointer" + i].move(event);
                    }
                }
            }
            return null;
        },
        stopPointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier == event.identifier) {
                return this.pointer1.stop(event);
            } else if (this.pointer2.active && this.pointer2.identifier == event.identifier) {
                return this.pointer2.stop(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active && this["pointer" + i].identifier == event.identifier) {
                        return this["pointer" + i].stop(event);
                    }
                }
            }
            return null;
        },
        getPointer: function(state) {
            state = state || false;
            if (this.pointer1.active == state) {
                return this.pointer1;
            } else if (this.pointer2.active == state) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active == state) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getPointerFromIdentifier: function(identifier) {
            if (this.pointer1.identifier === identifier) {
                return this.pointer1;
            } else if (this.pointer2.identifier === identifier) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].identifier === identifier) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getPointerFromId: function(pointerId) {
            if (this.pointer1.pointerId === pointerId) {
                return this.pointer1;
            } else if (this.pointer2.pointerId === pointerId) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].pointerId === pointerId) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getLocalPosition: function(displayObject, pointer, output) {
            if (typeof output === "undefined") {
                output = new Phaser.Point();
            }
            var wt = displayObject.worldTransform;
            var id = 1 / (wt.a * wt.d + wt.b * -wt.c);
            return output.setTo(wt.d * id * pointer.x + -wt.b * id * pointer.y + (wt.ty * wt.b - wt.tx * wt.d) * id, wt.a * id * pointer.y + -wt.c * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.c) * id);
        },
        hitTest: function(displayObject, pointer, localPoint) {
            if (!displayObject.worldVisible) {
                return false;
            }
            this.getLocalPosition(displayObject, pointer, this._localPoint);
            localPoint.copyFrom(this._localPoint);
            if (displayObject.hitArea && displayObject.hitArea.contains) {
                if (displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y)) {
                    return true;
                }
                return false;
            } else if (displayObject instanceof Phaser.TileSprite) {
                var width = displayObject.width;
                var height = displayObject.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x > x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y > y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            } else if (displayObject instanceof PIXI.Sprite) {
                var width = displayObject.texture.frame.width;
                var height = displayObject.texture.frame.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x > x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y > y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            }
            for (var i = 0, len = displayObject.children.length; i < len; i++) {
                if (this.hitTest(displayObject.children[i], pointer, localPoint)) {
                    return true;
                }
            }
            return false;
        }
    };
    Phaser.Input.prototype.constructor = Phaser.Input;
    Object.defineProperty(Phaser.Input.prototype, "x", {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "y", {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalInactivePointers", {
        get: function() {
            return 10 - this.currentPointers;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalActivePointers", {
        get: function() {
            this.currentPointers = 0;
            for (var i = 1; i <= 10; i++) {
                if (this["pointer" + i] && this["pointer" + i].active) {
                    this.currentPointers++;
                }
            }
            return this.currentPointers;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y;
        }
    });
    Phaser.Key = function(game, keycode) {
        this.game = game;
        this.enabled = true;
        this.event = null;
        this.isDown = false;
        this.isUp = true;
        this.altKey = false;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = -2500;
        this.repeats = 0;
        this.keyCode = keycode;
        this.onDown = new Phaser.Signal();
        this.onHoldCallback = null;
        this.onHoldContext = null;
        this.onUp = new Phaser.Signal();
    };
    Phaser.Key.prototype = {
        update: function() {
            if (!this.enabled) {
                return;
            }
            if (this.isDown) {
                this.duration = this.game.time.now - this.timeDown;
                this.repeats++;
                if (this.onHoldCallback) {
                    this.onHoldCallback.call(this.onHoldContext, this);
                }
            }
        },
        processKeyDown: function(event) {
            if (!this.enabled) {
                return;
            }
            this.event = event;
            if (this.isDown) {
                return;
            }
            this.altKey = event.altKey;
            this.ctrlKey = event.ctrlKey;
            this.shiftKey = event.shiftKey;
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
            this.onDown.dispatch(this);
        },
        processKeyUp: function(event) {
            if (!this.enabled) {
                return;
            }
            this.event = event;
            if (this.isUp) {
                return;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = this.game.time.now - this.timeDown;
            this.onUp.dispatch(this);
        },
        reset: function(hard) {
            if (typeof hard === "undefined") {
                hard = true;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = 0;
            this.enabled = true;
            if (hard) {
                this.onDown.removeAll();
                this.onUp.removeAll();
                this.onHoldCallback = null;
                this.onHoldContext = null;
            }
        },
        justPressed: function(duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            return this.isDown && this.duration < duration;
        },
        justReleased: function(duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            return !this.isDown && this.game.time.now - this.timeUp < duration;
        }
    };
    Phaser.Key.prototype.constructor = Phaser.Key;
    Phaser.Keyboard = function(game) {
        this.game = game;
        this.disabled = false;
        this.event = null;
        this.pressEvent = null;
        this.callbackContext = this;
        this.onDownCallback = null;
        this.onPressCallback = null;
        this.onUpCallback = null;
        this._keys = [];
        this._capture = [];
        this._onKeyDown = null;
        this._onKeyPress = null;
        this._onKeyUp = null;
        this._i = 0;
        this._k = 0;
    };
    Phaser.Keyboard.prototype = {
        addCallbacks: function(context, onDown, onUp, onPress) {
            this.callbackContext = context;
            if (typeof onDown !== "undefined") {
                this.onDownCallback = onDown;
            }
            if (typeof onUp !== "undefined") {
                this.onUpCallback = onUp;
            }
            if (typeof onPress !== "undefined") {
                this.onPressCallback = onPress;
            }
        },
        addKey: function(keycode) {
            if (!this._keys[keycode]) {
                this._keys[keycode] = new Phaser.Key(this.game, keycode);
                this.addKeyCapture(keycode);
            }
            return this._keys[keycode];
        },
        removeKey: function(keycode) {
            if (this._keys[keycode]) {
                this._keys[keycode] = null;
                this.removeKeyCapture(keycode);
            }
        },
        createCursorKeys: function() {
            return {
                up: this.addKey(Phaser.Keyboard.UP),
                down: this.addKey(Phaser.Keyboard.DOWN),
                left: this.addKey(Phaser.Keyboard.LEFT),
                right: this.addKey(Phaser.Keyboard.RIGHT)
            };
        },
        start: function() {
            if (this.game.device.cocoonJS) {
                return;
            }
            if (this._onKeyDown !== null) {
                return;
            }
            var _this = this;
            this._onKeyDown = function(event) {
                return _this.processKeyDown(event);
            };
            this._onKeyUp = function(event) {
                return _this.processKeyUp(event);
            };
            this._onKeyPress = function(event) {
                return _this.processKeyPress(event);
            };
            window.addEventListener("keydown", this._onKeyDown, false);
            window.addEventListener("keyup", this._onKeyUp, false);
            window.addEventListener("keypress", this._onKeyPress, false);
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown);
            window.removeEventListener("keyup", this._onKeyUp);
            window.removeEventListener("keypress", this._onKeyPress);
            this._onKeyDown = null;
            this._onKeyUp = null;
            this._onKeyPress = null;
        },
        destroy: function() {
            this.stop();
            this.clearCaptures();
            this._keys.length = 0;
            this._i = 0;
        },
        addKeyCapture: function(keycode) {
            if (typeof keycode === "object") {
                for (var key in keycode) {
                    this._capture[keycode[key]] = true;
                }
            } else {
                this._capture[keycode] = true;
            }
        },
        removeKeyCapture: function(keycode) {
            delete this._capture[keycode];
        },
        clearCaptures: function() {
            this._capture = {};
        },
        update: function() {
            this._i = this._keys.length;
            while (this._i--) {
                if (this._keys[this._i]) {
                    this._keys[this._i].update();
                }
            }
        },
        processKeyDown: function(event) {
            this.event = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyDown(event);
            this._k = event.keyCode;
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, event);
            }
        },
        processKeyPress: function(event) {
            this.pressEvent = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.onPressCallback) {
                this.onPressCallback.call(this.callbackContext, String.fromCharCode(event.charCode), event);
            }
        },
        processKeyUp: function(event) {
            this.event = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyUp(event);
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, event);
            }
        },
        reset: function(hard) {
            if (typeof hard === "undefined") {
                hard = true;
            }
            this.event = null;
            var i = this._keys.length;
            while (i--) {
                if (this._keys[i]) {
                    this._keys[i].reset(hard);
                }
            }
        },
        justPressed: function(keycode, duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            if (this._keys[keycode]) {
                return this._keys[keycode].justPressed(duration);
            } else {
                return false;
            }
        },
        justReleased: function(keycode, duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            if (this._keys[keycode]) {
                return this._keys[keycode].justReleased(duration);
            } else {
                return false;
            }
        },
        isDown: function(keycode) {
            if (this._keys[keycode]) {
                return this._keys[keycode].isDown;
            }
            return false;
        }
    };
    Object.defineProperty(Phaser.Keyboard.prototype, "lastChar", {
        get: function() {
            if (this.event.charCode === 32) {
                return "";
            } else {
                return String.fromCharCode(this.pressEvent.charCode);
            }
        }
    });
    Object.defineProperty(Phaser.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k];
        }
    });
    Phaser.Keyboard.prototype.constructor = Phaser.Keyboard;
    Phaser.Keyboard.A = "A".charCodeAt(0);
    Phaser.Keyboard.B = "B".charCodeAt(0);
    Phaser.Keyboard.C = "C".charCodeAt(0);
    Phaser.Keyboard.D = "D".charCodeAt(0);
    Phaser.Keyboard.E = "E".charCodeAt(0);
    Phaser.Keyboard.F = "F".charCodeAt(0);
    Phaser.Keyboard.G = "G".charCodeAt(0);
    Phaser.Keyboard.H = "H".charCodeAt(0);
    Phaser.Keyboard.I = "I".charCodeAt(0);
    Phaser.Keyboard.J = "J".charCodeAt(0);
    Phaser.Keyboard.K = "K".charCodeAt(0);
    Phaser.Keyboard.L = "L".charCodeAt(0);
    Phaser.Keyboard.M = "M".charCodeAt(0);
    Phaser.Keyboard.N = "N".charCodeAt(0);
    Phaser.Keyboard.O = "O".charCodeAt(0);
    Phaser.Keyboard.P = "P".charCodeAt(0);
    Phaser.Keyboard.Q = "Q".charCodeAt(0);
    Phaser.Keyboard.R = "R".charCodeAt(0);
    Phaser.Keyboard.S = "S".charCodeAt(0);
    Phaser.Keyboard.T = "T".charCodeAt(0);
    Phaser.Keyboard.U = "U".charCodeAt(0);
    Phaser.Keyboard.V = "V".charCodeAt(0);
    Phaser.Keyboard.W = "W".charCodeAt(0);
    Phaser.Keyboard.X = "X".charCodeAt(0);
    Phaser.Keyboard.Y = "Y".charCodeAt(0);
    Phaser.Keyboard.Z = "Z".charCodeAt(0);
    Phaser.Keyboard.ZERO = "0".charCodeAt(0);
    Phaser.Keyboard.ONE = "1".charCodeAt(0);
    Phaser.Keyboard.TWO = "2".charCodeAt(0);
    Phaser.Keyboard.THREE = "3".charCodeAt(0);
    Phaser.Keyboard.FOUR = "4".charCodeAt(0);
    Phaser.Keyboard.FIVE = "5".charCodeAt(0);
    Phaser.Keyboard.SIX = "6".charCodeAt(0);
    Phaser.Keyboard.SEVEN = "7".charCodeAt(0);
    Phaser.Keyboard.EIGHT = "8".charCodeAt(0);
    Phaser.Keyboard.NINE = "9".charCodeAt(0);
    Phaser.Keyboard.NUMPAD_0 = 96;
    Phaser.Keyboard.NUMPAD_1 = 97;
    Phaser.Keyboard.NUMPAD_2 = 98;
    Phaser.Keyboard.NUMPAD_3 = 99;
    Phaser.Keyboard.NUMPAD_4 = 100;
    Phaser.Keyboard.NUMPAD_5 = 101;
    Phaser.Keyboard.NUMPAD_6 = 102;
    Phaser.Keyboard.NUMPAD_7 = 103;
    Phaser.Keyboard.NUMPAD_8 = 104;
    Phaser.Keyboard.NUMPAD_9 = 105;
    Phaser.Keyboard.NUMPAD_MULTIPLY = 106;
    Phaser.Keyboard.NUMPAD_ADD = 107;
    Phaser.Keyboard.NUMPAD_ENTER = 108;
    Phaser.Keyboard.NUMPAD_SUBTRACT = 109;
    Phaser.Keyboard.NUMPAD_DECIMAL = 110;
    Phaser.Keyboard.NUMPAD_DIVIDE = 111;
    Phaser.Keyboard.F1 = 112;
    Phaser.Keyboard.F2 = 113;
    Phaser.Keyboard.F3 = 114;
    Phaser.Keyboard.F4 = 115;
    Phaser.Keyboard.F5 = 116;
    Phaser.Keyboard.F6 = 117;
    Phaser.Keyboard.F7 = 118;
    Phaser.Keyboard.F8 = 119;
    Phaser.Keyboard.F9 = 120;
    Phaser.Keyboard.F10 = 121;
    Phaser.Keyboard.F11 = 122;
    Phaser.Keyboard.F12 = 123;
    Phaser.Keyboard.F13 = 124;
    Phaser.Keyboard.F14 = 125;
    Phaser.Keyboard.F15 = 126;
    Phaser.Keyboard.COLON = 186;
    Phaser.Keyboard.EQUALS = 187;
    Phaser.Keyboard.UNDERSCORE = 189;
    Phaser.Keyboard.QUESTION_MARK = 191;
    Phaser.Keyboard.TILDE = 192;
    Phaser.Keyboard.OPEN_BRACKET = 219;
    Phaser.Keyboard.BACKWARD_SLASH = 220;
    Phaser.Keyboard.CLOSED_BRACKET = 221;
    Phaser.Keyboard.QUOTES = 222;
    Phaser.Keyboard.BACKSPACE = 8;
    Phaser.Keyboard.TAB = 9;
    Phaser.Keyboard.CLEAR = 12;
    Phaser.Keyboard.ENTER = 13;
    Phaser.Keyboard.SHIFT = 16;
    Phaser.Keyboard.CONTROL = 17;
    Phaser.Keyboard.ALT = 18;
    Phaser.Keyboard.CAPS_LOCK = 20;
    Phaser.Keyboard.ESC = 27;
    Phaser.Keyboard.SPACEBAR = 32;
    Phaser.Keyboard.PAGE_UP = 33;
    Phaser.Keyboard.PAGE_DOWN = 34;
    Phaser.Keyboard.END = 35;
    Phaser.Keyboard.HOME = 36;
    Phaser.Keyboard.LEFT = 37;
    Phaser.Keyboard.UP = 38;
    Phaser.Keyboard.RIGHT = 39;
    Phaser.Keyboard.DOWN = 40;
    Phaser.Keyboard.INSERT = 45;
    Phaser.Keyboard.DELETE = 46;
    Phaser.Keyboard.HELP = 47;
    Phaser.Keyboard.NUM_LOCK = 144;
    Phaser.Mouse = function(game) {
        this.game = game;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseMoveCallback = null;
        this.mouseUpCallback = null;
        this.mouseOutCallback = null;
        this.mouseOverCallback = null;
        this.mouseWheelCallback = null;
        this.capture = false;
        this.button = -1;
        this.wheelDelta = 0;
        this.disabled = false;
        this.locked = false;
        this.stopOnGameOut = false;
        this.pointerLock = new Phaser.Signal();
        this.event = null;
        this._onMouseDown = null;
        this._onMouseMove = null;
        this._onMouseUp = null;
        this._onMouseOut = null;
        this._onMouseOver = null;
        this._onMouseWheel = null;
    };
    Phaser.Mouse.NO_BUTTON = -1;
    Phaser.Mouse.LEFT_BUTTON = 0;
    Phaser.Mouse.MIDDLE_BUTTON = 1;
    Phaser.Mouse.RIGHT_BUTTON = 2;
    Phaser.Mouse.WHEEL_UP = 1;
    Phaser.Mouse.WHEEL_DOWN = -1;
    Phaser.Mouse.prototype = {
        start: function() {
            if (this.game.device.android && this.game.device.chrome === false) {
                return;
            }
            if (this._onMouseDown !== null) {
                return;
            }
            var _this = this;
            this._onMouseDown = function(event) {
                return _this.onMouseDown(event);
            };
            this._onMouseMove = function(event) {
                return _this.onMouseMove(event);
            };
            this._onMouseUp = function(event) {
                return _this.onMouseUp(event);
            };
            this._onMouseUpGlobal = function(event) {
                return _this.onMouseUpGlobal(event);
            };
            this._onMouseOut = function(event) {
                return _this.onMouseOut(event);
            };
            this._onMouseOver = function(event) {
                return _this.onMouseOver(event);
            };
            this._onMouseWheel = function(event) {
                return _this.onMouseWheel(event);
            };
            this.game.canvas.addEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.addEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.addEventListener("mouseup", this._onMouseUp, true);
            if (!this.game.device.cocoonJS) {
                window.addEventListener("mouseup", this._onMouseUpGlobal, true);
                this.game.canvas.addEventListener("mouseover", this._onMouseOver, true);
                this.game.canvas.addEventListener("mouseout", this._onMouseOut, true);
                this.game.canvas.addEventListener("mousewheel", this._onMouseWheel, true);
                this.game.canvas.addEventListener("DOMMouseScroll", this._onMouseWheel, true);
            }
        },
        onMouseDown: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.button = event.button;
            if (this.mouseDownCallback) {
                this.mouseDownCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.start(event);
        },
        onMouseMove: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.mouseMoveCallback) {
                this.mouseMoveCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.move(event);
        },
        onMouseUp: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.button = Phaser.Mouse.NO_BUTTON;
            if (this.mouseUpCallback) {
                this.mouseUpCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.stop(event);
        },
        onMouseUpGlobal: function(event) {
            if (!this.game.input.mousePointer.withinGame) {
                this.button = Phaser.Mouse.NO_BUTTON;
                if (this.mouseUpCallback) {
                    this.mouseUpCallback.call(this.callbackContext, event);
                }
                event["identifier"] = 0;
                this.game.input.mousePointer.stop(event);
            }
        },
        onMouseOut: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.game.input.mousePointer.withinGame = false;
            if (this.mouseOutCallback) {
                this.mouseOutCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.stopOnGameOut) {
                event["identifier"] = 0;
                this.game.input.mousePointer.stop(event);
            }
        },
        onMouseWheel: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            if (this.mouseWheelCallback) {
                this.mouseWheelCallback.call(this.callbackContext, event);
            }
        },
        onMouseOver: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.game.input.mousePointer.withinGame = true;
            if (this.mouseOverCallback) {
                this.mouseOverCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var element = this.game.canvas;
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
                var _this = this;
                this._pointerLockChange = function(event) {
                    return _this.pointerLockChange(event);
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true);
            }
        },
        pointerLockChange: function(event) {
            var element = this.game.canvas;
            if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                this.locked = true;
                this.pointerLock.dispatch(true, event);
            } else {
                this.locked = false;
                this.pointerLock.dispatch(false, event);
            }
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        },
        stop: function() {
            this.game.canvas.removeEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.removeEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.removeEventListener("mouseup", this._onMouseUp, true);
            this.game.canvas.removeEventListener("mouseover", this._onMouseOver, true);
            this.game.canvas.removeEventListener("mouseout", this._onMouseOut, true);
            this.game.canvas.removeEventListener("mousewheel", this._onMouseWheel, true);
            this.game.canvas.removeEventListener("DOMMouseScroll", this._onMouseWheel, true);
            window.removeEventListener("mouseup", this._onMouseUpGlobal, true);
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        }
    };
    Phaser.Mouse.prototype.constructor = Phaser.Mouse;
    Phaser.MSPointer = function(game) {
        this.game = game;
        this.callbackContext = this.game;
        this.disabled = false;
        this._onMSPointerDown = null;
        this._onMSPointerMove = null;
        this._onMSPointerUp = null;
    };
    Phaser.MSPointer.prototype = {
        start: function() {
            if (this._onMSPointerDown !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.mspointer) {
                this._onMSPointerDown = function(event) {
                    return _this.onPointerDown(event);
                };
                this._onMSPointerMove = function(event) {
                    return _this.onPointerMove(event);
                };
                this._onMSPointerUp = function(event) {
                    return _this.onPointerUp(event);
                };
                this.game.canvas.addEventListener("MSPointerDown", this._onMSPointerDown, false);
                this.game.canvas.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                this.game.canvas.addEventListener("MSPointerUp", this._onMSPointerUp, false);
                this.game.canvas.addEventListener("pointerDown", this._onMSPointerDown, false);
                this.game.canvas.addEventListener("pointerMove", this._onMSPointerMove, false);
                this.game.canvas.addEventListener("pointerUp", this._onMSPointerUp, false);
                this.game.canvas.style["-ms-content-zooming"] = "none";
                this.game.canvas.style["-ms-touch-action"] = "none";
            }
        },
        onPointerDown: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.startPointer(event);
        },
        onPointerMove: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.updatePointer(event);
        },
        onPointerUp: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.stopPointer(event);
        },
        stop: function() {
            this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
            this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp);
        }
    };
    Phaser.MSPointer.prototype.constructor = Phaser.MSPointer;
    Phaser.Pointer = function(game, id) {
        this.game = game;
        this.id = id;
        this.type = Phaser.POINTER;
        this.exists = true;
        this.identifier = 0;
        this.pointerId = null;
        this.target = null;
        this.button = null;
        this._holdSent = false;
        this._history = [];
        this._nextDrop = 0;
        this._stateReset = false;
        this.withinGame = false;
        this.clientX = -1;
        this.clientY = -1;
        this.pageX = -1;
        this.pageY = -1;
        this.screenX = -1;
        this.screenY = -1;
        this.rawMovementX = 0;
        this.rawMovementY = 0;
        this.movementX = 0;
        this.movementY = 0;
        this.x = -1;
        this.y = -1;
        this.isMouse = false;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.timeUp = 0;
        this.previousTapTime = 0;
        this.totalTouches = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = false;
        this.dirty = false;
        this.position = new Phaser.Point();
        this.positionDown = new Phaser.Point();
        this.positionUp = new Phaser.Point();
        this.circle = new Phaser.Circle(0, 0, 44);
        if (id === 0) {
            this.isMouse = true;
        }
    };
    Phaser.Pointer.prototype = {
        start: function(event) {
            if (event["pointerId"]) {
                this.pointerId = event.pointerId;
            }
            this.identifier = event.identifier;
            this.target = event.target;
            if (typeof event.button !== "undefined") {
                this.button = event.button;
            }
            this._history = [];
            this.active = true;
            this.withinGame = true;
            this.isDown = true;
            this.isUp = false;
            this.dirty = false;
            this.msSinceLastClick = this.game.time.now - this.timeDown;
            this.timeDown = this.game.time.now;
            this._holdSent = false;
            this.move(event, true);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.x, this.y);
                this.game.input.onDown.dispatch(this, event);
                this.game.input.resetSpeed(this.x, this.y);
            }
            this._stateReset = false;
            this.totalTouches++;
            if (!this.isMouse) {
                this.game.input.currentPointers++;
            }
            if (this.targetObject !== null) {
                this.targetObject._touchedHandler(this);
            }
            return this;
        },
        update: function() {
            if (this.active) {
                if (this.dirty) {
                    if (this.game.input.interactiveItems.total > 0) {
                        this.processInteractiveObjects(true);
                    }
                    this.dirty = false;
                }
                if (this._holdSent === false && this.duration >= this.game.input.holdRate) {
                    if (this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                        this.game.input.onHold.dispatch(this);
                    }
                    this._holdSent = true;
                }
                if (this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop) {
                    this._nextDrop = this.game.time.now + this.game.input.recordRate;
                    this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    });
                    if (this._history.length > this.game.input.recordLimit) {
                        this._history.shift();
                    }
                }
            }
        },
        move: function(event, fromClick) {
            if (this.game.input.pollLocked) {
                return;
            }
            if (typeof fromClick === "undefined") {
                fromClick = false;
            }
            if (typeof event.button !== "undefined") {
                this.button = event.button;
            }
            this.clientX = event.clientX;
            this.clientY = event.clientY;
            this.pageX = event.pageX;
            this.pageY = event.pageY;
            this.screenX = event.screenX;
            this.screenY = event.screenY;
            if (this.isMouse && this.game.input.mouse.locked && !fromClick) {
                this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                this.movementX += this.rawMovementX;
                this.movementY += this.rawMovementY;
            }
            this.x = (this.pageX - this.game.scale.offset.x) * this.game.input.scale.x;
            this.y = (this.pageY - this.game.scale.offset.y) * this.game.input.scale.y;
            this.position.setTo(this.x, this.y);
            this.circle.x = this.x;
            this.circle.y = this.y;
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.activePointer = this;
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.game.input.x, this.game.input.y);
                this.game.input.circle.x = this.game.input.x;
                this.game.input.circle.y = this.game.input.y;
            }
            this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
            if (this.game.paused) {
                return this;
            }
            var i = this.game.input.moveCallbacks.length;
            while (i--) {
                this.game.input.moveCallbacks[i].callback.call(this.game.input.moveCallbacks[i].context, this, this.x, this.y, fromClick);
            }
            if (this.targetObject !== null && this.targetObject.isDragged === true) {
                if (this.targetObject.update(this) === false) {
                    this.targetObject = null;
                }
            } else if (this.game.input.interactiveItems.total > 0) {
                this.processInteractiveObjects(fromClick);
            }
            return this;
        },
        processInteractiveObjects: function(fromClick) {
            this.game.input.interactiveItems.setAll("checked", false);
            this._highestRenderOrderID = Number.MAX_SAFE_INTEGER;
            this._highestRenderObject = null;
            this._highestInputPriorityID = -1;
            var currentNode = this.game.input.interactiveItems.first;
            do {
                if (currentNode && currentNode.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, false)) {
                    currentNode.checked = true;
                    if (fromClick && currentNode.checkPointerDown(this, true) || !fromClick && currentNode.checkPointerOver(this, true)) {
                        this._highestRenderOrderID = currentNode.sprite._cache[3];
                        this._highestInputPriorityID = currentNode.priorityID;
                        this._highestRenderObject = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            } while (currentNode !== null);
            var currentNode = this.game.input.interactiveItems.first;
            do {
                if (currentNode && !currentNode.checked && currentNode.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, true)) {
                    if (fromClick && currentNode.checkPointerDown(this, false) || !fromClick && currentNode.checkPointerOver(this, false)) {
                        this._highestRenderOrderID = currentNode.sprite._cache[3];
                        this._highestInputPriorityID = currentNode.priorityID;
                        this._highestRenderObject = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            } while (currentNode !== null);
            if (this._highestRenderObject === null) {
                if (this.targetObject) {
                    this.targetObject._pointerOutHandler(this);
                    this.targetObject = null;
                }
            } else {
                if (this.targetObject === null) {
                    this.targetObject = this._highestRenderObject;
                    this._highestRenderObject._pointerOverHandler(this);
                } else {
                    if (this.targetObject === this._highestRenderObject) {
                        if (this._highestRenderObject.update(this) === false) {
                            this.targetObject = null;
                        }
                    } else {
                        this.targetObject._pointerOutHandler(this);
                        this.targetObject = this._highestRenderObject;
                        this.targetObject._pointerOverHandler(this);
                    }
                }
            }
            return this.targetObject !== null;
        },
        leave: function(event) {
            this.withinGame = false;
            this.move(event, false);
        },
        stop: function(event) {
            if (this._stateReset) {
                event.preventDefault();
                return;
            }
            this.timeUp = this.game.time.now;
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.onUp.dispatch(this, event);
                if (this.duration >= 0 && this.duration <= this.game.input.tapRate) {
                    if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate) {
                        this.game.input.onTap.dispatch(this, true);
                    } else {
                        this.game.input.onTap.dispatch(this, false);
                    }
                    this.previousTapTime = this.timeUp;
                }
            }
            if (this.id > 0) {
                this.active = false;
            }
            this.withinGame = false;
            this.isDown = false;
            this.isUp = true;
            this.pointerId = null;
            this.identifier = null;
            this.positionUp.setTo(this.x, this.y);
            if (this.isMouse === false) {
                this.game.input.currentPointers--;
            }
            this.game.input.interactiveItems.callAll("_releasedHandler", this);
            this.targetObject = null;
            return this;
        },
        justPressed: function(duration) {
            duration = duration || this.game.input.justPressedRate;
            return this.isDown === true && this.timeDown + duration > this.game.time.now;
        },
        justReleased: function(duration) {
            duration = duration || this.game.input.justReleasedRate;
            return this.isUp === true && this.timeUp + duration > this.game.time.now;
        },
        reset: function() {
            if (this.isMouse === false) {
                this.active = false;
            }
            this.pointerId = null;
            this.identifier = null;
            this.dirty = false;
            this.isDown = false;
            this.isUp = true;
            this.totalTouches = 0;
            this._holdSent = false;
            this._history.length = 0;
            this._stateReset = true;
            if (this.targetObject) {
                this.targetObject._releasedHandler(this);
            }
            this.targetObject = null;
        },
        resetMovement: function() {
            this.movementX = 0;
            this.movementY = 0;
        }
    };
    Phaser.Pointer.prototype.constructor = Phaser.Pointer;
    Object.defineProperty(Phaser.Pointer.prototype, "duration", {
        get: function() {
            if (this.isUp) {
                return -1;
            }
            return this.game.time.now - this.timeDown;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y;
        }
    });
    Phaser.Touch = function(game) {
        this.game = game;
        this.disabled = false;
        this.callbackContext = this.game;
        this.touchStartCallback = null;
        this.touchMoveCallback = null;
        this.touchEndCallback = null;
        this.touchEnterCallback = null;
        this.touchLeaveCallback = null;
        this.touchCancelCallback = null;
        this.preventDefault = true;
        this.event = null;
        this._onTouchStart = null;
        this._onTouchMove = null;
        this._onTouchEnd = null;
        this._onTouchEnter = null;
        this._onTouchLeave = null;
        this._onTouchCancel = null;
        this._onTouchMove = null;
    };
    Phaser.Touch.prototype = {
        start: function() {
            if (this._onTouchStart !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.touch) {
                this._onTouchStart = function(event) {
                    return _this.onTouchStart(event);
                };
                this._onTouchMove = function(event) {
                    return _this.onTouchMove(event);
                };
                this._onTouchEnd = function(event) {
                    return _this.onTouchEnd(event);
                };
                this._onTouchEnter = function(event) {
                    return _this.onTouchEnter(event);
                };
                this._onTouchLeave = function(event) {
                    return _this.onTouchLeave(event);
                };
                this._onTouchCancel = function(event) {
                    return _this.onTouchCancel(event);
                };
                this.game.canvas.addEventListener("touchstart", this._onTouchStart, false);
                this.game.canvas.addEventListener("touchmove", this._onTouchMove, false);
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, false);
                this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false);
                if (!this.game.device.cocoonJS) {
                    this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
                    this.game.canvas.addEventListener("touchleave", this._onTouchLeave, false);
                }
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(event) {
                event.preventDefault();
            };
            document.addEventListener("touchmove", this._documentTouchMove, false);
        },
        onTouchStart: function(event) {
            this.event = event;
            if (this.touchStartCallback) {
                this.touchStartCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.startPointer(event.changedTouches[i]);
            }
        },
        onTouchCancel: function(event) {
            this.event = event;
            if (this.touchCancelCallback) {
                this.touchCancelCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        onTouchEnter: function(event) {
            this.event = event;
            if (this.touchEnterCallback) {
                this.touchEnterCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchLeave: function(event) {
            this.event = event;
            if (this.touchLeaveCallback) {
                this.touchLeaveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchMove: function(event) {
            this.event = event;
            if (this.touchMoveCallback) {
                this.touchMoveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.updatePointer(event.changedTouches[i]);
            }
        },
        onTouchEnd: function(event) {
            this.event = event;
            if (this.touchEndCallback) {
                this.touchEndCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        stop: function() {
            if (this.game.device.touch) {
                this.game.canvas.removeEventListener("touchstart", this._onTouchStart);
                this.game.canvas.removeEventListener("touchmove", this._onTouchMove);
                this.game.canvas.removeEventListener("touchend", this._onTouchEnd);
                this.game.canvas.removeEventListener("touchenter", this._onTouchEnter);
                this.game.canvas.removeEventListener("touchleave", this._onTouchLeave);
                this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel);
            }
        }
    };
    Phaser.Touch.prototype.constructor = Phaser.Touch;
    Phaser.Gamepad = function(game) {
        this.game = game;
        this._gamepadIndexMap = {};
        this._rawPads = [];
        this._active = false;
        this.disabled = false;
        this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") != -1 || !!navigator.getGamepads;
        this._prevRawGamepadTypes = [];
        this._prevTimestamps = [];
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this._ongamepadconnected = null;
        this._gamepaddisconnected = null;
        this._gamepads = [ new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this) ];
    };
    Phaser.Gamepad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
            }
        },
        start: function() {
            if (this._active) {
                return;
            }
            this._active = true;
            var _this = this;
            this._onGamepadConnected = function(event) {
                return _this.onGamepadConnected(event);
            };
            this._onGamepadDisconnected = function(event) {
                return _this.onGamepadDisconnected(event);
            };
            window.addEventListener("gamepadconnected", this._onGamepadConnected, false);
            window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, false);
        },
        onGamepadConnected: function(event) {
            var newPad = event.gamepad;
            this._rawPads.push(newPad);
            this._gamepads[newPad.index].connect(newPad);
        },
        onGamepadDisconnected: function(event) {
            var removedPad = event.gamepad;
            for (var i in this._rawPads) {
                if (this._rawPads[i].index === removedPad.index) {
                    this._rawPads.splice(i, 1);
                }
            }
            this._gamepads[removedPad.index].disconnect();
        },
        update: function() {
            this._pollGamepads();
            this.pad1.pollStatus();
            this.pad2.pollStatus();
            this.pad3.pollStatus();
            this.pad4.pollStatus();
        },
        _pollGamepads: function() {
            if (navigator["getGamepads"]) {
                var rawGamepads = navigator.getGamepads();
            } else if (navigator["webkitGetGamepads"]) {
                var rawGamepads = navigator.webkitGetGamepads();
            } else if (navigator["webkitGamepads"]) {
                var rawGamepads = navigator.webkitGamepads();
            }
            if (rawGamepads) {
                this._rawPads = [];
                var gamepadsChanged = false;
                for (var i = 0; i < rawGamepads.length; i++) {
                    if (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i]) {
                        gamepadsChanged = true;
                        this._prevRawGamepadTypes[i] = typeof rawGamepads[i];
                    }
                    if (rawGamepads[i]) {
                        this._rawPads.push(rawGamepads[i]);
                    }
                    if (i === 3) {
                        break;
                    }
                }
                if (gamepadsChanged) {
                    var validConnections = {
                        rawIndices: {},
                        padIndices: {}
                    };
                    var singlePad;
                    for (var j = 0; j < this._gamepads.length; j++) {
                        singlePad = this._gamepads[j];
                        if (singlePad.connected) {
                            for (var k = 0; k < this._rawPads.length; k++) {
                                if (this._rawPads[k].index === singlePad.index) {
                                    validConnections.rawIndices[singlePad.index] = true;
                                    validConnections.padIndices[j] = true;
                                }
                            }
                        }
                    }
                    for (var l = 0; l < this._gamepads.length; l++) {
                        singlePad = this._gamepads[l];
                        if (validConnections.padIndices[l]) {
                            continue;
                        }
                        if (this._rawPads.length < 1) {
                            singlePad.disconnect();
                        }
                        for (var m = 0; m < this._rawPads.length; m++) {
                            if (validConnections.padIndices[l]) {
                                break;
                            }
                            var rawPad = this._rawPads[m];
                            if (rawPad) {
                                if (validConnections.rawIndices[rawPad.index]) {
                                    singlePad.disconnect();
                                    continue;
                                } else {
                                    singlePad.connect(rawPad);
                                    validConnections.rawIndices[rawPad.index] = true;
                                    validConnections.padIndices[l] = true;
                                }
                            } else {
                                singlePad.disconnect();
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(value) {
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].deadZone = value;
            }
        },
        stop: function() {
            this._active = false;
            window.removeEventListener("gamepadconnected", this._onGamepadConnected);
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function() {
            this.update();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].reset();
            }
        },
        justPressed: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justPressed(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justReleased(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        isDown: function(buttonCode) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].isDown(buttonCode) === true) {
                    return true;
                }
            }
            return false;
        },
        destroy: function() {
            this.stop();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].destroy();
            }
        }
    };
    Phaser.Gamepad.prototype.constructor = Phaser.Gamepad;
    Object.defineProperty(Phaser.Gamepad.prototype, "active", {
        get: function() {
            return this._active;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3];
        }
    });
    Phaser.Gamepad.BUTTON_0 = 0;
    Phaser.Gamepad.BUTTON_1 = 1;
    Phaser.Gamepad.BUTTON_2 = 2;
    Phaser.Gamepad.BUTTON_3 = 3;
    Phaser.Gamepad.BUTTON_4 = 4;
    Phaser.Gamepad.BUTTON_5 = 5;
    Phaser.Gamepad.BUTTON_6 = 6;
    Phaser.Gamepad.BUTTON_7 = 7;
    Phaser.Gamepad.BUTTON_8 = 8;
    Phaser.Gamepad.BUTTON_9 = 9;
    Phaser.Gamepad.BUTTON_10 = 10;
    Phaser.Gamepad.BUTTON_11 = 11;
    Phaser.Gamepad.BUTTON_12 = 12;
    Phaser.Gamepad.BUTTON_13 = 13;
    Phaser.Gamepad.BUTTON_14 = 14;
    Phaser.Gamepad.BUTTON_15 = 15;
    Phaser.Gamepad.AXIS_0 = 0;
    Phaser.Gamepad.AXIS_1 = 1;
    Phaser.Gamepad.AXIS_2 = 2;
    Phaser.Gamepad.AXIS_3 = 3;
    Phaser.Gamepad.AXIS_4 = 4;
    Phaser.Gamepad.AXIS_5 = 5;
    Phaser.Gamepad.AXIS_6 = 6;
    Phaser.Gamepad.AXIS_7 = 7;
    Phaser.Gamepad.AXIS_8 = 8;
    Phaser.Gamepad.AXIS_9 = 9;
    Phaser.Gamepad.XBOX360_A = 0;
    Phaser.Gamepad.XBOX360_B = 1;
    Phaser.Gamepad.XBOX360_X = 2;
    Phaser.Gamepad.XBOX360_Y = 3;
    Phaser.Gamepad.XBOX360_LEFT_BUMPER = 4;
    Phaser.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    Phaser.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    Phaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    Phaser.Gamepad.XBOX360_BACK = 8;
    Phaser.Gamepad.XBOX360_START = 9;
    Phaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.XBOX360_DPAD_LEFT = 14;
    Phaser.Gamepad.XBOX360_DPAD_RIGHT = 15;
    Phaser.Gamepad.XBOX360_DPAD_UP = 12;
    Phaser.Gamepad.XBOX360_DPAD_DOWN = 13;
    Phaser.Gamepad.XBOX360_STICK_LEFT_X = 0;
    Phaser.Gamepad.XBOX360_STICK_LEFT_Y = 1;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    Phaser.Gamepad.PS3XC_X = 0;
    Phaser.Gamepad.PS3XC_CIRCLE = 1;
    Phaser.Gamepad.PS3XC_SQUARE = 2;
    Phaser.Gamepad.PS3XC_TRIANGLE = 3;
    Phaser.Gamepad.PS3XC_L1 = 4;
    Phaser.Gamepad.PS3XC_R1 = 5;
    Phaser.Gamepad.PS3XC_L2 = 6;
    Phaser.Gamepad.PS3XC_R2 = 7;
    Phaser.Gamepad.PS3XC_SELECT = 8;
    Phaser.Gamepad.PS3XC_START = 9;
    Phaser.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.PS3XC_DPAD_UP = 12;
    Phaser.Gamepad.PS3XC_DPAD_DOWN = 13;
    Phaser.Gamepad.PS3XC_DPAD_LEFT = 14;
    Phaser.Gamepad.PS3XC_DPAD_RIGHT = 15;
    Phaser.Gamepad.PS3XC_STICK_LEFT_X = 0;
    Phaser.Gamepad.PS3XC_STICK_LEFT_Y = 1;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_X = 2;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_Y = 3;
    Phaser.SinglePad = function(game, padParent) {
        this.game = game;
        this.index = null;
        this.connected = false;
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this.deadZone = .26;
        this._padParent = padParent;
        this._rawPad = null;
        this._prevTimestamp = null;
        this._buttons = [];
        this._buttonsLen = 0;
        this._axes = [];
        this._axesLen = 0;
    };
    Phaser.SinglePad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
            }
        },
        getButton: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode];
            } else {
                return null;
            }
        },
        pollStatus: function() {
            if (!this.connected || this.game.input.disabled || this.game.input.gamepad.disabled || this._rawPad.timestamp && this._rawPad.timestamp === this._prevTimestamp) {
                return;
            }
            for (var i = 0; i < this._buttonsLen; i++) {
                var rawButtonVal = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i];
                if (rawButtonVal !== this._buttons[i].value) {
                    if (rawButtonVal === 1) {
                        this.processButtonDown(i, rawButtonVal);
                    } else if (rawButtonVal === 0) {
                        this.processButtonUp(i, rawButtonVal);
                    } else {
                        this.processButtonFloat(i, rawButtonVal);
                    }
                }
            }
            for (var index = 0; index < this._axesLen; index++) {
                var value = this._rawPad.axes[index];
                if (value > 0 && value > this.deadZone || value < 0 && value < -this.deadZone) {
                    this.processAxisChange(index, value);
                } else {
                    this.processAxisChange(index, 0);
                }
            }
            this._prevTimestamp = this._rawPad.timestamp;
        },
        connect: function(rawPad) {
            var triggerCallback = !this.connected;
            this.connected = true;
            this.index = rawPad.index;
            this._rawPad = rawPad;
            this._buttons = [];
            this._buttonsLen = rawPad.buttons.length;
            this._axes = [];
            this._axesLen = rawPad.axes.length;
            for (var a = 0; a < this._axesLen; a++) {
                this._axes[a] = rawPad.axes[a];
            }
            for (var buttonCode in rawPad.buttons) {
                buttonCode = parseInt(buttonCode, 10);
                this._buttons[buttonCode] = new Phaser.GamepadButton(this, buttonCode);
            }
            if (triggerCallback && this._padParent.onConnectCallback) {
                this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index);
            }
            if (triggerCallback && this.onConnectCallback) {
                this.onConnectCallback.call(this.callbackContext);
            }
        },
        disconnect: function() {
            var triggerCallback = this.connected;
            var disconnectingIndex = this.index;
            this.connected = false;
            this.index = null;
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            if (triggerCallback && this._padParent.onDisconnectCallback) {
                this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex);
            }
            if (triggerCallback && this.onDisconnectCallback) {
                this.onDisconnectCallback.call(this.callbackContext);
            }
        },
        destroy: function() {
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            this.onConnectCallback = null;
            this.onDisconnectCallback = null;
            this.onDownCallback = null;
            this.onUpCallback = null;
            this.onAxisCallback = null;
            this.onFloatCallback = null;
        },
        processAxisChange: function(index, value) {
            if (this._axes[index] === value) {
                return;
            }
            this._axes[index] = value;
            if (this._padParent.onAxisCallback) {
                this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, index, value);
            }
            if (this.onAxisCallback) {
                this.onAxisCallback.call(this.callbackContext, this, index, value);
            }
        },
        processButtonDown: function(buttonCode, value) {
            if (this._padParent.onDownCallback) {
                this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonDown(value);
            }
        },
        processButtonUp: function(buttonCode, value) {
            if (this._padParent.onUpCallback) {
                this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonUp(value);
            }
        },
        processButtonFloat: function(buttonCode, value) {
            if (this._padParent.onFloatCallback) {
                this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onFloatCallback) {
                this.onFloatCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonFloat(value);
            }
        },
        axis: function(axisCode) {
            if (this._axes[axisCode]) {
                return this._axes[axisCode];
            }
            return false;
        },
        isDown: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isDown;
            }
            return false;
        },
        isUp: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isUp;
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justReleased(duration);
            }
        },
        justPressed: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justPressed(duration);
            }
        },
        buttonValue: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].value;
            }
            return null;
        },
        reset: function() {
            for (var j = 0; j < this._axes.length; j++) {
                this._axes[j] = 0;
            }
        }
    };
    Phaser.SinglePad.prototype.constructor = Phaser.SinglePad;
    Phaser.GamepadButton = function(pad, buttonCode) {
        this.pad = pad;
        this.game = pad.game;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = 0;
        this.repeats = 0;
        this.value = 0;
        this.buttonCode = buttonCode;
        this.onDown = new Phaser.Signal();
        this.onUp = new Phaser.Signal();
        this.onFloat = new Phaser.Signal();
    };
    Phaser.GamepadButton.prototype = {
        processButtonDown: function(value) {
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
            this.value = value;
            this.onDown.dispatch(this, value);
        },
        processButtonUp: function(value) {
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.value = value;
            this.onUp.dispatch(this, value);
        },
        processButtonFloat: function(value) {
            this.value = value;
            this.onFloat.dispatch(this, value);
        },
        justPressed: function(duration) {
            duration = duration || 250;
            return this.isDown === true && this.timeDown + duration > this.game.time.now;
        },
        justReleased: function(duration) {
            duration = duration || 250;
            return this.isUp === true && this.timeUp + duration > this.game.time.now;
        },
        reset: function() {
            this.isDown = false;
            this.isUp = true;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
        },
        destroy: function() {
            this.onDown.dispose();
            this.onUp.dispose();
            this.onFloat.dispose();
            this.pad = null;
            this.game = null;
        }
    };
    Phaser.GamepadButton.prototype.constructor = Phaser.GamepadButton;
    Phaser.InputHandler = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.enabled = false;
        this.checked = false;
        this.priorityID = 0;
        this.useHandCursor = false;
        this._setHandCursor = false;
        this.isDragged = false;
        this.allowHorizontalDrag = true;
        this.allowVerticalDrag = true;
        this.bringToTop = false;
        this.snapOffset = null;
        this.snapOnDrag = false;
        this.snapOnRelease = false;
        this.snapX = 0;
        this.snapY = 0;
        this.snapOffsetX = 0;
        this.snapOffsetY = 0;
        this.pixelPerfectOver = false;
        this.pixelPerfectClick = false;
        this.pixelPerfectAlpha = 255;
        this.draggable = false;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.consumePointerEvent = false;
        this._dragPhase = false;
        this._wasEnabled = false;
        this._tempPoint = new Phaser.Point();
        this._pointerData = [];
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
        });
    };
    Phaser.InputHandler.prototype = {
        start: function(priority, useHandCursor) {
            priority = priority || 0;
            if (typeof useHandCursor === "undefined") {
                useHandCursor = false;
            }
            if (this.enabled === false) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = useHandCursor;
                this.priorityID = priority;
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i] = {
                        id: i,
                        x: 0,
                        y: 0,
                        isDown: false,
                        isUp: false,
                        isOver: false,
                        isOut: false,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: false
                    };
                }
                this.snapOffset = new Phaser.Point();
                this.enabled = true;
                this._wasEnabled = true;
                if (this.sprite.events && this.sprite.events.onInputOver === null) {
                    this.sprite.events.onInputOver = new Phaser.Signal();
                    this.sprite.events.onInputOut = new Phaser.Signal();
                    this.sprite.events.onInputDown = new Phaser.Signal();
                    this.sprite.events.onInputUp = new Phaser.Signal();
                    this.sprite.events.onDragStart = new Phaser.Signal();
                    this.sprite.events.onDragStop = new Phaser.Signal();
                }
            }
            this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);
            this.flagged = false;
            return this.sprite;
        },
        addedToGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this._wasEnabled && !this.enabled) {
                this.start();
            }
        },
        removedFromGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this.enabled) {
                this._wasEnabled = true;
                this.stop();
            } else {
                this._wasEnabled = false;
            }
        },
        reset: function() {
            this.enabled = false;
            this.flagged = false;
            for (var i = 0; i < 10; i++) {
                this._pointerData[i] = {
                    id: i,
                    x: 0,
                    y: 0,
                    isDown: false,
                    isUp: false,
                    isOver: false,
                    isOut: false,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: false
                };
            }
        },
        stop: function() {
            if (this.enabled === false) {
                return;
            } else {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
            }
        },
        destroy: function() {
            if (this.sprite) {
                if (this._setHandCursor) {
                    this.game.canvas.style.cursor = "default";
                    this._setHandCursor = false;
                }
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
                this._pointerData.length = 0;
                this.boundsRect = null;
                this.boundsSprite = null;
                this.sprite = null;
            }
        },
        validForInput: function(highestID, highestRenderID, includePixelPerfect) {
            if (typeof includePixelPerfect === "undefined") {
                includePixelPerfect = true;
            }
            if (this.sprite.scale.x === 0 || this.sprite.scale.y === 0 || this.priorityID < this.game.input.minPriorityID) {
                return false;
            }
            if (!includePixelPerfect && (this.pixelPerfectClick || this.pixelPerfectOver)) {
                return false;
            }
            if (this.priorityID > highestID || this.priorityID === highestID && this.sprite._cache[3] < highestRenderID) {
                return true;
            }
            return false;
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].x;
        },
        pointerY: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].y;
        },
        pointerDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDown;
        },
        pointerUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isUp;
        },
        pointerTimeDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeDown;
        },
        pointerTimeUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeUp;
        },
        pointerOver: function(index) {
            if (this.enabled) {
                if (typeof index === "undefined") {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOver) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOver;
                }
            }
            return false;
        },
        pointerOut: function(index) {
            if (this.enabled) {
                if (typeof index === "undefined") {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOut) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOut;
                }
            }
            return false;
        },
        pointerTimeOver: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOver;
        },
        pointerTimeOut: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOut;
        },
        pointerDragged: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDragged;
        },
        checkPointerDown: function(pointer, fastTest) {
            if (!pointer.isDown || !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (typeof fastTest === "undefined") {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectClick) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPointerOver: function(pointer, fastTest) {
            if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (typeof fastTest === "undefined") {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectOver) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPixel: function(x, y, pointer) {
            if (this.sprite.texture.baseTexture.source) {
                if (x === null && y === null) {
                    this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);
                    var x = this._tempPoint.x;
                    var y = this._tempPoint.y;
                }
                if (this.sprite.anchor.x !== 0) {
                    x -= -this.sprite.texture.frame.width * this.sprite.anchor.x;
                }
                if (this.sprite.anchor.y !== 0) {
                    y -= -this.sprite.texture.frame.height * this.sprite.anchor.y;
                }
                x += this.sprite.texture.frame.x;
                y += this.sprite.texture.frame.y;
                if (this.sprite.texture.trim) {
                    x -= this.sprite.texture.trim.x;
                    y -= this.sprite.texture.trim.y;
                    if (x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom) {
                        this._dx = x;
                        this._dy = y;
                        return false;
                    }
                }
                this._dx = x;
                this._dy = y;
                this.game.input.hitContext.clearRect(0, 0, 1, 1);
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);
                var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (rgb.data[3] >= this.pixelPerfectAlpha) {
                    return true;
                }
            }
            return false;
        },
        update: function(pointer) {
            if (this.sprite === null || this.sprite.parent === undefined) {
                return;
            }
            if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) {
                this._pointerOutHandler(pointer);
                return false;
            }
            if (this.draggable && this._draggedPointerID == pointer.id) {
                return this.updateDrag(pointer);
            } else if (this._pointerData[pointer.id].isOver === true) {
                if (this.checkPointerOver(pointer)) {
                    this._pointerData[pointer.id].x = pointer.x - this.sprite.x;
                    this._pointerData[pointer.id].y = pointer.y - this.sprite.y;
                    return true;
                } else {
                    this._pointerOutHandler(pointer);
                    return false;
                }
            }
        },
        _pointerOverHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isOver === false || pointer.dirty) {
                this._pointerData[pointer.id].isOver = true;
                this._pointerData[pointer.id].isOut = false;
                this._pointerData[pointer.id].timeOver = this.game.time.now;
                this._pointerData[pointer.id].x = pointer.x - this.sprite.x;
                this._pointerData[pointer.id].y = pointer.y - this.sprite.y;
                if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false) {
                    this.game.canvas.style.cursor = "pointer";
                    this._setHandCursor = true;
                }
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputOver.dispatch(this.sprite, pointer);
                }
            }
        },
        _pointerOutHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            this._pointerData[pointer.id].isOver = false;
            this._pointerData[pointer.id].isOut = true;
            this._pointerData[pointer.id].timeOut = this.game.time.now;
            if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false) {
                this.game.canvas.style.cursor = "default";
                this._setHandCursor = false;
            }
            if (this.sprite && this.sprite.events) {
                this.sprite.events.onInputOut.dispatch(this.sprite, pointer);
            }
        },
        _touchedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isDown === false && this._pointerData[pointer.id].isOver === true) {
                if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer)) {
                    return;
                }
                this._pointerData[pointer.id].isDown = true;
                this._pointerData[pointer.id].isUp = false;
                this._pointerData[pointer.id].timeDown = this.game.time.now;
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputDown.dispatch(this.sprite, pointer);
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged === false) {
                    this.startDrag(pointer);
                }
                if (this.bringToTop) {
                    this.sprite.bringToTop();
                }
            }
            return this.consumePointerEvent;
        },
        _releasedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isDown && pointer.isUp) {
                this._pointerData[pointer.id].isDown = false;
                this._pointerData[pointer.id].isUp = true;
                this._pointerData[pointer.id].timeUp = this.game.time.now;
                this._pointerData[pointer.id].downDuration = this._pointerData[pointer.id].timeUp - this._pointerData[pointer.id].timeDown;
                if (this.checkPointerOver(pointer)) {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, pointer, true);
                    }
                } else {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, pointer, false);
                    }
                    if (this.useHandCursor) {
                        this.game.canvas.style.cursor = "default";
                        this._setHandCursor = false;
                    }
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged && this._draggedPointerID === pointer.id) {
                    this.stopDrag(pointer);
                }
            }
        },
        updateDrag: function(pointer) {
            if (pointer.isUp) {
                this.stopDrag(pointer);
                return false;
            }
            if (this.sprite.fixedToCamera) {
                if (this.allowHorizontalDrag) {
                    this.sprite.cameraOffset.x = pointer.x + this._dragPoint.x + this.dragOffset.x;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.cameraOffset.y = pointer.y + this._dragPoint.y + this.dragOffset.y;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            } else {
                if (this.allowHorizontalDrag) {
                    this.sprite.x = pointer.x + this._dragPoint.x + this.dragOffset.x;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.y = pointer.y + this._dragPoint.y + this.dragOffset.y;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            }
            return true;
        },
        justOver: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOver && this.overDuration(pointer) < delay;
        },
        justOut: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOut && this.game.time.now - this._pointerData[pointer].timeOut < delay;
        },
        justPressed: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isDown && this.downDuration(pointer) < delay;
        },
        justReleased: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isUp && this.game.time.now - this._pointerData[pointer].timeUp < delay;
        },
        overDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isOver) {
                return this.game.time.now - this._pointerData[pointer].timeOver;
            }
            return -1;
        },
        downDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isDown) {
                return this.game.time.now - this._pointerData[pointer].timeDown;
            }
            return -1;
        },
        enableDrag: function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
            if (typeof lockCenter == "undefined") {
                lockCenter = false;
            }
            if (typeof bringToTop == "undefined") {
                bringToTop = false;
            }
            if (typeof pixelPerfect == "undefined") {
                pixelPerfect = false;
            }
            if (typeof alphaThreshold == "undefined") {
                alphaThreshold = 255;
            }
            if (typeof boundsRect == "undefined") {
                boundsRect = null;
            }
            if (typeof boundsSprite == "undefined") {
                boundsSprite = null;
            }
            this._dragPoint = new Phaser.Point();
            this.draggable = true;
            this.bringToTop = bringToTop;
            this.dragOffset = new Phaser.Point();
            this.dragFromCenter = lockCenter;
            this.pixelPerfectClick = pixelPerfect;
            this.pixelPerfectAlpha = alphaThreshold;
            if (boundsRect) {
                this.boundsRect = boundsRect;
            }
            if (boundsSprite) {
                this.boundsSprite = boundsSprite;
            }
        },
        disableDrag: function() {
            if (this._pointerData) {
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i].isDragged = false;
                }
            }
            this.draggable = false;
            this.isDragged = false;
            this._draggedPointerID = -1;
        },
        startDrag: function(pointer) {
            this.isDragged = true;
            this._draggedPointerID = pointer.id;
            this._pointerData[pointer.id].isDragged = true;
            if (this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    this.sprite.centerOn(pointer.x, pointer.y);
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                } else {
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                }
            } else {
                if (this.dragFromCenter) {
                    var bounds = this.sprite.getBounds();
                    this.sprite.x = pointer.x + (this.sprite.x - bounds.centerX);
                    this.sprite.y = pointer.y + (this.sprite.y - bounds.centerY);
                    this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);
                } else {
                    this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);
                }
            }
            this.updateDrag(pointer);
            if (this.bringToTop) {
                this._dragPhase = true;
                this.sprite.bringToTop();
            }
            this.sprite.events.onDragStart.dispatch(this.sprite, pointer);
        },
        stopDrag: function(pointer) {
            this.isDragged = false;
            this._draggedPointerID = -1;
            this._pointerData[pointer.id].isDragged = false;
            this._dragPhase = false;
            if (this.snapOnRelease) {
                if (this.sprite.fixedToCamera) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                } else {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            }
            this.sprite.events.onDragStop.dispatch(this.sprite, pointer);
            if (this.checkPointerOver(pointer) === false) {
                this._pointerOutHandler(pointer);
            }
        },
        setDragLock: function(allowHorizontal, allowVertical) {
            if (typeof allowHorizontal == "undefined") {
                allowHorizontal = true;
            }
            if (typeof allowVertical == "undefined") {
                allowVertical = true;
            }
            this.allowHorizontalDrag = allowHorizontal;
            this.allowVerticalDrag = allowVertical;
        },
        enableSnap: function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
            if (typeof onDrag == "undefined") {
                onDrag = true;
            }
            if (typeof onRelease == "undefined") {
                onRelease = false;
            }
            if (typeof snapOffsetX == "undefined") {
                snapOffsetX = 0;
            }
            if (typeof snapOffsetY == "undefined") {
                snapOffsetY = 0;
            }
            this.snapX = snapX;
            this.snapY = snapY;
            this.snapOffsetX = snapOffsetX;
            this.snapOffsetY = snapOffsetY;
            this.snapOnDrag = onDrag;
            this.snapOnRelease = onRelease;
        },
        disableSnap: function() {
            this.snapOnDrag = false;
            this.snapOnRelease = false;
        },
        checkBoundsRect: function() {
            if (this.sprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsRect.left) {
                    this.sprite.cameraOffset.x = this.boundsRect.left;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsRect.top) {
                    this.sprite.cameraOffset.y = this.boundsRect.top;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;
                }
            } else {
                if (this.sprite.x < this.boundsRect.left) {
                    this.sprite.x = this.boundsRect.x;
                } else if (this.sprite.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.x = this.boundsRect.right - this.sprite.width;
                }
                if (this.sprite.y < this.boundsRect.top) {
                    this.sprite.y = this.boundsRect.top;
                } else if (this.sprite.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.y = this.boundsRect.bottom - this.sprite.height;
                }
            }
        },
        checkBoundsSprite: function() {
            if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x + this.boundsSprite.width - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height;
                }
            } else {
                if (this.sprite.x < this.boundsSprite.x) {
                    this.sprite.x = this.boundsSprite.x;
                } else if (this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width) {
                    this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width;
                }
                if (this.sprite.y < this.boundsSprite.y) {
                    this.sprite.y = this.boundsSprite.y;
                } else if (this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height) {
                    this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height;
                }
            }
        }
    };
    Phaser.InputHandler.prototype.constructor = Phaser.InputHandler;
    Phaser.Events = function(sprite) {
        this.parent = sprite;
        this.onAddedToGroup = new Phaser.Signal();
        this.onRemovedFromGroup = new Phaser.Signal();
        this.onDestroy = new Phaser.Signal();
        this.onKilled = new Phaser.Signal();
        this.onRevived = new Phaser.Signal();
        this.onOutOfBounds = new Phaser.Signal();
        this.onEnterBounds = new Phaser.Signal();
        this.onInputOver = null;
        this.onInputOut = null;
        this.onInputDown = null;
        this.onInputUp = null;
        this.onDragStart = null;
        this.onDragStop = null;
        this.onAnimationStart = null;
        this.onAnimationComplete = null;
        this.onAnimationLoop = null;
    };
    Phaser.Events.prototype = {
        destroy: function() {
            this.parent = null;
            this.onDestroy.dispose();
            this.onAddedToGroup.dispose();
            this.onRemovedFromGroup.dispose();
            this.onKilled.dispose();
            this.onRevived.dispose();
            this.onOutOfBounds.dispose();
            if (this.onInputOver) {
                this.onInputOver.dispose();
                this.onInputOut.dispose();
                this.onInputDown.dispose();
                this.onInputUp.dispose();
                this.onDragStart.dispose();
                this.onDragStop.dispose();
            }
            if (this.onAnimationStart) {
                this.onAnimationStart.dispose();
                this.onAnimationComplete.dispose();
                this.onAnimationLoop.dispose();
            }
        }
    };
    Phaser.Events.prototype.constructor = Phaser.Events;
    Phaser.GameObjectFactory = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectFactory.prototype = {
        existing: function(object) {
            return this.world.add(object);
        },
        image: function(x, y, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Image(this.game, x, y, key, frame));
        },
        sprite: function(x, y, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.create(x, y, key, frame);
        },
        tween: function(obj) {
            return this.game.tweens.create(obj);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);
        },
        physicsGroup: function(physicsBodyType, parent, name, addToStage) {
            return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (typeof parent === "undefined") {
                parent = null;
            }
            if (typeof name === "undefined") {
                name = "group";
            }
            if (typeof addToStage === "undefined") {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        tileSprite: function(x, y, width, height, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));
        },
        rope: function(x, y, key, frame, points, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Rope(this.game, x, y, key, frame, points));
        },
        text: function(x, y, text, style, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Text(this.game, x, y, text, style));
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));
        },
        graphics: function(x, y, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Graphics(this.game, x, y));
        },
        emitter: function(x, y, maxParticles) {
            return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        bitmapData: function(width, height, key, addToCache) {
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        },
        plugin: function(plugin) {
            return this.game.plugins.add(plugin);
        }
    };
    Phaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory;
    Phaser.GameObjectCreator = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectCreator.prototype = {
        image: function(x, y, key, frame) {
            return new Phaser.Image(this.game, x, y, key, frame);
        },
        sprite: function(x, y, key, frame) {
            return new Phaser.Sprite(this.game, x, y, key, frame);
        },
        tween: function(obj) {
            return new Phaser.Tween(obj, this.game);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, null, name, addToStage, enableBody, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (typeof name === "undefined") {
                name = "group";
            }
            if (typeof addToStage === "undefined") {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        tileSprite: function(x, y, width, height, key, frame) {
            return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);
        },
        rope: function(x, y, key, frame, points) {
            return new Phaser.Rope(this.game, x, y, key, frame, points);
        },
        text: function(x, y, text, style) {
            return new Phaser.Text(this.game, x, y, text, style);
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
            return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);
        },
        graphics: function(x, y) {
            return new Phaser.Graphics(this.game, x, y);
        },
        emitter: function(x, y, maxParticles) {
            return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size) {
            return new Phaser.BitmapText(this.game, x, y, font, text, size);
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        bitmapData: function(width, height, key, addToCache) {
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        }
    };
    Phaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator;
    Phaser.BitmapData = function(game, key, width, height) {
        if (typeof width === "undefined") {
            width = 256;
        }
        if (typeof height === "undefined") {
            height = 256;
        }
        this.game = game;
        this.key = key;
        this.width = width;
        this.height = height;
        this.canvas = Phaser.Canvas.create(width, height, "", true);
        this.context = this.canvas.getContext("2d");
        this.ctx = this.context;
        this.imageData = this.context.getImageData(0, 0, width, height);
        this.data = this.imageData.data;
        this.pixels = null;
        if (this.imageData.data.buffer) {
            this.buffer = this.imageData.data.buffer;
            this.pixels = new Uint32Array(this.buffer);
        } else {
            if (window["ArrayBuffer"]) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer);
            } else {
                this.pixels = this.imageData.data;
            }
        }
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "bitmapData", game.rnd.uuid());
        this.texture.frame = this.textureFrame;
        this.type = Phaser.BITMAPDATA;
        this.disableTextureUpload = false;
        this.dirty = false;
        this.cls = this.clear;
        this._image = null;
        this._pos = new Phaser.Point();
        this._size = new Phaser.Point();
        this._scale = new Phaser.Point();
        this._rotate = 0;
        this._alpha = {
            prev: 1,
            current: 1
        };
        this._anchor = new Phaser.Point();
        this._tempR = 0;
        this._tempG = 0;
        this._tempB = 0;
    };
    Phaser.BitmapData.prototype = {
        add: function(object) {
            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    if (object[i]["loadTexture"]) {
                        object[i].loadTexture(this);
                    }
                }
            } else {
                object.loadTexture(this);
            }
            return this;
        },
        load: function(source) {
            if (typeof source === "string") {
                source = this.game.cache.getImage(source);
            }
            if (source) {
                this.resize(source.width, source.height);
                this.cls();
            } else {
                return;
            }
            this.draw(source);
            this.update();
            return this;
        },
        clear: function() {
            this.context.clearRect(0, 0, this.width, this.height);
            this.dirty = true;
            return this;
        },
        fill: function(r, g, b, a) {
            if (typeof a === "undefined") {
                a = 1;
            }
            this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";
            this.context.fillRect(0, 0, this.width, this.height);
            this.dirty = true;
            return this;
        },
        resize: function(width, height) {
            if (width !== this.width || height !== this.height) {
                this.width = width;
                this.height = height;
                this.canvas.width = width;
                this.canvas.height = height;
                this.baseTexture.width = width;
                this.baseTexture.height = height;
                this.textureFrame.width = width;
                this.textureFrame.height = height;
                this.texture.width = width;
                this.texture.height = height;
                this.texture.crop.width = width;
                this.texture.crop.height = height;
                this.update();
                this.dirty = true;
            }
            return this;
        },
        update: function(x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            this.imageData = this.context.getImageData(x, y, width, height);
            this.data = this.imageData.data;
            if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
            } else {
                if (window["ArrayBuffer"]) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer);
                } else {
                    this.pixels = this.imageData.data;
                }
            }
            return this;
        },
        processPixelRGB: function(callback, callbackContext, x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = Phaser.Color.createColor();
            var result = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== false && result !== null && result !== undefined) {
                        this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false);
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        processPixel: function(callback, callbackContext, x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = 0;
            var result = 0;
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    pixel = this.getPixel32(tx, ty);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== pixel) {
                        this.pixels[ty * this.width + tx] = result;
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        replaceRGB: function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
            var sx = 0;
            var sy = 0;
            var w = this.width;
            var h = this.height;
            var source = Phaser.Color.packPixel(r1, g1, b1, a1);
            if (region !== undefined && region instanceof Phaser.Rectangle) {
                sx = region.x;
                sy = region.y;
                w = region.width;
                h = region.height;
            }
            for (var y = 0; y < h; y++) {
                for (var x = 0; x < w; x++) {
                    if (this.getPixel32(sx + x, sy + y) === source) {
                        this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false);
                    }
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setHSL: function(h, s, l, region) {
            if (typeof h === "undefined" || h === null) {
                h = false;
            }
            if (typeof s === "undefined" || s === null) {
                s = false;
            }
            if (typeof l === "undefined" || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (typeof region === "undefined") {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = h;
                    }
                    if (s) {
                        pixel.s = s;
                    }
                    if (l) {
                        pixel.l = l;
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        shiftHSL: function(h, s, l, region) {
            if (typeof h === "undefined" || h === null) {
                h = false;
            }
            if (typeof s === "undefined" || s === null) {
                s = false;
            }
            if (typeof l === "undefined" || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (typeof region === "undefined") {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = this.game.math.wrap(pixel.h + h, 0, 1);
                    }
                    if (s) {
                        pixel.s = this.game.math.limitValue(pixel.s + s, 0, 1);
                    }
                    if (l) {
                        pixel.l = this.game.math.limitValue(pixel.l + l, 0, 1);
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setPixel32: function(x, y, red, green, blue, alpha, immediate) {
            if (typeof immediate === "undefined") {
                immediate = true;
            }
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                if (Phaser.Device.LITTLE_ENDIAN) {
                    this.pixels[y * this.width + x] = alpha << 24 | blue << 16 | green << 8 | red;
                } else {
                    this.pixels[y * this.width + x] = red << 24 | green << 16 | blue << 8 | alpha;
                }
                if (immediate) {
                    this.context.putImageData(this.imageData, 0, 0);
                    this.dirty = true;
                }
            }
            return this;
        },
        setPixel: function(x, y, red, green, blue, immediate) {
            return this.setPixel32(x, y, red, green, blue, 255, immediate);
        },
        getPixel: function(x, y, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var index = ~~(x + y * this.width);
            index *= 4;
            out.r = this.data[index];
            out.g = this.data[++index];
            out.b = this.data[++index];
            out.a = this.data[++index];
            return out;
        },
        getPixel32: function(x, y) {
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                return this.pixels[y * this.width + x];
            }
        },
        getPixelRGB: function(x, y, out, hsl, hsv) {
            return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);
        },
        getPixels: function(rect) {
            return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);
        },
        addToWorld: function(x, y, anchorX, anchorY, scaleX, scaleY) {
            scaleX = scaleX || 1;
            scaleY = scaleY || 1;
            var image = this.game.add.image(x, y, this);
            image.anchor.set(anchorX, anchorY);
            image.scale.set(scaleX, scaleY);
            return image;
        },
        copy: function(source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) {
            if (typeof source === "undefined" || source === null) {
                source = this;
            }
            this._image = source;
            if (source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text) {
                this._pos.set(source.texture.crop.x, source.texture.crop.y);
                this._size.set(source.texture.crop.width, source.texture.crop.height);
                this._scale.set(source.scale.x, source.scale.y);
                this._anchor.set(source.anchor.x, source.anchor.y);
                this._rotate = source.rotation;
                this._alpha.current = source.alpha;
                this._image = source.texture.baseTexture.source;
                if (source.texture.trim) {
                    tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width;
                    ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height;
                }
            } else {
                this._pos.set(0);
                this._scale.set(1);
                this._anchor.set(0);
                this._rotate = 0;
                this._alpha.current = 1;
                if (source instanceof Phaser.BitmapData) {
                    this._image = source.canvas;
                } else if (typeof source === "string") {
                    source = this.game.cache.getImage(source);
                    if (source === null) {
                        return;
                    } else {
                        this._image = source;
                    }
                }
                this._size.set(this._image.width, this._image.height);
            }
            if (typeof x === "undefined" || x === null) {
                x = 0;
            }
            if (typeof y === "undefined" || y === null) {
                y = 0;
            }
            if (width) {
                this._size.x = width;
            }
            if (height) {
                this._size.y = height;
            }
            if (typeof tx === "undefined" || tx === null) {
                tx = x;
            }
            if (typeof ty === "undefined" || ty === null) {
                ty = y;
            }
            if (typeof newWidth === "undefined" || newWidth === null) {
                newWidth = this._size.x;
            }
            if (typeof newHeight === "undefined" || newHeight === null) {
                newHeight = this._size.y;
            }
            if (typeof rotate === "number") {
                this._rotate = rotate;
            }
            if (typeof anchorX === "number") {
                this._anchor.x = anchorX;
            }
            if (typeof anchorY === "number") {
                this._anchor.y = anchorY;
            }
            if (typeof scaleX === "number") {
                this._scale.x = scaleX;
            }
            if (typeof scaleY === "number") {
                this._scale.y = scaleY;
            }
            if (typeof alpha === "number") {
                this._alpha.current = alpha;
            }
            if (typeof blendMode === "undefined") {
                blendMode = null;
            }
            if (typeof roundPx === "undefined") {
                roundPx = false;
            }
            if (this._alpha.current <= 0 || this._scale.x === 0 || this._scale.y === 0 || this._size.x === 0 || this._size.y === 0) {
                return;
            }
            this._alpha.prev = this.context.globalAlpha;
            this.context.save();
            this.context.globalAlpha = this._alpha.current;
            if (blendMode) {
                this.context.globalCompositeOperation = blendMode;
            }
            if (roundPx) {
                tx |= 0;
                ty |= 0;
            }
            this.context.translate(tx, ty);
            this.context.scale(this._scale.x, this._scale.y);
            this.context.rotate(this._rotate);
            this.context.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight);
            this.context.restore();
            this.context.globalAlpha = this._alpha.prev;
            this.dirty = true;
            return this;
        },
        copyRect: function(source, area, x, y, alpha, blendMode, roundPx) {
            return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx);
        },
        draw: function(source, x, y, width, height, blendMode, roundPx) {
            return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx);
        },
        alphaMask: function(source, mask) {
            return this.draw(mask).blendSourceAtop().draw(source).blendReset();
        },
        extract: function(destination, r, g, b, a, resize, r2, g2, b2) {
            if (typeof a === "undefined") {
                a = 255;
            }
            if (typeof resize === "undefined") {
                resize = false;
            }
            if (typeof r2 === "undefined") {
                r2 = r;
            }
            if (typeof g2 === "undefined") {
                g2 = g;
            }
            if (typeof b2 === "undefined") {
                b2 = b;
            }
            if (resize) {
                destination.resize(this.width, this.height);
            }
            this.processPixelRGB(function(pixel, x, y) {
                if (pixel.r === r && pixel.g === g && pixel.b === b) {
                    destination.setPixel32(x, y, r2, g2, b2, a, false);
                }
                return false;
            }, this);
            destination.context.putImageData(destination.imageData, 0, 0);
            destination.dirty = true;
            return destination;
        },
        rect: function(x, y, width, height, fillStyle) {
            if (typeof fillStyle !== "undefined") {
                this.context.fillStyle = fillStyle;
            }
            this.context.fillRect(x, y, width, height);
            return this;
        },
        circle: function(x, y, radius, fillStyle) {
            if (typeof fillStyle !== "undefined") {
                this.context.fillStyle = fillStyle;
            }
            this.context.beginPath();
            this.context.arc(x, y, radius, 0, Math.PI * 2, false);
            this.context.closePath();
            this.context.fill();
            return this;
        },
        render: function() {
            if (!this.disableTextureUpload && this.game.renderType === Phaser.WEBGL && this.dirty) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
                this.dirty = false;
            }
            return this;
        },
        blendReset: function() {
            this.context.globalCompositeOperation = "source-over";
            return this;
        },
        blendSourceOver: function() {
            this.context.globalCompositeOperation = "source-over";
            return this;
        },
        blendSourceIn: function() {
            this.context.globalCompositeOperation = "source-in";
            return this;
        },
        blendSourceOut: function() {
            this.context.globalCompositeOperation = "source-out";
            return this;
        },
        blendSourceAtop: function() {
            this.context.globalCompositeOperation = "source-atop";
            return this;
        },
        blendDestinationOver: function() {
            this.context.globalCompositeOperation = "destination-over";
            return this;
        },
        blendDestinationIn: function() {
            this.context.globalCompositeOperation = "destination-in";
            return this;
        },
        blendDestinationOut: function() {
            this.context.globalCompositeOperation = "destination-out";
            return this;
        },
        blendDestinationAtop: function() {
            this.context.globalCompositeOperation = "destination-atop";
            return this;
        },
        blendXor: function() {
            this.context.globalCompositeOperation = "xor";
            return this;
        },
        blendAdd: function() {
            this.context.globalCompositeOperation = "lighter";
            return this;
        },
        blendMultiply: function() {
            this.context.globalCompositeOperation = "multiply";
            return this;
        },
        blendScreen: function() {
            this.context.globalCompositeOperation = "screen";
            return this;
        },
        blendOverlay: function() {
            this.context.globalCompositeOperation = "overlay";
            return this;
        },
        blendDarken: function() {
            this.context.globalCompositeOperation = "darken";
            return this;
        },
        blendLighten: function() {
            this.context.globalCompositeOperation = "lighten";
            return this;
        },
        blendColorDodge: function() {
            this.context.globalCompositeOperation = "color-dodge";
            return this;
        },
        blendColorBurn: function() {
            this.context.globalCompositeOperation = "color-burn";
            return this;
        },
        blendHardLight: function() {
            this.context.globalCompositeOperation = "hard-light";
            return this;
        },
        blendSoftLight: function() {
            this.context.globalCompositeOperation = "soft-light";
            return this;
        },
        blendDifference: function() {
            this.context.globalCompositeOperation = "difference";
            return this;
        },
        blendExclusion: function() {
            this.context.globalCompositeOperation = "exclusion";
            return this;
        },
        blendHue: function() {
            this.context.globalCompositeOperation = "hue";
            return this;
        },
        blendSaturation: function() {
            this.context.globalCompositeOperation = "saturation";
            return this;
        },
        blendColor: function() {
            this.context.globalCompositeOperation = "color";
            return this;
        },
        blendLuminosity: function() {
            this.context.globalCompositeOperation = "luminosity";
            return this;
        }
    };
    Object.defineProperty(Phaser.BitmapData.prototype, "smoothed", {
        get: function() {
            Phaser.Canvas.getSmoothingEnabled(this.context);
        },
        set: function(value) {
            Phaser.Canvas.setSmoothingEnabled(this.context, value);
        }
    });
    Phaser.BitmapData.getTransform = function(translateX, translateY, scaleX, scaleY, skewX, skewY) {
        if (typeof translateX !== "number") {
            translateX = 0;
        }
        if (typeof translateY !== "number") {
            translateY = 0;
        }
        if (typeof scaleX !== "number") {
            scaleX = 1;
        }
        if (typeof scaleY !== "number") {
            scaleY = 1;
        }
        if (typeof skewX !== "number") {
            skewX = 0;
        }
        if (typeof skewY !== "number") {
            skewY = 0;
        }
        return {
            sx: scaleX,
            sy: scaleY,
            scaleX: scaleX,
            scaleY: scaleY,
            skewX: skewX,
            skewY: skewY,
            translateX: translateX,
            translateY: translateY,
            tx: translateX,
            ty: translateY
        };
    };
    Phaser.BitmapData.prototype.constructor = Phaser.BitmapData;
    Phaser.Sprite = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.SPRITE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.position.set(x, y);
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.input = null;
        this.body = null;
        this.alive = true;
        this.health = 1;
        this.lifespan = 0;
        this.checkWorldBounds = false;
        this.outOfBoundsKill = false;
        this.debug = false;
        this.cameraOffset = new Phaser.Point();
        this.cropRect = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0 ];
        this._crop = null;
        this._frame = null;
        this._bounds = new Phaser.Rectangle();
        this.loadTexture(key, frame);
    };
    Phaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Sprite.prototype.constructor = Phaser.Sprite;
    Phaser.Sprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.lifespan > 0) {
            this.lifespan -= this.game.time.elapsed;
            if (this.lifespan <= 0) {
                this.kill();
                return false;
            }
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
                if (this.outOfBoundsKill) {
                    this.kill();
                    return false;
                }
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Sprite.prototype.update = function() {};
    Phaser.Sprite.prototype.postUpdate = function() {
        if (this.key instanceof Phaser.BitmapData) {
            this.key.render();
        }
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Sprite.prototype.loadTexture = function(key, frame, stopAnimation) {
        frame = frame || 0;
        if (stopAnimation || typeof stopAnimation === "undefined") {
            this.animations.stop();
        }
        this.key = key;
        var setFrame = true;
        var smoothed = this.smoothed;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
        if (setFrame) {
            this._frame = Phaser.Rectangle.clone(this.texture.frame);
        }
        if (!smoothed) {
            this.smoothed = false;
        }
    };
    Phaser.Sprite.prototype.setFrame = function(frame) {
        this._frame = frame;
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.cropRect) {
            this.updateCrop();
        } else {
            if (this.game.renderType === Phaser.WEBGL) {
                PIXI.WebGLRenderer.updateTextureFrame(this.texture);
            }
        }
    };
    Phaser.Sprite.prototype.resetFrame = function() {
        if (this._frame) {
            this.setFrame(this._frame);
        }
    };
    Phaser.Sprite.prototype.crop = function(rect, copy) {
        if (typeof copy === "undefined") {
            copy = false;
        }
        if (rect) {
            if (copy && this.cropRect !== null) {
                this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);
            } else if (copy && this.cropRect === null) {
                this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);
            } else {
                this.cropRect = rect;
            }
            this.updateCrop();
        } else {
            this._crop = null;
            this.cropRect = null;
            this.resetFrame();
        }
    };
    Phaser.Sprite.prototype.updateCrop = function() {
        if (!this.cropRect) {
            return;
        }
        this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);
        this._crop.x += this._frame.x;
        this._crop.y += this._frame.y;
        var cx = Math.max(this._frame.x, this._crop.x);
        var cy = Math.max(this._frame.y, this._crop.y);
        var cw = Math.min(this._frame.right, this._crop.right) - cx;
        var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
        this.texture.crop.x = cx;
        this.texture.crop.y = cy;
        this.texture.crop.width = cw;
        this.texture.crop.height = ch;
        this.texture.frame.width = Math.min(cw, this.cropRect.width);
        this.texture.frame.height = Math.min(ch, this.cropRect.height);
        this.texture.width = this.texture.frame.width;
        this.texture.height = this.texture.frame.height;
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Sprite.prototype.revive = function(health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.health = health;
        if (this.events) {
            this.events.onRevived.dispatch(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this._cache[8] === 1) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        if (this.input) {
            this.input.destroy();
        }
        if (this.animations) {
            this.animations.destroy();
        }
        if (this.body) {
            this.body.destroy();
        }
        if (this.events) {
            this.events.destroy();
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        if (this._crop) {
            this._crop = null;
        }
        if (this._frame) {
            this._frame = null;
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Sprite.prototype.damage = function(amount) {
        if (this.alive) {
            this.health -= amount;
            if (this.health <= 0) {
                this.kill();
            }
        }
        return this;
    };
    Phaser.Sprite.prototype.reset = function(x, y, health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = health;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Phaser.Sprite.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
        if (this.animations) {
            return this.animations.play(name, frameRate, loop, killOnComplete);
        }
    };
    Phaser.Sprite.prototype.overlap = function(displayObject) {
        return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());
    };
    Object.defineProperty(Phaser.Sprite.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            this.animations.frame = value;
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            this.animations.frameName = value;
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.removeFromWorld();
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode;
        },
        set: function(value) {
            if (value) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0;
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Image = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.IMAGE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.position.set(x, y);
        this.world = new Phaser.Point(x, y);
        this.alive = true;
        this.autoCull = false;
        this.input = null;
        this.debug = false;
        this.cameraOffset = new Phaser.Point();
        this.cropRect = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this._crop = null;
        this._frame = null;
        this._bounds = new Phaser.Rectangle();
        this.loadTexture(key, frame);
    };
    Phaser.Image.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Image.prototype.constructor = Phaser.Image;
    Phaser.Image.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull) {
            this._bounds.copyFrom(this.getBounds());
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Image.prototype.update = function() {};
    Phaser.Image.prototype.postUpdate = function() {
        if (this.key instanceof Phaser.BitmapData) {
            this.key.render();
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Image.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        var setFrame = true;
        var smoothed = this.smoothed;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
        if (setFrame) {
            this._frame = Phaser.Rectangle.clone(this.texture.frame);
        }
        if (!smoothed) {
            this.smoothed = false;
        }
    };
    Phaser.Image.prototype.setFrame = function(frame) {
        this._frame = frame;
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.cropRect) {
            this.updateCrop();
        } else {
            if (this.game.renderType === Phaser.WEBGL) {
                PIXI.WebGLRenderer.updateTextureFrame(this.texture);
            }
        }
    };
    Phaser.Image.prototype.resetFrame = function() {
        if (this._frame) {
            this.setFrame(this._frame);
        }
    };
    Phaser.Image.prototype.crop = function(rect, copy) {
        if (typeof copy === "undefined") {
            copy = false;
        }
        if (rect) {
            if (copy && this.cropRect !== null) {
                this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);
            } else if (copy && this.cropRect === null) {
                this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);
            } else {
                this.cropRect = rect;
            }
            this.updateCrop();
        } else {
            this._crop = null;
            this.cropRect = null;
            this.resetFrame();
        }
    };
    Phaser.Image.prototype.updateCrop = function() {
        if (!this.cropRect) {
            return;
        }
        this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);
        this._crop.x += this._frame.x;
        this._crop.y += this._frame.y;
        var cx = Math.max(this._frame.x, this._crop.x);
        var cy = Math.max(this._frame.y, this._crop.y);
        var cw = Math.min(this._frame.right, this._crop.right) - cx;
        var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
        this.texture.crop.x = cx;
        this.texture.crop.y = cy;
        this.texture.crop.width = cw;
        this.texture.crop.height = ch;
        this.texture.frame.width = Math.min(cw, this.cropRect.width);
        this.texture.frame.height = Math.min(ch, this.cropRect.height);
        this.texture.width = this.texture.frame.width;
        this.texture.height = this.texture.frame.height;
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Image.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
        this.visible = true;
        if (this.events) {
            this.events.onRevived.dispatch(this);
        }
        return this;
    };
    Phaser.Image.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this);
        }
        return this;
    };
    Phaser.Image.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        if (this.events) {
            this.events.destroy();
        }
        if (this.input) {
            this.input.destroy();
        }
        if (this.animations) {
            this.animations.destroy();
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Image.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        return this;
    };
    Phaser.Image.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this);
        }
        return this;
    };
    Object.defineProperty(Phaser.Image.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "frame", {
        get: function() {
            return this._frame;
        },
        set: function(value) {
            if (value !== this.frame) {
                var frameData = this.game.cache.getFrameData(this.key);
                if (frameData && value < frameData.total && frameData.getFrame(value)) {
                    this.setTexture(PIXI.TextureCache[frameData.getFrame(value).uuid]);
                    this._frame = value;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "frameName", {
        get: function() {
            return this._frameName;
        },
        set: function(value) {
            if (value !== this.frameName) {
                var frameData = this.game.cache.getFrameData(this.key);
                if (frameData && frameData.getFrameByName(value)) {
                    this.setTexture(PIXI.TextureCache[frameData.getFrameByName(value).uuid]);
                    this._frameName = value;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode;
        },
        set: function(value) {
            if (value) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0;
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.TileSprite = function(game, x, y, width, height, key, frame) {
        x = x || 0;
        y = y || 0;
        width = width || 256;
        height = height || 256;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.TILESPRITE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new Phaser.Point();
        PIXI.TilingSprite.call(this, PIXI.TextureCache["__default"], width, height);
        this.position.set(x, y);
        this.input = null;
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.checkWorldBounds = false;
        this.cameraOffset = new Phaser.Point();
        this.body = null;
        this.alive = true;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this.loadTexture(key, frame);
    };
    Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    Phaser.TileSprite.prototype.constructor = Phaser.TileSprite;
    Phaser.TileSprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.TileSprite.prototype.update = function() {};
    Phaser.TileSprite.prototype.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = this.game.camera.view.x + this.cameraOffset.x;
            this.position.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.TileSprite.prototype.autoScroll = function(x, y) {
        this._scroll.set(x, y);
    };
    Phaser.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    };
    Phaser.TileSprite.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
    };
    Phaser.TileSprite.prototype.setFrame = function(frame) {
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.TileSprite.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.filters) {
            this.filters = null;
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.animations.destroy();
        this.events.destroy();
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.alive = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.TileSprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
        return this.animations.play(name, frameRate, loop, killOnComplete);
    };
    Phaser.TileSprite.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Object.defineProperty(Phaser.TileSprite.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            if (value !== this.animations.frame) {
                this.animations.frame = value;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            if (value !== this.animations.frameName) {
                this.animations.frameName = value;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.safeRemove = true;
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Rope = function(game, x, y, key, frame, points) {
        this.points = [];
        this.points = points;
        this._hasUpdateAnimation = false;
        this._updateAnimationCallback = null;
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.ROPE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new Phaser.Point();
        PIXI.Rope.call(this, key, this.points);
        this.position.set(x, y);
        this.input = null;
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.checkWorldBounds = false;
        this.cameraOffset = new Phaser.Point();
        this.body = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this.loadTexture(key, frame);
    };
    Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype);
    Phaser.Rope.prototype.constructor = Phaser.Rope;
    Phaser.Rope.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Rope.prototype.update = function() {
        if (this._hasUpdateAnimation) {
            this.updateAnimation.call(this);
        }
    };
    Phaser.Rope.prototype.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = this.game.camera.view.x + this.cameraOffset.x;
            this.position.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Rope.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
    };
    Phaser.Rope.prototype.setFrame = function(frame) {
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Rope.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.filters) {
            this.filters = null;
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.animations.destroy();
        this.events.destroy();
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Rope.prototype.play = function(name, frameRate, loop, killOnComplete) {
        return this.animations.play(name, frameRate, loop, killOnComplete);
    };
    Phaser.Rope.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Object.defineProperty(Phaser.Rope.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            if (value !== this.animations.frame) {
                this.animations.frame = value;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            if (value !== this.animations.frameName) {
                this.animations.frameName = value;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.safeRemove = true;
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(value) {
            if (value && typeof value === "function") {
                this._hasUpdateAnimation = true;
                this._updateAnimation = value;
            } else {
                this._hasUpdateAnimation = false;
                this._updateAnimation = null;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "segments", {
        get: function() {
            var segments = [];
            var index, x1, y1, x2, y2, width, height, rect;
            for (var i = 0; i < this.points.length; i++) {
                index = i * 4;
                x1 = this.verticies[index];
                y1 = this.verticies[index + 1];
                x2 = this.verticies[index + 4];
                y2 = this.verticies[index + 3];
                width = Phaser.Math.difference(x1, x2);
                height = Phaser.Math.difference(y1, y2);
                x1 += this.world.x;
                y1 += this.world.y;
                rect = new Phaser.Rectangle(x1, y1, width, height);
                segments.push(rect);
            }
            return segments;
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Text = function(game, x, y, text, style) {
        x = x || 0;
        y = y || 0;
        text = text || " ";
        style = style || {};
        if (text.length === 0) {
            text = " ";
        } else {
            text = text.toString();
        }
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.TEXT;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this._text = text;
        this._font = "";
        this._fontSize = 32;
        this._fontWeight = "normal";
        this._lineSpacing = 0;
        this.events = new Phaser.Events(this);
        this.input = null;
        this.cameraOffset = new Phaser.Point();
        this.setStyle(style);
        PIXI.Text.call(this, text, this.style);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        if (text !== " ") {
            this.updateText();
        }
    };
    Phaser.Text.prototype = Object.create(PIXI.Text.prototype);
    Phaser.Text.prototype.constructor = Phaser.Text;
    Phaser.Text.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Text.prototype.update = function() {};
    Phaser.Text.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Text.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.texture.destroy(true);
        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        } else {
            this.canvas = null;
            this.context = null;
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Text.prototype.setShadow = function(x, y, color, blur) {
        this.style.shadowOffsetX = x || 0;
        this.style.shadowOffsetY = y || 0;
        this.style.shadowColor = color || "rgba(0,0,0,0)";
        this.style.shadowBlur = blur || 0;
        this.dirty = true;
    };
    Phaser.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        style.shadowOffsetX = style.shadowOffsetX || 0;
        style.shadowOffsetY = style.shadowOffsetY || 0;
        style.shadowColor = style.shadowColor || "rgba(0,0,0,0)";
        style.shadowBlur = style.shadowBlur || 0;
        this.style = style;
        this.dirty = true;
    };
    Phaser.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) {
            outputText = this.runWordWrap(this.text);
        }
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = [];
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width;
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        this.canvas.width = maxLineWidth + this.style.strokeThickness;
        var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;
        this.canvas.height = lineHeight * lines.length;
        if (navigator.isCocoonJS) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.shadowOffsetX = this.style.shadowOffsetX;
        this.context.shadowOffsetY = this.style.shadowOffsetY;
        this.context.shadowColor = this.style.shadowColor;
        this.context.shadowBlur = this.style.shadowBlur;
        this.context.textBaseline = "top";
        this.context.lineCap = "round";
        this.context.lineJoin = "round";
        for (i = 0; i < lines.length; i++) {
            var linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);
            if (this.style.align === "right") {
                linePosition.x += maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                linePosition.x += (maxLineWidth - lineWidths[i]) / 2;
            }
            linePosition.y += this._lineSpacing;
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(lines[i], linePosition.x, linePosition.y);
            }
            if (this.style.fill) {
                this.context.fillText(lines[i], linePosition.x, linePosition.y);
            }
        }
        this.updateTexture();
    };
    Phaser.Text.prototype.runWordWrap = function(text) {
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = this.style.wordWrapWidth;
            var words = lines[i].split(" ");
            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;
                var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                if (wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                        result += "\n";
                    }
                    result += words[j] + " ";
                    spaceLeft = this.style.wordWrapWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += words[j] + " ";
                }
            }
            if (i < lines.length - 1) {
                result += "\n";
            }
        }
        return result;
    };
    Object.defineProperty(Phaser.Text.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || " ";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(value) {
            if (value !== this._font) {
                this._font = value.trim();
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(value) {
            value = parseInt(value, 10);
            if (value !== this._fontSize) {
                this._fontSize = value;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontWeight;
        },
        set: function(value) {
            if (value !== this._fontWeight) {
                this._fontWeight = value;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fill", {
        get: function() {
            return this.style.fill;
        },
        set: function(value) {
            if (value !== this.style.fill) {
                this.style.fill = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "align", {
        get: function() {
            return this.style.align;
        },
        set: function(value) {
            if (value !== this.style.align) {
                this.style.align = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke;
        },
        set: function(value) {
            if (value !== this.style.stroke) {
                this.style.stroke = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness;
        },
        set: function(value) {
            if (value !== this.style.strokeThickness) {
                this.style.strokeThickness = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap;
        },
        set: function(value) {
            if (value !== this.style.wordWrap) {
                this.style.wordWrap = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth;
        },
        set: function(value) {
            if (value !== this.style.wordWrapWidth) {
                this.style.wordWrapWidth = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing;
        },
        set: function(value) {
            if (value !== this._lineSpacing) {
                this._lineSpacing = parseFloat(value);
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetX) {
                this.style.shadowOffsetX = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetY) {
                this.style.shadowOffsetY = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor;
        },
        set: function(value) {
            if (value !== this.style.shadowColor) {
                this.style.shadowColor = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur;
        },
        set: function(value) {
            if (value !== this.style.shadowBlur) {
                this.style.shadowBlur = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.BitmapText = function(game, x, y, font, text, size) {
        x = x || 0;
        y = y || 0;
        font = font || "";
        text = text || "";
        size = size || 32;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.BITMAPTEXT;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this._text = text;
        this._font = font;
        this._fontSize = size;
        this._align = "left";
        this._tint = 16777215;
        this.events = new Phaser.Events(this);
        this.input = null;
        this.cameraOffset = new Phaser.Point();
        PIXI.BitmapText.call(this, text);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
    };
    Phaser.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype);
    Phaser.BitmapText.prototype.constructor = Phaser.BitmapText;
    Phaser.BitmapText.prototype.setStyle = function() {
        this.style = {
            align: this._align
        };
        this.fontName = this._font;
        this.fontSize = this._fontSize;
        this.dirty = true;
    };
    Phaser.BitmapText.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        return true;
    };
    Phaser.BitmapText.prototype.update = function() {};
    Phaser.BitmapText.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.BitmapText.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                if (this.children[i].destroy) {
                    this.children[i].destroy(destroyChildren);
                } else {
                    this.removeChild(this.children[i]);
                }
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Object.defineProperty(Phaser.BitmapText.prototype, "align", {
        get: function() {
            return this._align;
        },
        set: function(value) {
            if (value !== this._align) {
                this._align = value;
                this.setStyle();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint;
        },
        set: function(value) {
            if (value !== this._tint) {
                this._tint = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(value) {
            if (value !== this._font) {
                this._font = value.trim();
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(value) {
            value = parseInt(value, 10);
            if (value !== this._fontSize) {
                this._fontSize = value;
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || " ";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Button = function(game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        callback = callback || null;
        callbackContext = callbackContext || this;
        Phaser.Image.call(this, game, x, y, key, outFrame);
        this.type = Phaser.BUTTON;
        this._onOverFrameName = null;
        this._onOutFrameName = null;
        this._onDownFrameName = null;
        this._onUpFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameID = null;
        this._onDownFrameID = null;
        this._onUpFrameID = null;
        this.onOverMouseOnly = false;
        this.onOverSound = null;
        this.onOutSound = null;
        this.onDownSound = null;
        this.onUpSound = null;
        this.onOverSoundMarker = "";
        this.onOutSoundMarker = "";
        this.onDownSoundMarker = "";
        this.onUpSoundMarker = "";
        this.onInputOver = new Phaser.Signal();
        this.onInputOut = new Phaser.Signal();
        this.onInputDown = new Phaser.Signal();
        this.onInputUp = new Phaser.Signal();
        this.freezeFrames = false;
        this.forceOut = false;
        this.inputEnabled = true;
        this.input.start(0, true);
        this.setFrames(overFrame, outFrame, downFrame, upFrame);
        if (callback !== null) {
            this.onInputUp.add(callback, callbackContext);
        }
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this);
    };
    Phaser.Button.prototype = Object.create(Phaser.Image.prototype);
    Phaser.Button.prototype.constructor = Phaser.Button;
    Phaser.Button.prototype.clearFrames = function() {
        this._onOverFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameName = null;
        this._onOutFrameID = null;
        this._onDownFrameName = null;
        this._onDownFrameID = null;
        this._onUpFrameName = null;
        this._onUpFrameID = null;
    };
    Phaser.Button.prototype.setFrames = function(overFrame, outFrame, downFrame, upFrame) {
        this.clearFrames();
        if (overFrame !== null) {
            if (typeof overFrame === "string") {
                this._onOverFrameName = overFrame;
                if (this.input.pointerOver()) {
                    this.frameName = overFrame;
                }
            } else {
                this._onOverFrameID = overFrame;
                if (this.input.pointerOver()) {
                    this.frame = overFrame;
                }
            }
        }
        if (outFrame !== null) {
            if (typeof outFrame === "string") {
                this._onOutFrameName = outFrame;
                if (this.input.pointerOver() === false) {
                    this.frameName = outFrame;
                }
            } else {
                this._onOutFrameID = outFrame;
                if (this.input.pointerOver() === false) {
                    this.frame = outFrame;
                }
            }
        }
        if (downFrame !== null) {
            if (typeof downFrame === "string") {
                this._onDownFrameName = downFrame;
                if (this.input.pointerDown()) {
                    this.frameName = downFrame;
                }
            } else {
                this._onDownFrameID = downFrame;
                if (this.input.pointerDown()) {
                    this.frame = downFrame;
                }
            }
        }
        if (upFrame !== null) {
            if (typeof upFrame === "string") {
                this._onUpFrameName = upFrame;
                if (this.input.pointerUp()) {
                    this.frameName = upFrame;
                }
            } else {
                this._onUpFrameID = upFrame;
                if (this.input.pointerUp()) {
                    this.frame = upFrame;
                }
            }
        }
    };
    Phaser.Button.prototype.setSounds = function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
        this.setOverSound(overSound, overMarker);
        this.setOutSound(outSound, outMarker);
        this.setDownSound(downSound, downMarker);
        this.setUpSound(upSound, upMarker);
    };
    Phaser.Button.prototype.setOverSound = function(sound, marker) {
        this.onOverSound = null;
        this.onOverSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onOverSound = sound;
        }
        if (typeof marker === "string") {
            this.onOverSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setOutSound = function(sound, marker) {
        this.onOutSound = null;
        this.onOutSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onOutSound = sound;
        }
        if (typeof marker === "string") {
            this.onOutSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setDownSound = function(sound, marker) {
        this.onDownSound = null;
        this.onDownSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onDownSound = sound;
        }
        if (typeof marker === "string") {
            this.onDownSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setUpSound = function(sound, marker) {
        this.onUpSound = null;
        this.onUpSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onUpSound = sound;
        }
        if (typeof marker === "string") {
            this.onUpSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.onInputOverHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(1);
        }
        if (this.onOverMouseOnly && !pointer.isMouse) {
            return;
        }
        if (this.onOverSound) {
            this.onOverSound.play(this.onOverSoundMarker);
        }
        if (this.onInputOver) {
            this.onInputOver.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputOutHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(2);
        }
        if (this.onOutSound) {
            this.onOutSound.play(this.onOutSoundMarker);
        }
        if (this.onInputOut) {
            this.onInputOut.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputDownHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(3);
        }
        if (this.onDownSound) {
            this.onDownSound.play(this.onDownSoundMarker);
        }
        if (this.onInputDown) {
            this.onInputDown.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputUpHandler = function(sprite, pointer, isOver) {
        if (this.onUpSound) {
            this.onUpSound.play(this.onUpSoundMarker);
        }
        if (this.onInputUp) {
            this.onInputUp.dispatch(this, pointer, isOver);
        }
        if (this.freezeFrames) {
            return;
        }
        if (this.forceOut) {
            this.setState(2);
        } else {
            if (this._onUpFrameName !== null || this._onUpFrameID !== null) {
                this.setState(4);
            } else {
                if (isOver) {
                    this.setState(1);
                } else {
                    this.setState(2);
                }
            }
        }
    };
    Phaser.Button.prototype.setState = function(newState) {
        if (newState === 1) {
            if (this._onOverFrameName != null) {
                this.frameName = this._onOverFrameName;
            } else if (this._onOverFrameID != null) {
                this.frame = this._onOverFrameID;
            }
        } else if (newState === 2) {
            if (this._onOutFrameName != null) {
                this.frameName = this._onOutFrameName;
            } else if (this._onOutFrameID != null) {
                this.frame = this._onOutFrameID;
            }
        } else if (newState === 3) {
            if (this._onDownFrameName != null) {
                this.frameName = this._onDownFrameName;
            } else if (this._onDownFrameID != null) {
                this.frame = this._onDownFrameID;
            }
        } else if (newState === 4) {
            if (this._onUpFrameName != null) {
                this.frameName = this._onUpFrameName;
            } else if (this._onUpFrameID != null) {
                this.frame = this._onUpFrameID;
            }
        }
    };
    Phaser.Graphics = function(game, x, y) {
        x = x || 0;
        y = y || 0;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.GRAPHICS;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this.cameraOffset = new Phaser.Point();
        PIXI.Graphics.call(this);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
    };
    Phaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    Phaser.Graphics.prototype.constructor = Phaser.Graphics;
    Phaser.Graphics.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        return true;
    };
    Phaser.Graphics.prototype.update = function() {};
    Phaser.Graphics.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.Graphics.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        this.clear();
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Graphics.prototype.drawPolygon = function(poly) {
        this.moveTo(poly.points[0].x, poly.points[0].y);
        for (var i = 1; i < poly.points.length; i += 1) {
            this.lineTo(poly.points[i].x, poly.points[i].y);
        }
        this.lineTo(poly.points[0].x, poly.points[0].y);
    };
    Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
        if (typeof cull === "undefined") {
            cull = false;
        }
        var triangle = new Phaser.Polygon(points);
        if (cull) {
            var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);
            var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);
            var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);
            var faceNormal = cb.cross(ab);
            if (cameraToFace.dot(faceNormal) > 0) {
                this.drawPolygon(triangle);
            }
        } else {
            this.drawPolygon(triangle);
        }
    };
    Phaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) {
        if (typeof cull === "undefined") {
            cull = false;
        }
        var point1 = new Phaser.Point();
        var point2 = new Phaser.Point();
        var point3 = new Phaser.Point();
        var points = [];
        var i;
        if (!indices) {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < vertices.length / 3; i++) {
                    this.drawTriangle([ vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2] ], cull);
                }
            } else {
                for (i = 0; i < vertices.length / 6; i++) {
                    point1.x = vertices[i * 6 + 0];
                    point1.y = vertices[i * 6 + 1];
                    point2.x = vertices[i * 6 + 2];
                    point2.y = vertices[i * 6 + 3];
                    point3.x = vertices[i * 6 + 4];
                    point3.y = vertices[i * 6 + 5];
                    this.drawTriangle([ point1, point2, point3 ], cull);
                }
            }
        } else {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < indices.length / 3; i++) {
                    points.push(vertices[indices[i * 3]]);
                    points.push(vertices[indices[i * 3 + 1]]);
                    points.push(vertices[indices[i * 3 + 2]]);
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            } else {
                for (i = 0; i < indices.length; i++) {
                    point1.x = vertices[indices[i] * 2];
                    point1.y = vertices[indices[i] * 2 + 1];
                    points.push(point1.copyTo({}));
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            }
        }
    };
    Object.defineProperty(Phaser.Graphics.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Graphics.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Graphics.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.RenderTexture = function(game, width, height, key, scaleMode) {
        if (typeof key === "undefined") {
            key = "";
        }
        if (typeof scaleMode === "undefined") {
            scaleMode = Phaser.scaleModes.DEFAULT;
        }
        this.game = game;
        this.key = key;
        this.type = Phaser.RENDERTEXTURE;
        this._temp = new Phaser.Point();
        PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode);
    };
    Phaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    Phaser.RenderTexture.prototype.constructor = Phaser.RenderTexture;
    Phaser.RenderTexture.prototype.renderXY = function(displayObject, x, y, clear) {
        this._temp.set(x, y);
        this.render(displayObject, this._temp, clear);
    };
    Phaser.SpriteBatch = function(game, parent, name, addToStage) {
        if (typeof parent === "undefined" || parent === null) {
            parent = game.world;
        }
        PIXI.SpriteBatch.call(this);
        Phaser.Group.call(this, game, parent, name, addToStage);
        this.type = Phaser.SPRITEBATCH;
    };
    Phaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, Phaser.Group.prototype, PIXI.SpriteBatch.prototype);
    Phaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;
    Phaser.RetroFont = function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
        if (!game.cache.checkImageKey(key)) {
            return false;
        }
        if (typeof charsPerRow === "undefined" || charsPerRow === null) {
            charsPerRow = game.cache.getImage(key).width / characterWidth;
        }
        this.characterWidth = characterWidth;
        this.characterHeight = characterHeight;
        this.characterSpacingX = xSpacing || 0;
        this.characterSpacingY = ySpacing || 0;
        this.characterPerRow = charsPerRow;
        this.offsetX = xOffset || 0;
        this.offsetY = yOffset || 0;
        this.align = "left";
        this.multiLine = false;
        this.autoUpperCase = true;
        this.customSpacingX = 0;
        this.customSpacingY = 0;
        this.fixedWidth = 0;
        this.fontSet = game.cache.getImage(key);
        this._text = "";
        this.grabData = [];
        this.frameData = new Phaser.FrameData();
        var currentX = this.offsetX;
        var currentY = this.offsetY;
        var r = 0;
        for (var c = 0; c < chars.length; c++) {
            var uuid = game.rnd.uuid();
            var frame = this.frameData.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight, "", uuid));
            this.grabData[chars.charCodeAt(c)] = frame.index;
            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                x: currentX,
                y: currentY,
                width: this.characterWidth,
                height: this.characterHeight
            });
            r++;
            if (r == this.characterPerRow) {
                r = 0;
                currentX = this.offsetX;
                currentY += this.characterHeight + this.characterSpacingY;
            } else {
                currentX += this.characterWidth + this.characterSpacingX;
            }
        }
        game.cache.updateFrameData(key, this.frameData);
        this.stamp = new Phaser.Image(game, 0, 0, key, 0);
        Phaser.RenderTexture.call(this, game, 100, 100, "", Phaser.scaleModes.NEAREST);
        this.type = Phaser.RETROFONT;
    };
    Phaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype);
    Phaser.RetroFont.prototype.constructor = Phaser.RetroFont;
    Phaser.RetroFont.ALIGN_LEFT = "left";
    Phaser.RetroFont.ALIGN_RIGHT = "right";
    Phaser.RetroFont.ALIGN_CENTER = "center";
    Phaser.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    Phaser.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    Phaser.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    Phaser.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    Phaser.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    Phaser.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    Phaser.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    Phaser.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    Phaser.RetroFont.prototype.setFixedWidth = function(width, lineAlignment) {
        if (typeof lineAlignment === "undefined") {
            lineAlignment = "left";
        }
        this.fixedWidth = width;
        this.align = lineAlignment;
    };
    Phaser.RetroFont.prototype.setText = function(content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
        this.multiLine = multiLine || false;
        this.customSpacingX = characterSpacing || 0;
        this.customSpacingY = lineSpacing || 0;
        this.align = lineAlignment || "left";
        if (allowLowerCase) {
            this.autoUpperCase = false;
        } else {
            this.autoUpperCase = true;
        }
        if (content.length > 0) {
            this.text = content;
        }
    };
    Phaser.RetroFont.prototype.buildRetroFontText = function() {
        var cx = 0;
        var cy = 0;
        this.clear();
        if (this.multiLine) {
            var lines = this._text.split("\n");
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            } else {
                this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            }
            for (var i = 0; i < lines.length; i++) {
                switch (this.align) {
                  case Phaser.RetroFont.ALIGN_LEFT:
                    cx = 0;
                    break;

                  case Phaser.RetroFont.ALIGN_RIGHT:
                    cx = this.width - lines[i].length * (this.characterWidth + this.customSpacingX);
                    break;

                  case Phaser.RetroFont.ALIGN_CENTER:
                    cx = this.width / 2 - lines[i].length * (this.characterWidth + this.customSpacingX) / 2;
                    cx += this.customSpacingX / 2;
                    break;
                }
                if (cx < 0) {
                    cx = 0;
                }
                this.pasteLine(lines[i], cx, cy, this.customSpacingX);
                cy += this.characterHeight + this.customSpacingY;
            }
        } else {
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, this.characterHeight, true);
            } else {
                this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true);
            }
            switch (this.align) {
              case Phaser.RetroFont.ALIGN_LEFT:
                cx = 0;
                break;

              case Phaser.RetroFont.ALIGN_RIGHT:
                cx = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                break;

              case Phaser.RetroFont.ALIGN_CENTER:
                cx = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
                cx += this.customSpacingX / 2;
                break;
            }
            this.textureBuffer.clear();
            this.pasteLine(this._text, cx, 0, this.customSpacingX);
        }
    };
    Phaser.RetroFont.prototype.pasteLine = function(line, x, y, customSpacingX) {
        var p = new Phaser.Point();
        for (var c = 0; c < line.length; c++) {
            if (line.charAt(c) == " ") {
                x += this.characterWidth + customSpacingX;
            } else {
                if (this.grabData[line.charCodeAt(c)] >= 0) {
                    this.stamp.frame = this.grabData[line.charCodeAt(c)];
                    p.set(x, y);
                    this.render(this.stamp, p, false);
                    x += this.characterWidth + customSpacingX;
                    if (x > this.width) {
                        break;
                    }
                }
            }
        }
    };
    Phaser.RetroFont.prototype.getLongestLine = function() {
        var longestLine = 0;
        if (this._text.length > 0) {
            var lines = this._text.split("\n");
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].length > longestLine) {
                    longestLine = lines[i].length;
                }
            }
        }
        return longestLine;
    };
    Phaser.RetroFont.prototype.removeUnsupportedCharacters = function(stripCR) {
        var newString = "";
        for (var c = 0; c < this._text.length; c++) {
            var aChar = this._text[c];
            var code = aChar.charCodeAt(0);
            if (this.grabData[code] >= 0 || !stripCR && aChar === "\n") {
                newString = newString.concat(aChar);
            }
        }
        return newString;
    };
    Phaser.RetroFont.prototype.updateOffset = function(x, y) {
        if (this.offsetX === x && this.offsetY === y) {
            return;
        }
        var diffX = x - this.offsetX;
        var diffY = y - this.offsetY;
        var frames = this.game.cache.getFrameData(this.stamp.key).getFrames();
        var i = frames.length;
        while (i--) {
            frames[i].x += diffX;
            frames[i].y += diffY;
            PIXI.TextureCache[frames[i].uuid].frame.x = frames[i].x;
            PIXI.TextureCache[frames[i].uuid].frame.y = frames[i].y;
        }
        this.buildRetroFontText();
    };
    Object.defineProperty(Phaser.RetroFont.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            var newText;
            if (this.autoUpperCase) {
                newText = value.toUpperCase();
            } else {
                newText = value;
            }
            if (newText !== this._text) {
                this._text = newText;
                this.removeUnsupportedCharacters(this.multiLine);
                this.buildRetroFontText();
            }
        }
    });
    Object.defineProperty(Phaser.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed;
        },
        set: function(value) {
            this.stamp.smoothed = value;
            this.buildRetroFontText();
        }
    });
    Phaser.Particle = function(game, x, y, key, frame) {
        Phaser.Sprite.call(this, game, x, y, key, frame);
        this.autoScale = false;
        this.scaleData = null;
        this._s = 0;
        this.autoAlpha = false;
        this.alphaData = null;
        this._a = 0;
    };
    Phaser.Particle.prototype = Object.create(Phaser.Sprite.prototype);
    Phaser.Particle.prototype.constructor = Phaser.Particle;
    Phaser.Particle.prototype.update = function() {
        if (this.autoScale) {
            this._s--;
            if (this._s) {
                this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
            } else {
                this.autoScale = false;
            }
        }
        if (this.autoAlpha) {
            this._a--;
            if (this._a) {
                this.alpha = this.alphaData[this._a].v;
            } else {
                this.autoAlpha = false;
            }
        }
    };
    Phaser.Particle.prototype.onEmit = function() {};
    Phaser.Particle.prototype.setAlphaData = function(data) {
        this.alphaData = data;
        this._a = data.length - 1;
        this.alpha = this.alphaData[this._a].v;
        this.autoAlpha = true;
    };
    Phaser.Particle.prototype.setScaleData = function(data) {
        this.scaleData = data;
        this._s = data.length - 1;
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        this.autoScale = true;
    };
    Phaser.Particle.prototype.reset = function(x, y, health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = health;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        this.alpha = 1;
        this.scale.set(1);
        this.autoScale = false;
        this.autoAlpha = false;
        return this;
    };
    Phaser.Canvas = {
        create: function(width, height, id) {
            width = width || 256;
            height = height || 256;
            var canvas = document.createElement("canvas");
            if (typeof id === "string" && id !== "") {
                canvas.id = id;
            }
            canvas.width = width;
            canvas.height = height;
            canvas.style.display = "block";
            return canvas;
        },
        getOffset: function(element, point) {
            point = point || new Phaser.Point();
            var box = element.getBoundingClientRect();
            var clientTop = element.clientTop || document.body.clientTop || 0;
            var clientLeft = element.clientLeft || document.body.clientLeft || 0;
            var scrollTop = 0;
            var scrollLeft = 0;
            if (document.compatMode === "CSS1Compat") {
                scrollTop = window.pageYOffset || document.documentElement.scrollTop || element.scrollTop || 0;
                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || element.scrollLeft || 0;
            } else {
                scrollTop = window.pageYOffset || document.body.scrollTop || element.scrollTop || 0;
                scrollLeft = window.pageXOffset || document.body.scrollLeft || element.scrollLeft || 0;
            }
            point.x = box.left + scrollLeft - clientLeft;
            point.y = box.top + scrollTop - clientTop;
            return point;
        },
        getAspectRatio: function(canvas) {
            return canvas.width / canvas.height;
        },
        setBackgroundColor: function(canvas, color) {
            color = color || "rgb(0,0,0)";
            canvas.style.backgroundColor = color;
            return canvas;
        },
        setTouchAction: function(canvas, value) {
            value = value || "none";
            canvas.style.msTouchAction = value;
            canvas.style["ms-touch-action"] = value;
            canvas.style["touch-action"] = value;
            return canvas;
        },
        setUserSelect: function(canvas, value) {
            value = value || "none";
            canvas.style["-webkit-touch-callout"] = value;
            canvas.style["-webkit-user-select"] = value;
            canvas.style["-khtml-user-select"] = value;
            canvas.style["-moz-user-select"] = value;
            canvas.style["-ms-user-select"] = value;
            canvas.style["user-select"] = value;
            canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return canvas;
        },
        addToDOM: function(canvas, parent, overflowHidden) {
            var target;
            if (typeof overflowHidden === "undefined") {
                overflowHidden = true;
            }
            if (parent) {
                if (typeof parent === "string") {
                    target = document.getElementById(parent);
                } else if (typeof parent === "object" && parent.nodeType === 1) {
                    target = parent;
                }
            }
            if (!target) {
                target = document.body;
            }
            if (overflowHidden && target.style) {
                target.style.overflow = "hidden";
            }
            target.appendChild(canvas);
            return canvas;
        },
        removeFromDOM: function(canvas) {
            if (canvas.parentNode) {
                canvas.parentNode.removeChild(canvas);
            }
        },
        setTransform: function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
            context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY);
            return context;
        },
        setSmoothingEnabled: function(context, value) {
            context["imageSmoothingEnabled"] = value;
            context["mozImageSmoothingEnabled"] = value;
            context["oImageSmoothingEnabled"] = value;
            context["webkitImageSmoothingEnabled"] = value;
            context["msImageSmoothingEnabled"] = value;
            return context;
        },
        getSmoothingEnabled: function(context) {
            return context["imageSmoothingEnabled"] || context["mozImageSmoothingEnabled"] || context["oImageSmoothingEnabled"] || context["webkitImageSmoothingEnabled"] || context["msImageSmoothingEnabled"];
        },
        setImageRenderingCrisp: function(canvas) {
            canvas.style["image-rendering"] = "optimizeSpeed";
            canvas.style["image-rendering"] = "crisp-edges";
            canvas.style["image-rendering"] = "-moz-crisp-edges";
            canvas.style["image-rendering"] = "-webkit-optimize-contrast";
            canvas.style["image-rendering"] = "optimize-contrast";
            canvas.style["image-rendering"] = "pixelated";
            canvas.style.msInterpolationMode = "nearest-neighbor";
            return canvas;
        },
        setImageRenderingBicubic: function(canvas) {
            canvas.style["image-rendering"] = "auto";
            canvas.style.msInterpolationMode = "bicubic";
            return canvas;
        }
    };
    Phaser.Device = function(game) {
        this.game = game;
        this.desktop = false;
        this.iOS = false;
        this.cocoonJS = false;
        this.cocoonJSApp = false;
        this.cordova = false;
        this.node = false;
        this.nodeWebkit = false;
        this.ejecta = false;
        this.crosswalk = false;
        this.android = false;
        this.chromeOS = false;
        this.linux = false;
        this.macOS = false;
        this.windows = false;
        this.windowsPhone = false;
        this.canvas = false;
        this.file = false;
        this.fileSystem = false;
        this.localStorage = false;
        this.webGL = false;
        this.worker = false;
        this.touch = false;
        this.mspointer = false;
        this.css3D = false;
        this.pointerLock = false;
        this.typedArray = false;
        this.vibration = false;
        this.getUserMedia = false;
        this.quirksMode = false;
        this.arora = false;
        this.chrome = false;
        this.epiphany = false;
        this.firefox = false;
        this.ie = false;
        this.ieVersion = 0;
        this.trident = false;
        this.tridentVersion = 0;
        this.mobileSafari = false;
        this.midori = false;
        this.opera = false;
        this.safari = false;
        this.webApp = false;
        this.silk = false;
        this.audioData = false;
        this.webAudio = false;
        this.ogg = false;
        this.opus = false;
        this.mp3 = false;
        this.wav = false;
        this.m4a = false;
        this.webm = false;
        this.iPhone = false;
        this.iPhone4 = false;
        this.iPad = false;
        this.pixelRatio = 0;
        this.littleEndian = false;
        this.support32bit = false;
        this.fullscreen = false;
        this.requestFullscreen = "";
        this.cancelFullscreen = "";
        this.fullscreenKeyboard = false;
        this._checkOS();
        this._checkAudio();
        this._checkBrowser();
        this._checkCSS3D();
        this._checkDevice();
        this._checkFeatures();
    };
    Phaser.Device.LITTLE_ENDIAN = false;
    Phaser.Device.prototype = {
        _checkOS: function() {
            var ua = navigator.userAgent;
            if (/Playstation Vita/.test(ua)) {
                this.vita = true;
            } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                this.kindle = true;
            } else if (/Android/.test(ua)) {
                this.android = true;
            } else if (/CrOS/.test(ua)) {
                this.chromeOS = true;
            } else if (/iP[ao]d|iPhone/i.test(ua)) {
                this.iOS = true;
            } else if (/Linux/.test(ua)) {
                this.linux = true;
            } else if (/Mac OS/.test(ua)) {
                this.macOS = true;
            } else if (/Windows/.test(ua)) {
                this.windows = true;
                if (/Windows Phone/i.test(ua)) {
                    this.windowsPhone = true;
                }
            }
            if (this.windows || this.macOS || this.linux && this.silk === false || this.chromeOS) {
                this.desktop = true;
            }
            if (this.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
                this.desktop = false;
            }
        },
        _checkFeatures: function() {
            this.canvas = !!window["CanvasRenderingContext2D"] || this.cocoonJS;
            try {
                this.localStorage = !!localStorage.getItem;
            } catch (error) {
                this.localStorage = false;
            }
            this.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
            this.fileSystem = !!window["requestFileSystem"];
            this.webGL = function() {
                try {
                    var canvas = document.createElement("canvas");
                    canvas.screencanvas = false;
                    return !!window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
                } catch (e) {
                    return false;
                }
            }();
            if (this.webGL === null || this.webGL === false) {
                this.webGL = false;
            } else {
                this.webGL = true;
            }
            this.worker = !!window["Worker"];
            if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1) {
                this.touch = true;
            }
            if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) {
                this.mspointer = true;
            }
            this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            this.quirksMode = document.compatMode === "CSS1Compat" ? false : true;
            this.getUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
        },
        checkFullScreenSupport: function() {
            var fs = [ "requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen" ];
            for (var i = 0; i < fs.length; i++) {
                if (this.game.canvas[fs[i]]) {
                    this.fullscreen = true;
                    this.requestFullscreen = fs[i];
                    break;
                }
            }
            var cfs = [ "cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen" ];
            if (this.fullscreen) {
                for (var i = 0; i < cfs.length; i++) {
                    if (document[cfs[i]]) {
                        this.cancelFullscreen = cfs[i];
                        break;
                    }
                }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"]) {
                this.fullscreenKeyboard = true;
            }
        },
        _checkBrowser: function() {
            var ua = navigator.userAgent;
            if (/Arora/.test(ua)) {
                this.arora = true;
            } else if (/Chrome/.test(ua)) {
                this.chrome = true;
            } else if (/Epiphany/.test(ua)) {
                this.epiphany = true;
            } else if (/Firefox/.test(ua)) {
                this.firefox = true;
            } else if (/AppleWebKit/.test(ua) && this.iOS) {
                this.mobileSafari = true;
            } else if (/MSIE (\d+\.\d+);/.test(ua)) {
                this.ie = true;
                this.ieVersion = parseInt(RegExp.$1, 10);
            } else if (/Midori/.test(ua)) {
                this.midori = true;
            } else if (/Opera/.test(ua)) {
                this.opera = true;
            } else if (/Safari/.test(ua)) {
                this.safari = true;
            } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
                this.ie = true;
                this.trident = true;
                this.tridentVersion = parseInt(RegExp.$1, 10);
                this.ieVersion = parseInt(RegExp.$3, 10);
            }
            if (/Silk/.test(ua)) {
                this.silk = true;
            }
            if (navigator["standalone"]) {
                this.webApp = true;
            }
            if (typeof window.cordova !== "undefined") {
                this.cordova = true;
            }
            if (typeof process !== "undefined" && typeof require !== "undefined") {
                this.node = true;
            }
            if (this.node) {
                try {
                    this.nodeWebkit = typeof require("nw.gui") !== "undefined";
                } catch (error) {
                    this.nodeWebkit = false;
                }
            }
            if (navigator["isCocoonJS"]) {
                this.cocoonJS = true;
            }
            if (this.cocoonJS) {
                try {
                    this.cocoonJSApp = typeof CocoonJS !== "undefined";
                } catch (error) {
                    this.cocoonJSApp = false;
                }
            }
            if (typeof window.ejecta !== "undefined") {
                this.ejecta = true;
            }
            if (/Crosswalk/.test(ua)) {
                this.crosswalk = true;
            }
        },
        _checkAudio: function() {
            this.audioData = !!window["Audio"];
            this.webAudio = !!(window["webkitAudioContext"] || window["AudioContext"]);
            var audioElement = document.createElement("audio");
            var result = false;
            try {
                if (result = !!audioElement.canPlayType) {
                    if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                        this.ogg = true;
                    }
                    if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "")) {
                        this.opus = true;
                    }
                    if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                        this.mp3 = true;
                    }
                    if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")) {
                        this.wav = true;
                    }
                    if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                        this.m4a = true;
                    }
                    if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                        this.webm = true;
                    }
                }
            } catch (e) {}
        },
        _checkDevice: function() {
            this.pixelRatio = window["devicePixelRatio"] || 1;
            this.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") != -1;
            this.iPhone4 = this.pixelRatio == 2 && this.iPhone;
            this.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") != -1;
            if (typeof Int8Array !== "undefined") {
                this.typedArray = true;
            } else {
                this.typedArray = false;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
                this.littleEndian = this._checkIsLittleEndian();
                Phaser.Device.LITTLE_ENDIAN = this.littleEndian;
            }
            this.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && this.littleEndian !== null && this._checkIsUint8ClampedImageData();
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
                this.vibration = true;
            }
        },
        _checkIsLittleEndian: function() {
            var a = new ArrayBuffer(4);
            var b = new Uint8Array(a);
            var c = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            if (c[0] == 3569595041) {
                return true;
            }
            if (c[0] == 2712847316) {
                return false;
            } else {
                return null;
            }
        },
        _checkIsUint8ClampedImageData: function() {
            if (typeof Uint8ClampedArray === "undefined") {
                return false;
            }
            var elem = document.createElement("canvas");
            var ctx = elem.getContext("2d");
            if (!ctx) {
                return false;
            }
            var image = ctx.createImageData(1, 1);
            return image.data instanceof Uint8ClampedArray;
        },
        _checkCSS3D: function() {
            var el = document.createElement("p");
            var has3d;
            var transforms = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(el, null);
            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }
            document.body.removeChild(el);
            this.css3D = has3d !== undefined && has3d.length > 0 && has3d !== "none";
        },
        canPlayAudio: function(type) {
            if (type == "mp3" && this.mp3) {
                return true;
            } else if (type == "ogg" && (this.ogg || this.opus)) {
                return true;
            } else if (type == "m4a" && this.m4a) {
                return true;
            } else if (type == "wav" && this.wav) {
                return true;
            } else if (type == "webm" && this.webm) {
                return true;
            }
            return false;
        },
        isConsoleOpen: function() {
            if (window.console && window.console["firebug"]) {
                return true;
            }
            if (window.console) {
                console.profile();
                console.profileEnd();
                if (console.clear) {
                    console.clear();
                }
                if (console["profiles"]) {
                    return console["profiles"].length > 0;
                }
            }
            return false;
        }
    };
    Phaser.Device.prototype.constructor = Phaser.Device;
    Phaser.Device.isAndroidStockBrowser = function() {
        var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return matches && matches[1] < 537;
    };
    Phaser.RequestAnimationFrame = function(game, forceSetTimeOut) {
        if (typeof forceSetTimeOut === "undefined") {
            forceSetTimeOut = false;
        }
        this.game = game;
        this.isRunning = false;
        this.forceSetTimeOut = forceSetTimeOut;
        var vendors = [ "ms", "moz", "webkit", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
        }
        this._isSetTimeOut = false;
        this._onLoop = null;
        this._timeOutID = null;
    };
    Phaser.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = true;
            var _this = this;
            if (!window.requestAnimationFrame || this.forceSetTimeOut) {
                this._isSetTimeOut = true;
                this._onLoop = function() {
                    return _this.updateSetTimeout();
                };
                this._timeOutID = window.setTimeout(this._onLoop, 0);
            } else {
                this._isSetTimeOut = false;
                this._onLoop = function(time) {
                    return _this.updateRAF(time);
                };
                this._timeOutID = window.requestAnimationFrame(this._onLoop);
            }
        },
        updateRAF: function() {
            this.game.update(Date.now());
            this._timeOutID = window.requestAnimationFrame(this._onLoop);
        },
        updateSetTimeout: function() {
            this.game.update(Date.now());
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
        },
        stop: function() {
            if (this._isSetTimeOut) {
                clearTimeout(this._timeOutID);
            } else {
                window.cancelAnimationFrame(this._timeOutID);
            }
            this.isRunning = false;
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut;
        },
        isRAF: function() {
            return this._isSetTimeOut === false;
        }
    };
    Phaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame;
    Phaser.Math = {
        PI2: Math.PI * 2,
        fuzzyEqual: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.abs(a - b) < epsilon;
        },
        fuzzyLessThan: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return a < b + epsilon;
        },
        fuzzyGreaterThan: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return a > b - epsilon;
        },
        fuzzyCeil: function(val, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.ceil(val - epsilon);
        },
        fuzzyFloor: function(val, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.floor(val + epsilon);
        },
        average: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length - 0; _i++) {
                args[_i] = arguments[_i + 0];
            }
            var avg = 0;
            for (var i = 0; i < args.length; i++) {
                avg += args[i];
            }
            return avg / args.length;
        },
        truncate: function(n) {
            return n > 0 ? Math.floor(n) : Math.ceil(n);
        },
        shear: function(n) {
            return n % 1;
        },
        snapTo: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.round(input / gap);
            return start + input;
        },
        snapToFloor: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.floor(input / gap);
            return start + input;
        },
        snapToCeil: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.ceil(input / gap);
            return start + input;
        },
        snapToInArray: function(input, arr, sort) {
            if (typeof sort === "undefined") {
                sort = true;
            }
            if (sort) {
                arr.sort();
            }
            if (input < arr[0]) {
                return arr[0];
            }
            var i = 1;
            while (arr[i] < input) {
                i++;
            }
            var low = arr[i - 1];
            var high = i < arr.length ? arr[i] : Number.POSITIVE_INFINITY;
            return high - input <= input - low ? high : low;
        },
        roundTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.round(value * p) / p;
        },
        floorTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.floor(value * p) / p;
        },
        ceilTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.ceil(value * p) / p;
        },
        interpolateFloat: function(a, b, weight) {
            return (b - a) * weight + a;
        },
        angleBetween: function(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        },
        angleBetweenY: function(x1, y1, x2, y2) {
            return Math.atan2(x2 - x1, y2 - y1);
        },
        angleBetweenPoints: function(point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
        },
        angleBetweenPointsY: function(point1, point2) {
            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
        },
        reverseAngle: function(angleRad) {
            return this.normalizeAngle(angleRad + Math.PI, true);
        },
        normalizeAngle: function(angleRad) {
            angleRad = angleRad % (2 * Math.PI);
            return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;
        },
        normalizeLatitude: function(lat) {
            return Math.max(-90, Math.min(90, lat));
        },
        normalizeLongitude: function(lng) {
            if (lng % 360 == 180) {
                return 180;
            }
            lng = lng % 360;
            return lng < -180 ? lng + 360 : lng > 180 ? lng - 360 : lng;
        },
        chanceRoll: function(chance) {
            if (typeof chance === "undefined") {
                chance = 50;
            }
            if (chance <= 0) {
                return false;
            } else if (chance >= 100) {
                return true;
            } else {
                if (Math.random() * 100 >= chance) {
                    return false;
                } else {
                    return true;
                }
            }
        },
        numberArray: function(min, max) {
            var result = [];
            for (var i = min; i <= max; i++) {
                result.push(i);
            }
            return result;
        },
        numberArrayStep: function(start, end, step) {
            start = +start || 0;
            var type = typeof end;
            if ((type === "number" || type === "string") && step && step[end] === start) {
                end = step = null;
            }
            step = step == null ? 1 : +step || 0;
            if (end === null) {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            var index = -1;
            var length = Phaser.Math.max(Phaser.Math.ceil((end - start) / (step || 1)), 0);
            var result = new Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        },
        maxAdd: function(value, amount, max) {
            value += amount;
            if (value > max) {
                value = max;
            }
            return value;
        },
        minSub: function(value, amount, min) {
            value -= amount;
            if (value < min) {
                value = min;
            }
            return value;
        },
        wrap: function(value, min, max) {
            var range = max - min;
            if (range <= 0) {
                return 0;
            }
            var result = (value - min) % range;
            if (result < 0) {
                result += range;
            }
            return result + min;
        },
        wrapValue: function(value, amount, max) {
            var diff;
            value = Math.abs(value);
            amount = Math.abs(amount);
            max = Math.abs(max);
            diff = (value + amount) % max;
            return diff;
        },
        limitValue: function(value, min, max) {
            return value < min ? min : value > max ? max : value;
        },
        randomSign: function() {
            return Math.random() > .5 ? 1 : -1;
        },
        isOdd: function(n) {
            return n & 1;
        },
        isEven: function(n) {
            if (n & 1) {
                return false;
            } else {
                return true;
            }
        },
        min: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i] < data[min]) {
                    min = i;
                }
            }
            return data[min];
        },
        max: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i] > data[max]) {
                    max = i;
                }
            }
            return data[max];
        },
        minProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i][property] < data[min][property]) {
                    min = i;
                }
            }
            return data[min][property];
        },
        maxProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i][property] > data[max][property]) {
                    max = i;
                }
            }
            return data[max][property];
        },
        wrapAngle: function(angle, radians) {
            var radianFactor = radians ? Math.PI / 180 : 1;
            return this.wrap(angle, -180 * radianFactor, 180 * radianFactor);
        },
        angleLimit: function(angle, min, max) {
            var result = angle;
            if (angle > max) {
                result = max;
            } else if (angle < min) {
                result = min;
            }
            return result;
        },
        linearInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (k < 0) {
                return this.linear(v[0], v[1], f);
            }
            if (k > 1) {
                return this.linear(v[m], v[m - 1], m - f);
            }
            return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        bezierInterpolation: function(v, k) {
            var b = 0;
            var n = v.length - 1;
            for (var i = 0; i <= n; i++) {
                b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);
            }
            return b;
        },
        catmullRomInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor(f = m * (1 + k));
                }
                return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            } else {
                if (k < 0) {
                    return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        linear: function(p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        bernstein: function(n, i) {
            return this.factorial(n) / this.factorial(i) / this.factorial(n - i);
        },
        factorial: function(value) {
            if (value === 0) {
                return 1;
            }
            var res = value;
            while (--value) {
                res *= value;
            }
            return res;
        },
        catmullRom: function(p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * .5, v1 = (p3 - p1) * .5, t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
        difference: function(a, b) {
            return Math.abs(a - b);
        },
        getRandom: function(objects, startIndex, length) {
            if (typeof startIndex === "undefined") {
                startIndex = 0;
            }
            if (typeof length === "undefined") {
                length = 0;
            }
            if (objects != null) {
                var l = length;
                if (l === 0 || l > objects.length - startIndex) {
                    l = objects.length - startIndex;
                }
                if (l > 0) {
                    return objects[startIndex + Math.floor(Math.random() * l)];
                }
            }
            return null;
        },
        removeRandom: function(objects, startIndex, length) {
            if (typeof startIndex === "undefined") {
                startIndex = 0;
            }
            if (typeof length === "undefined") {
                length = 0;
            }
            if (objects != null) {
                var l = length;
                if (l === 0 || l > objects.length - startIndex) {
                    l = objects.length - startIndex;
                }
                if (l > 0) {
                    var idx = startIndex + Math.floor(Math.random() * l);
                    var removed = objects.splice(idx, 1);
                    return removed[0];
                }
            }
            return null;
        },
        floor: function(value) {
            var n = value | 0;
            return value > 0 ? n : n != value ? n - 1 : n;
        },
        ceil: function(value) {
            var n = value | 0;
            return value > 0 ? n != value ? n + 1 : n : n;
        },
        sinCosGenerator: function(length, sinAmplitude, cosAmplitude, frequency) {
            if (typeof sinAmplitude === "undefined") {
                sinAmplitude = 1;
            }
            if (typeof cosAmplitude === "undefined") {
                cosAmplitude = 1;
            }
            if (typeof frequency === "undefined") {
                frequency = 1;
            }
            var sin = sinAmplitude;
            var cos = cosAmplitude;
            var frq = frequency * Math.PI / length;
            var cosTable = [];
            var sinTable = [];
            for (var c = 0; c < length; c++) {
                cos -= sin * frq;
                sin += cos * frq;
                cosTable[c] = cos;
                sinTable[c] = sin;
            }
            return {
                sin: sinTable,
                cos: cosTable,
                length: length
            };
        },
        shift: function(stack) {
            var s = stack.shift();
            stack.push(s);
            return s;
        },
        shuffleArray: function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        },
        distance: function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        },
        distancePow: function(x1, y1, x2, y2, pow) {
            if (typeof pow === "undefined") {
                pow = 2;
            }
            return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
        },
        distanceRounded: function(x1, y1, x2, y2) {
            return Math.round(Phaser.Math.distance(x1, y1, x2, y2));
        },
        clamp: function(x, a, b) {
            return x < a ? a : x > b ? b : x;
        },
        clampBottom: function(x, a) {
            return x < a ? a : x;
        },
        within: function(a, b, tolerance) {
            return Math.abs(a - b) <= tolerance;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        smoothstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        sign: function(x) {
            return x < 0 ? -1 : x > 0 ? 1 : 0;
        },
        percent: function(a, b, base) {
            if (typeof base === "undefined") {
                base = 0;
            }
            if (a > b || base > b) {
                return 1;
            } else if (a < base || base > a) {
                return 0;
            } else {
                return (a - base) / b;
            }
        },
        degToRad: function() {
            var degreeToRadiansFactor = Math.PI / 180;
            return function(degrees) {
                return degrees * degreeToRadiansFactor;
            };
        }(),
        radToDeg: function() {
            var radianToDegreesFactor = 180 / Math.PI;
            return function(radians) {
                return radians * radianToDegreesFactor;
            };
        }()
    };
    Phaser.RandomDataGenerator = function(seeds) {
        if (typeof seeds === "undefined") {
            seeds = [];
        }
        this.c = 1;
        this.s0 = 0;
        this.s1 = 0;
        this.s2 = 0;
        this.sow(seeds);
    };
    Phaser.RandomDataGenerator.prototype = {
        rnd: function() {
            var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;
            this.c = t | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = t - this.c;
            return this.s2;
        },
        sow: function(seeds) {
            if (typeof seeds === "undefined") {
                seeds = [];
            }
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            var seed;
            for (var i = 0; seed = seeds[i++]; ) {
                this.s0 -= this.hash(seed);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(seed);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(seed);
                this.s2 += ~~(this.s2 < 0);
            }
        },
        hash: function(data) {
            var h, i, n;
            n = 4022871197;
            data = data.toString();
            for (i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                h = .02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 4294967296;
            }
            return (n >>> 0) * 2.3283064365386963e-10;
        },
        integer: function() {
            return this.rnd.apply(this) * 4294967296;
        },
        frac: function() {
            return this.rnd.apply(this) + (this.rnd.apply(this) * 2097152 | 0) * 1.1102230246251565e-16;
        },
        real: function() {
            return this.integer() + this.frac();
        },
        integerInRange: function(min, max) {
            return Math.floor(this.realInRange(0, max - min + 1) + min);
        },
        between: function(min, max) {
            return this.integerInRange(min, max);
        },
        realInRange: function(min, max) {
            return this.frac() * (max - min) + min;
        },
        normal: function() {
            return 1 - 2 * this.frac();
        },
        uuid: function() {
            var a = "";
            var b = "";
            for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}
            return b;
        },
        pick: function(ary) {
            return ary[this.integerInRange(0, ary.length - 1)];
        },
        weightedPick: function(ary) {
            return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1))];
        },
        timestamp: function(min, max) {
            return this.realInRange(min || 9466848e5, max || 1577862e6);
        },
        angle: function() {
            return this.integerInRange(-180, 180);
        }
    };
    Phaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator;
    Phaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.level = 0;
        this.bounds = {};
        this.objects = [];
        this.nodes = [];
        this._empty = [];
        this.reset(x, y, width, height, maxObjects, maxLevels, level);
    };
    Phaser.QuadTree.prototype = {
        reset: function(x, y, width, height, maxObjects, maxLevels, level) {
            this.maxObjects = maxObjects || 10;
            this.maxLevels = maxLevels || 4;
            this.level = level || 0;
            this.bounds = {
                x: Math.round(x),
                y: Math.round(y),
                width: width,
                height: height,
                subWidth: Math.floor(width / 2),
                subHeight: Math.floor(height / 2),
                right: Math.round(x) + Math.floor(width / 2),
                bottom: Math.round(y) + Math.floor(height / 2)
            };
            this.objects.length = 0;
            this.nodes.length = 0;
        },
        populate: function(group) {
            group.forEach(this.populateHandler, this, true);
        },
        populateHandler: function(sprite) {
            if (sprite.body && sprite.exists) {
                this.insert(sprite.body);
            }
        },
        split: function() {
            this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        },
        insert: function(body) {
            var i = 0;
            var index;
            if (this.nodes[0] != null) {
                index = this.getIndex(body);
                if (index !== -1) {
                    this.nodes[index].insert(body);
                    return;
                }
            }
            this.objects.push(body);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                if (this.nodes[0] == null) {
                    this.split();
                }
                while (i < this.objects.length) {
                    index = this.getIndex(this.objects[i]);
                    if (index !== -1) {
                        this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                    } else {
                        i++;
                    }
                }
            }
        },
        getIndex: function(rect) {
            var index = -1;
            if (rect.x < this.bounds.right && rect.right < this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 1;
                } else if (rect.y > this.bounds.bottom) {
                    index = 2;
                }
            } else if (rect.x > this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 0;
                } else if (rect.y > this.bounds.bottom) {
                    index = 3;
                }
            }
            return index;
        },
        retrieve: function(source) {
            if (source instanceof Phaser.Rectangle) {
                var returnObjects = this.objects;
                var index = this.getIndex(source);
            } else {
                if (!source.body) {
                    return this._empty;
                }
                var returnObjects = this.objects;
                var index = this.getIndex(source.body);
            }
            if (this.nodes[0]) {
                if (index !== -1) {
                    returnObjects = returnObjects.concat(this.nodes[index].retrieve(source));
                } else {
                    returnObjects = returnObjects.concat(this.nodes[0].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[1].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[2].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[3].retrieve(source));
                }
            }
            return returnObjects;
        },
        clear: function() {
            this.objects.length = 0;
            var i = this.nodes.length;
            while (i--) {
                this.nodes[i].clear();
                this.nodes.splice(i, 1);
            }
            this.nodes.length = 0;
        }
    };
    Phaser.QuadTree.prototype.constructor = Phaser.QuadTree;
    Phaser.Net = function(game) {
        this.game = game;
    };
    Phaser.Net.prototype = {
        getHostName: function() {
            if (window.location && window.location.hostname) {
                return window.location.hostname;
            }
            return null;
        },
        checkDomainName: function(domain) {
            return window.location.hostname.indexOf(domain) !== -1;
        },
        updateQueryString: function(key, value, redirect, url) {
            if (typeof redirect === "undefined") {
                redirect = false;
            }
            if (typeof url === "undefined" || url === "") {
                url = window.location.href;
            }
            var output = "";
            var re = new RegExp("([?|&])" + key + "=.*?(&|#|$)(.*)", "gi");
            if (re.test(url)) {
                if (typeof value !== "undefined" && value !== null) {
                    output = url.replace(re, "$1" + key + "=" + value + "$2$3");
                } else {
                    output = url.replace(re, "$1$3").replace(/(&|\?)$/, "");
                }
            } else {
                if (typeof value !== "undefined" && value !== null) {
                    var separator = url.indexOf("?") !== -1 ? "&" : "?";
                    var hash = url.split("#");
                    url = hash[0] + separator + key + "=" + value;
                    if (hash[1]) {
                        url += "#" + hash[1];
                    }
                    output = url;
                } else {
                    output = url;
                }
            }
            if (redirect) {
                window.location.href = output;
            } else {
                return output;
            }
        },
        getQueryString: function(parameter) {
            if (typeof parameter === "undefined") {
                parameter = "";
            }
            var output = {};
            var keyValues = location.search.substring(1).split("&");
            for (var i in keyValues) {
                var key = keyValues[i].split("=");
                if (key.length > 1) {
                    if (parameter && parameter == this.decodeURI(key[0])) {
                        return this.decodeURI(key[1]);
                    } else {
                        output[this.decodeURI(key[0])] = this.decodeURI(key[1]);
                    }
                }
            }
            return output;
        },
        decodeURI: function(value) {
            return decodeURIComponent(value.replace(/\+/g, " "));
        }
    };
    Phaser.Net.prototype.constructor = Phaser.Net;
    Phaser.TweenManager = function(game) {
        this.game = game;
        this._tweens = [];
        this._add = [];
        this.game.onPause.add(this._pauseAll, this);
        this.game.onResume.add(this._resumeAll, this);
    };
    Phaser.TweenManager.prototype = {
        getAll: function() {
            return this._tweens;
        },
        removeAll: function() {
            for (var i = 0; i < this._tweens.length; i++) {
                this._tweens[i].pendingDelete = true;
            }
            this._add = [];
        },
        add: function(tween) {
            tween._manager = this;
            this._add.push(tween);
        },
        create: function(object) {
            return new Phaser.Tween(object, this.game, this);
        },
        remove: function(tween) {
            var i = this._tweens.indexOf(tween);
            if (i !== -1) {
                this._tweens[i].pendingDelete = true;
            } else {
                i = this._add.indexOf(tween);
                if (i !== -1) {
                    this._add[i].pendingDelete = true;
                }
            }
        },
        update: function() {
            var addTweens = this._add.length;
            var numTweens = this._tweens.length;
            if (numTweens === 0 && addTweens === 0) {
                return false;
            }
            var i = 0;
            while (i < numTweens) {
                if (this._tweens[i].update(this.game.time.now)) {
                    i++;
                } else {
                    this._tweens.splice(i, 1);
                    numTweens--;
                }
            }
            if (addTweens > 0) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0;
            }
            return true;
        },
        isTweening: function(object) {
            return this._tweens.some(function(tween) {
                return tween._object === object;
            });
        },
        _pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._pause();
            }
        },
        _resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._resume();
            }
        },
        pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].pause();
            }
        },
        resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].resume(true);
            }
        }
    };
    Phaser.TweenManager.prototype.constructor = Phaser.TweenManager;
    Phaser.Tween = function(object, game, manager) {
        this._object = object;
        this.game = game;
        this._manager = manager;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1e3;
        this._repeat = 0;
        this._yoyo = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = Phaser.Easing.Default;
        this._interpolationFunction = Phaser.Math.linearInterpolation;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._onUpdateCallback = null;
        this._onUpdateCallbackContext = null;
        this._paused = false;
        this._pausedTime = 0;
        this._codePaused = false;
        this.pendingDelete = false;
        this.onStart = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onComplete = new Phaser.Signal();
        this.isRunning = false;
    };
    Phaser.Tween.prototype = {
        to: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            duration = duration || 1e3;
            ease = ease || null;
            autoStart = autoStart || false;
            delay = delay || 0;
            repeat = repeat || 0;
            yoyo = yoyo || false;
            if (yoyo && repeat === 0) {
                repeat = 1;
            }
            var self;
            if (this._parent) {
                self = this._manager.create(this._object);
                this._lastChild.chain(self);
                this._lastChild = self;
            } else {
                self = this;
                this._parent = this;
                this._lastChild = this;
            }
            self._repeat = repeat;
            self._duration = duration;
            self._valuesEnd = properties;
            if (ease !== null) {
                self._easingFunction = ease;
            }
            if (delay > 0) {
                self._delayTime = delay;
            }
            self._yoyo = yoyo;
            if (autoStart) {
                return this.start();
            } else {
                return this;
            }
        },
        from: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            var _cache = {};
            for (var prop in properties) {
                _cache[prop] = this._object[prop];
                this._object[prop] = properties[prop];
            }
            return this.to(_cache, duration, ease, autoStart, delay, repeat, yoyo);
        },
        start: function() {
            if (this.game === null || this._object === null) {
                return;
            }
            this._manager.add(this);
            this.isRunning = true;
            this._onStartCallbackFired = false;
            this._startTime = this.game.time.now + this._delayTime;
            for (var property in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[property])) {
                    if (this._valuesEnd[property].length === 0) {
                        continue;
                    }
                    this._valuesEnd[property] = [ this._object[property] ].concat(this._valuesEnd[property]);
                }
                this._valuesStart[property] = this._object[property];
                if (!Array.isArray(this._valuesStart[property])) {
                    this._valuesStart[property] *= 1;
                }
                this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
            }
            return this;
        },
        generateData: function(frameRate, data) {
            if (this.game === null || this._object === null) {
                return null;
            }
            this._startTime = 0;
            for (var property in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[property])) {
                    if (this._valuesEnd[property].length === 0) {
                        continue;
                    }
                    this._valuesEnd[property] = [ this._object[property] ].concat(this._valuesEnd[property]);
                }
                this._valuesStart[property] = this._object[property];
                if (!Array.isArray(this._valuesStart[property])) {
                    this._valuesStart[property] *= 1;
                }
                this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
            }
            var time = 0;
            var total = Math.floor(frameRate * (this._duration / 1e3));
            var tick = this._duration / total;
            var output = [];
            while (total--) {
                var property;
                var elapsed = (time - this._startTime) / this._duration;
                elapsed = elapsed > 1 ? 1 : elapsed;
                var value = this._easingFunction(elapsed);
                var blob = {};
                for (property in this._valuesEnd) {
                    var start = this._valuesStart[property] || 0;
                    var end = this._valuesEnd[property];
                    if (end instanceof Array) {
                        blob[property] = this._interpolationFunction(end, value);
                    } else {
                        if (typeof end === "string") {
                            end = start + parseFloat(end, 10);
                        } else if (typeof end === "number") {
                            blob[property] = start + (end - start) * value;
                        }
                    }
                }
                output.push(blob);
                time += tick;
            }
            var blob = {};
            for (property in this._valuesEnd) {
                blob[property] = this._valuesEnd[property];
            }
            output.push(blob);
            if (this._yoyo) {
                var reversed = output.slice();
                reversed.reverse();
                output = output.concat(reversed);
            }
            if (typeof data !== "undefined") {
                data = data.concat(output);
                return data;
            } else {
                return output;
            }
        },
        stop: function() {
            this.isRunning = false;
            this._onUpdateCallback = null;
            this._manager.remove(this);
            return this;
        },
        delay: function(amount) {
            this._delayTime = amount;
            return this;
        },
        repeat: function(times) {
            this._repeat = times;
            return this;
        },
        yoyo: function(yoyo) {
            this._yoyo = yoyo;
            if (yoyo && this._repeat === 0) {
                this._repeat = 1;
            }
            return this;
        },
        easing: function(easing) {
            this._easingFunction = easing;
            return this;
        },
        interpolation: function(interpolation) {
            this._interpolationFunction = interpolation;
            return this;
        },
        chain: function() {
            this._chainedTweens = arguments;
            return this;
        },
        loop: function() {
            this._lastChild.chain(this);
            return this;
        },
        onUpdateCallback: function(callback, callbackContext) {
            this._onUpdateCallback = callback;
            this._onUpdateCallbackContext = callbackContext;
            return this;
        },
        pause: function() {
            this._codePaused = true;
            this._paused = true;
            this._pausedTime = this.game.time.now;
        },
        _pause: function() {
            if (!this._codePaused) {
                this._paused = true;
                this._pausedTime = this.game.time.now;
            }
        },
        resume: function() {
            if (this._paused) {
                this._paused = false;
                this._codePaused = false;
                this._startTime += this.game.time.now - this._pausedTime;
            }
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this._startTime += this.game.time.pauseDuration;
                this._paused = false;
            }
        },
        update: function(time) {
            if (this.pendingDelete) {
                return false;
            }
            if (this._paused || time < this._startTime) {
                return true;
            }
            var property;
            if (time < this._startTime) {
                return true;
            }
            if (this._onStartCallbackFired === false) {
                this.onStart.dispatch(this._object);
                this._onStartCallbackFired = true;
            }
            var elapsed = (time - this._startTime) / this._duration;
            elapsed = elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction(elapsed);
            for (property in this._valuesEnd) {
                var start = this._valuesStart[property] || 0;
                var end = this._valuesEnd[property];
                if (end instanceof Array) {
                    this._object[property] = this._interpolationFunction(end, value);
                } else {
                    if (typeof end === "string") {
                        end = start + parseFloat(end, 10);
                    }
                    if (typeof end === "number") {
                        this._object[property] = start + (end - start) * value;
                    }
                }
            }
            if (this._onUpdateCallback !== null) {
                this._onUpdateCallback.call(this._onUpdateCallbackContext, this, value);
                if (!this.isRunning) {
                    return false;
                }
            }
            if (elapsed == 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--;
                    }
                    for (property in this._valuesStartRepeat) {
                        if (typeof this._valuesEnd[property] === "string") {
                            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property], 10);
                        }
                        if (this._yoyo) {
                            var tmp = this._valuesStartRepeat[property];
                            this._valuesStartRepeat[property] = this._valuesEnd[property];
                            this._valuesEnd[property] = tmp;
                        }
                        this._valuesStart[property] = this._valuesStartRepeat[property];
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed;
                    }
                    this._startTime = time + this._delayTime;
                    this.onLoop.dispatch(this._object);
                    return true;
                } else {
                    this.isRunning = false;
                    this.onComplete.dispatch(this._object);
                    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                        this._chainedTweens[i].start(time);
                    }
                    return false;
                }
            }
            return true;
        }
    };
    Phaser.Tween.prototype.constructor = Phaser.Tween;
    Phaser.Easing = {
        Linear: {
            None: function(k) {
                return k;
            }
        },
        Quadratic: {
            In: function(k) {
                return k * k;
            },
            Out: function(k) {
                return k * (2 - k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k;
                return -.5 * (--k * (k - 2) - 1);
            }
        },
        Cubic: {
            In: function(k) {
                return k * k * k;
            },
            Out: function(k) {
                return --k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k;
                return .5 * ((k -= 2) * k * k + 2);
            }
        },
        Quartic: {
            In: function(k) {
                return k * k * k * k;
            },
            Out: function(k) {
                return 1 - --k * k * k * k;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k;
                return -.5 * ((k -= 2) * k * k * k - 2);
            }
        },
        Quintic: {
            In: function(k) {
                return k * k * k * k * k;
            },
            Out: function(k) {
                return --k * k * k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k * k;
                return .5 * ((k -= 2) * k * k * k * k + 2);
            }
        },
        Sinusoidal: {
            In: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            Out: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            InOut: function(k) {
                return .5 * (1 - Math.cos(Math.PI * k));
            }
        },
        Exponential: {
            In: function(k) {
                return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            Out: function(k) {
                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            InOut: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
                return .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
        },
        Circular: {
            In: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            Out: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
                return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
        },
        Elastic: {
            In: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            },
            Out: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            },
            InOut: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                if ((k *= 2) < 1) return -.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
            }
        },
        Back: {
            In: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            Out: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            InOut: function(k) {
                var s = 1.70158 * 1.525;
                if ((k *= 2) < 1) return .5 * (k * k * ((s + 1) * k - s));
                return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
        },
        Bounce: {
            In: function(k) {
                return 1 - Phaser.Easing.Bounce.Out(1 - k);
            },
            Out: function(k) {
                if (k < 1 / 2.75) {
                    return 7.5625 * k * k;
                } else if (k < 2 / 2.75) {
                    return 7.5625 * (k -= 1.5 / 2.75) * k + .75;
                } else if (k < 2.5 / 2.75) {
                    return 7.5625 * (k -= 2.25 / 2.75) * k + .9375;
                } else {
                    return 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
                }
            },
            InOut: function(k) {
                if (k < .5) return Phaser.Easing.Bounce.In(k * 2) * .5;
                return Phaser.Easing.Bounce.Out(k * 2 - 1) * .5 + .5;
            }
        }
    };
    Phaser.Easing.Default = Phaser.Easing.Linear.None;
    Phaser.Time = function(game) {
        this.game = game;
        this.time = 0;
        this.now = 0;
        this.elapsed = 0;
        this.pausedTime = 0;
        this.advancedTiming = false;
        this.fps = 0;
        this.fpsMin = 1e3;
        this.fpsMax = 0;
        this.msMin = 1e3;
        this.msMax = 0;
        this.physicsElapsed = 0;
        this.deltaCap = 0;
        this.timeCap = 1 / 60 * 1e3;
        this.frames = 0;
        this.pauseDuration = 0;
        this.timeToCall = 0;
        this.lastTime = 0;
        this.events = new Phaser.Timer(this.game, false);
        this._started = 0;
        this._timeLastSecond = 0;
        this._pauseStarted = 0;
        this._justResumed = false;
        this._timers = [];
        this._len = 0;
        this._i = 0;
    };
    Phaser.Time.prototype = {
        boot: function() {
            this._started = Date.now();
            this.events.start();
        },
        add: function(timer) {
            this._timers.push(timer);
            return timer;
        },
        create: function(autoDestroy) {
            if (typeof autoDestroy === "undefined") {
                autoDestroy = true;
            }
            var timer = new Phaser.Timer(this.game, autoDestroy);
            this._timers.push(timer);
            return timer;
        },
        removeAll: function() {
            for (var i = 0; i < this._timers.length; i++) {
                this._timers[i].destroy();
            }
            this._timers = [];
            this.events.removeAll();
        },
        update: function(time) {
            this.now = time;
            this.timeToCall = this.game.math.max(0, 16 - (time - this.lastTime));
            this.elapsed = this.now - this.time;
            if (this.elapsed > this.timeCap) {
                this.elapsed = this.timeCap;
            }
            this.physicsElapsed = this.elapsed / 1e3 || 1 / 60;
            if (this.deltaCap > 0 && this.physicsElapsed > this.deltaCap) {
                this.physicsElapsed = this.deltaCap;
            }
            if (this.advancedTiming) {
                this.msMin = this.game.math.min(this.msMin, this.elapsed);
                this.msMax = this.game.math.max(this.msMax, this.elapsed);
                this.frames++;
                if (this.now > this._timeLastSecond + 1e3) {
                    this.fps = Math.round(this.frames * 1e3 / (this.now - this._timeLastSecond));
                    this.fpsMin = this.game.math.min(this.fpsMin, this.fps);
                    this.fpsMax = this.game.math.max(this.fpsMax, this.fps);
                    this._timeLastSecond = this.now;
                    this.frames = 0;
                }
            }
            this.time = this.now;
            this.lastTime = time + this.timeToCall;
            if (!this.game.paused) {
                this.events.update(this.now);
                this._i = 0;
                this._len = this._timers.length;
                while (this._i < this._len) {
                    if (this._timers[this._i].update(this.now)) {
                        this._i++;
                    } else {
                        this._timers.splice(this._i, 1);
                        this._len--;
                    }
                }
            }
        },
        gamePaused: function() {
            this._pauseStarted = this.now;
            this.events.pause();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._pause();
            }
        },
        gameResumed: function() {
            this.time = this.now = Date.now();
            this.pauseDuration = this.time - this._pauseStarted;
            this.events.resume();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._resume();
            }
        },
        totalElapsedSeconds: function() {
            return (this.now - this._started) * .001;
        },
        elapsedSince: function(since) {
            return this.now - since;
        },
        elapsedSecondsSince: function(since) {
            return (this.now - since) * .001;
        },
        reset: function() {
            this._started = this.now;
            this.removeAll();
        }
    };
    Phaser.Time.prototype.constructor = Phaser.Time;
    Phaser.Timer = function(game, autoDestroy) {
        if (typeof autoDestroy === "undefined") {
            autoDestroy = true;
        }
        this.game = game;
        this.running = false;
        this.autoDestroy = autoDestroy;
        this.expired = false;
        this.elapsed = 0;
        this.events = [];
        this.onComplete = new Phaser.Signal();
        this.nextTick = 0;
        this.timeCap = 1e3;
        this.paused = false;
        this._codePaused = false;
        this._started = 0;
        this._pauseStarted = 0;
        this._pauseTotal = 0;
        this._now = Date.now();
        this._len = 0;
        this._marked = 0;
        this._i = 0;
        this._diff = 0;
        this._newTick = 0;
    };
    Phaser.Timer.MINUTE = 6e4;
    Phaser.Timer.SECOND = 1e3;
    Phaser.Timer.HALF = 500;
    Phaser.Timer.QUARTER = 250;
    Phaser.Timer.prototype = {
        create: function(delay, loop, repeatCount, callback, callbackContext, args) {
            var tick = delay;
            if (this._now === 0) {
                tick += this.game.time.now;
            } else {
                tick += this._now;
            }
            var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);
            this.events.push(event);
            this.order();
            this.expired = false;
            return event;
        },
        add: function(delay, callback, callbackContext) {
            return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        repeat: function(delay, repeatCount, callback, callbackContext) {
            return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
        },
        loop: function(delay, callback, callbackContext) {
            return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        start: function(delay) {
            if (this.running) {
                return;
            }
            this._started = this.game.time.now + (delay || 0);
            this.running = true;
            for (var i = 0; i < this.events.length; i++) {
                this.events[i].tick = this.events[i].delay + this._started;
            }
        },
        stop: function(clearEvents) {
            this.running = false;
            if (typeof clearEvents === "undefined") {
                clearEvents = true;
            }
            if (clearEvents) {
                this.events.length = 0;
            }
        },
        remove: function(event) {
            for (var i = 0; i < this.events.length; i++) {
                if (this.events[i] === event) {
                    this.events[i].pendingDelete = true;
                    return true;
                }
            }
            return false;
        },
        order: function() {
            if (this.events.length > 0) {
                this.events.sort(this.sortHandler);
                this.nextTick = this.events[0].tick;
            }
        },
        sortHandler: function(a, b) {
            if (a.tick < b.tick) {
                return -1;
            } else if (a.tick > b.tick) {
                return 1;
            }
            return 0;
        },
        clearPendingEvents: function() {
            this._i = this.events.length;
            while (this._i--) {
                if (this.events[this._i].pendingDelete) {
                    this.events.splice(this._i, 1);
                }
            }
            this._len = this.events.length;
            this._i = 0;
        },
        update: function(time) {
            if (this.paused) {
                return true;
            }
            this.elapsed = time - this._now;
            this._now = time;
            if (this.elapsed > this.timeCap) {
                this.adjustEvents(time - this.elapsed);
            }
            this._marked = 0;
            this.clearPendingEvents();
            if (this.running && this._now >= this.nextTick && this._len > 0) {
                while (this._i < this._len && this.running) {
                    if (this._now >= this.events[this._i].tick) {
                        this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick);
                        if (this._newTick < 0) {
                            this._newTick = this._now + this.events[this._i].delay;
                        }
                        if (this.events[this._i].loop === true) {
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else if (this.events[this._i].repeatCount > 0) {
                            this.events[this._i].repeatCount--;
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else {
                            this._marked++;
                            this.events[this._i].pendingDelete = true;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        }
                        this._i++;
                    } else {
                        break;
                    }
                }
                if (this.events.length > this._marked) {
                    this.order();
                } else {
                    this.expired = true;
                    this.onComplete.dispatch(this);
                }
            }
            if (this.expired && this.autoDestroy) {
                return false;
            } else {
                return true;
            }
        },
        pause: function() {
            if (!this.running) {
                return;
            }
            this._codePaused = true;
            if (this.paused) {
                return;
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true;
        },
        _pause: function() {
            if (this.paused || !this.running) {
                return;
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true;
        },
        adjustEvents: function(baseTime) {
            for (var i = 0; i < this.events.length; i++) {
                if (!this.events[i].pendingDelete) {
                    var t = this.events[i].tick - baseTime;
                    if (t < 0) {
                        t = 0;
                    }
                    this.events[i].tick = this._now + t;
                }
            }
            var d = this.nextTick - baseTime;
            if (d < 0) {
                this.nextTick = this._now;
            } else {
                this.nextTick = this._now + d;
            }
        },
        resume: function() {
            if (!this.paused) {
                return;
            }
            var now = this.game.time.now;
            this._pauseTotal += now - this._now;
            this._now = now;
            this.adjustEvents(this._pauseStarted);
            this.paused = false;
            this._codePaused = false;
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this.resume();
            }
        },
        removeAll: function() {
            this.onComplete.removeAll();
            this.events.length = 0;
            this._len = 0;
            this._i = 0;
        },
        destroy: function() {
            this.onComplete.removeAll();
            this.running = false;
            this.events = [];
            this._len = 0;
            this._i = 0;
        }
    };
    Object.defineProperty(Phaser.Timer.prototype, "next", {
        get: function() {
            return this.nextTick;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "duration", {
        get: function() {
            if (this.running && this.nextTick > this._now) {
                return this.nextTick - this._now;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "length", {
        get: function() {
            return this.events.length;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "ms", {
        get: function() {
            if (this.running) {
                return this._now - this._started - this._pauseTotal;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "seconds", {
        get: function() {
            if (this.running) {
                return this.ms * .001;
            } else {
                return 0;
            }
        }
    });
    Phaser.Timer.prototype.constructor = Phaser.Timer;
    Phaser.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {
        this.timer = timer;
        this.delay = delay;
        this.tick = tick;
        this.repeatCount = repeatCount - 1;
        this.loop = loop;
        this.callback = callback;
        this.callbackContext = callbackContext;
        this.args = args;
        this.pendingDelete = false;
    };
    Phaser.TimerEvent.prototype.constructor = Phaser.TimerEvent;
    Phaser.AnimationManager = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.currentFrame = null;
        this.currentAnim = null;
        this.updateIfVisible = true;
        this.isLoaded = false;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = [];
    };
    Phaser.AnimationManager.prototype = {
        loadFrameData: function(frameData, frame) {
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(frameData);
                }
            }
            this._frameData = frameData;
            if (typeof frame === "undefined" || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        copyFrameData: function(frameData, frame) {
            this._frameData = frameData.clone();
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(this._frameData);
                }
            }
            if (typeof frame === "undefined" || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        add: function(name, frames, frameRate, loop, useNumericIndex) {
            frames = frames || [];
            frameRate = frameRate || 60;
            if (typeof loop === "undefined") {
                loop = false;
            }
            if (typeof useNumericIndex === "undefined") {
                if (frames && typeof frames[0] === "number") {
                    useNumericIndex = true;
                } else {
                    useNumericIndex = false;
                }
            }
            if (this.sprite.events.onAnimationStart === null) {
                this.sprite.events.onAnimationStart = new Phaser.Signal();
                this.sprite.events.onAnimationComplete = new Phaser.Signal();
                this.sprite.events.onAnimationLoop = new Phaser.Signal();
            }
            this._outputFrames.length = 0;
            this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames);
            this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop);
            this.currentAnim = this._anims[name];
            this.currentFrame = this.currentAnim.currentFrame;
            if (this.sprite.__tilePattern) {
                this.sprite.__tilePattern = false;
                this.tilingTexture = false;
            }
            return this._anims[name];
        },
        validateFrames: function(frames, useNumericIndex) {
            if (typeof useNumericIndex == "undefined") {
                useNumericIndex = true;
            }
            for (var i = 0; i < frames.length; i++) {
                if (useNumericIndex === true) {
                    if (frames[i] > this._frameData.total) {
                        return false;
                    }
                } else {
                    if (this._frameData.checkFrameName(frames[i]) === false) {
                        return false;
                    }
                }
            }
            return true;
        },
        play: function(name, frameRate, loop, killOnComplete) {
            if (this._anims[name]) {
                if (this.currentAnim === this._anims[name]) {
                    if (this.currentAnim.isPlaying === false) {
                        this.currentAnim.paused = false;
                        return this.currentAnim.play(frameRate, loop, killOnComplete);
                    }
                    return this.currentAnim;
                } else {
                    if (this.currentAnim && this.currentAnim.isPlaying) {
                        this.currentAnim.stop();
                    }
                    this.currentAnim = this._anims[name];
                    this.currentAnim.paused = false;
                    this.currentFrame = this.currentAnim.currentFrame;
                    return this.currentAnim.play(frameRate, loop, killOnComplete);
                }
            }
        },
        stop: function(name, resetFrame) {
            if (typeof resetFrame == "undefined") {
                resetFrame = false;
            }
            if (typeof name == "string") {
                if (this._anims[name]) {
                    this.currentAnim = this._anims[name];
                    this.currentAnim.stop(resetFrame);
                }
            } else {
                if (this.currentAnim) {
                    this.currentAnim.stop(resetFrame);
                }
            }
        },
        update: function() {
            if (this.updateIfVisible && !this.sprite.visible) {
                return false;
            }
            if (this.currentAnim && this.currentAnim.update() === true) {
                this.currentFrame = this.currentAnim.currentFrame;
                return true;
            }
            return false;
        },
        next: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.next(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        previous: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.previous(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        getAnimation: function(name) {
            if (typeof name === "string") {
                if (this._anims[name]) {
                    return this._anims[name];
                }
            }
            return null;
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            if (this.sprite.__tilePattern) {
                this.__tilePattern = false;
                this.tilingTexture = false;
            }
        },
        destroy: function() {
            var anim = null;
            for (var anim in this._anims) {
                if (this._anims.hasOwnProperty(anim)) {
                    this._anims[anim].destroy();
                }
            }
            this._anims = {};
            this._frameData = null;
            this._frameIndex = 0;
            this.currentAnim = null;
            this.currentFrame = null;
        }
    };
    Phaser.AnimationManager.prototype.constructor = Phaser.AnimationManager;
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused;
        },
        set: function(value) {
            this.currentAnim.paused = value;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) {
                return this._frameIndex;
            }
        },
        set: function(value) {
            if (typeof value === "number" && this._frameData.getFrame(value) !== null) {
                this.currentFrame = this._frameData.getFrame(value);
                if (this.currentFrame) {
                    this._frameIndex = value;
                    this.sprite.setFrame(this.currentFrame);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false;
                    }
                }
            }
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) {
                return this.currentFrame.name;
            }
        },
        set: function(value) {
            if (typeof value === "string" && this._frameData.getFrameByName(value) !== null) {
                this.currentFrame = this._frameData.getFrameByName(value);
                if (this.currentFrame) {
                    this._frameIndex = this.currentFrame.index;
                    this.sprite.setFrame(this.currentFrame);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false;
                    }
                }
            } else {
                console.warn("Cannot set frameName: " + value);
            }
        }
    });
    Phaser.Animation = function(game, parent, name, frameData, frames, delay, loop) {
        this.game = game;
        this._parent = parent;
        this._frameData = frameData;
        this.name = name;
        this._frames = [];
        this._frames = this._frames.concat(frames);
        this.delay = 1e3 / delay;
        this.loop = loop;
        this.loopCount = 0;
        this.killOnComplete = false;
        this.isFinished = false;
        this.isPlaying = false;
        this.isPaused = false;
        this._pauseStartTime = 0;
        this._frameIndex = 0;
        this._frameDiff = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.onStart = new Phaser.Signal();
        this.onUpdate = null;
        this.onComplete = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.game.onPause.add(this.onPause, this);
        this.game.onResume.add(this.onResume, this);
    };
    Phaser.Animation.prototype = {
        play: function(frameRate, loop, killOnComplete) {
            if (typeof frameRate === "number") {
                this.delay = 1e3 / frameRate;
            }
            if (typeof loop === "boolean") {
                this.loop = loop;
            }
            if (typeof killOnComplete !== "undefined") {
                this.killOnComplete = killOnComplete;
            }
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setFrame(this.currentFrame);
            if (this._parent.__tilePattern) {
                this._parent.__tilePattern = false;
                this._parent.tilingTexture = false;
            }
            this._parent.events.onAnimationStart.dispatch(this._parent, this);
            this.onStart.dispatch(this._parent, this);
            return this;
        },
        restart: function() {
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setFrame(this.currentFrame);
            this.onStart.dispatch(this._parent, this);
        },
        setFrame: function(frameId, useLocalFrameIndex) {
            var frameIndex;
            if (typeof useLocalFrameIndex === "undefined") {
                useLocalFrameIndex = false;
            }
            if (typeof frameId === "string") {
                for (var i = 0; i < this._frames.length; i++) {
                    if (this._frameData.getFrame(this._frames[i]).name === frameId) {
                        frameIndex = i;
                    }
                }
            } else if (typeof frameId === "number") {
                if (useLocalFrameIndex) {
                    frameIndex = frameId;
                } else {
                    for (var i = 0; i < this._frames.length; i++) {
                        if (this.frames[i] === frameIndex) {
                            frameIndex = i;
                        }
                    }
                }
            }
            if (frameIndex) {
                this._frameIndex = frameIndex - 1;
                this._timeNextFrame = this.game.time.now;
                this.update();
            }
        },
        stop: function(resetFrame, dispatchComplete) {
            if (typeof resetFrame === "undefined") {
                resetFrame = false;
            }
            if (typeof dispatchComplete === "undefined") {
                dispatchComplete = false;
            }
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (resetFrame) {
                this.currentFrame = this._frameData.getFrame(this._frames[0]);
                this._parent.setFrame(this.currentFrame);
            }
            if (dispatchComplete) {
                this._parent.events.onAnimationComplete.dispatch(this._parent, this);
                this.onComplete.dispatch(this._parent, this);
            }
        },
        onPause: function() {
            if (this.isPlaying) {
                this._frameDiff = this._timeNextFrame - this.game.time.now;
            }
        },
        onResume: function() {
            if (this.isPlaying) {
                this._timeNextFrame = this.game.time.now + this._frameDiff;
            }
        },
        update: function() {
            if (this.isPaused) {
                return false;
            }
            if (this.isPlaying && this.game.time.now >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.now - this._timeNextFrame;
                this._timeLastFrame = this.game.time.now;
                if (this._frameDiff > this.delay) {
                    this._frameSkip = Math.floor(this._frameDiff / this.delay);
                    this._frameDiff -= this._frameSkip * this.delay;
                }
                this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length) {
                    if (this.loop) {
                        this._frameIndex %= this._frames.length;
                        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                        this.loopCount++;
                        this._parent.events.onAnimationLoop.dispatch(this._parent, this);
                        this.onLoop.dispatch(this._parent, this);
                    } else {
                        this.complete();
                    }
                }
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                    if (this.onUpdate) {
                        this.onUpdate.dispatch(this, this.currentFrame);
                    }
                }
                return true;
            }
            return false;
        },
        next: function(quantity) {
            if (typeof quantity === "undefined") {
                quantity = 1;
            }
            var frame = this._frameIndex + quantity;
            if (frame >= this._frames.length) {
                if (this.loop) {
                    frame %= this._frames.length;
                } else {
                    frame = this._frames.length - 1;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                }
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        },
        previous: function(quantity) {
            if (typeof quantity === "undefined") {
                quantity = 1;
            }
            var frame = this._frameIndex - quantity;
            if (frame < 0) {
                if (this.loop) {
                    frame = this._frames.length + frame;
                } else {
                    frame++;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                }
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        },
        updateFrameData: function(frameData) {
            this._frameData = frameData;
            this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
        },
        destroy: function() {
            this.game.onPause.remove(this.onPause, this);
            this.game.onResume.remove(this.onResume, this);
            this.game = null;
            this._parent = null;
            this._frames = null;
            this._frameData = null;
            this.currentFrame = null;
            this.isPlaying = false;
            this.onStart.dispose();
            this.onLoop.dispose();
            this.onComplete.dispose();
            if (this.onUpdate) {
                this.onUpdate.dispose();
            }
        },
        complete: function() {
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            this._parent.events.onAnimationComplete.dispatch(this._parent, this);
            this.onComplete.dispatch(this._parent, this);
            if (this.killOnComplete) {
                this._parent.kill();
            }
        }
    };
    Phaser.Animation.prototype.constructor = Phaser.Animation;
    Object.defineProperty(Phaser.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused;
        },
        set: function(value) {
            this.isPaused = value;
            if (value) {
                this._pauseStartTime = this.game.time.now;
            } else {
                if (this.isPlaying) {
                    this._timeNextFrame = this.game.time.now + this.delay;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length;
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frame", {
        get: function() {
            if (this.currentFrame !== null) {
                return this.currentFrame.index;
            } else {
                return this._frameIndex;
            }
        },
        set: function(value) {
            this.currentFrame = this._frameData.getFrame(this._frames[value]);
            if (this.currentFrame !== null) {
                this._frameIndex = value;
                this._parent.setFrame(this.currentFrame);
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1e3 / this.delay);
        },
        set: function(value) {
            if (value >= 1) {
                this.delay = 1e3 / value;
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "enableUpdate", {
        get: function() {
            return this.onUpdate !== null;
        },
        set: function(value) {
            if (value && this.onUpdate === null) {
                this.onUpdate = new Phaser.Signal();
            } else if (!value && this.onUpdate !== null) {
                this.onUpdate.dispose();
                this.onUpdate = null;
            }
        }
    });
    Phaser.Animation.generateFrameNames = function(prefix, start, stop, suffix, zeroPad) {
        if (typeof suffix == "undefined") {
            suffix = "";
        }
        var output = [];
        var frame = "";
        if (start < stop) {
            for (var i = start; i <= stop; i++) {
                if (typeof zeroPad == "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        } else {
            for (var i = start; i >= stop; i--) {
                if (typeof zeroPad == "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        }
        return output;
    };
    Phaser.Frame = function(index, x, y, width, height, name, uuid) {
        this.index = index;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.name = name;
        this.uuid = uuid;
        this.centerX = Math.floor(width / 2);
        this.centerY = Math.floor(height / 2);
        this.distance = Phaser.Math.distance(0, 0, width, height);
        this.rotated = false;
        this.rotationDirection = "cw";
        this.trimmed = false;
        this.sourceSizeW = width;
        this.sourceSizeH = height;
        this.spriteSourceSizeX = 0;
        this.spriteSourceSizeY = 0;
        this.spriteSourceSizeW = 0;
        this.spriteSourceSizeH = 0;
        this.right = this.x + this.width;
        this.bottom = this.y + this.height;
    };
    Phaser.Frame.prototype = {
        setTrim: function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
            this.trimmed = trimmed;
            if (trimmed) {
                this.sourceSizeW = actualWidth;
                this.sourceSizeH = actualHeight;
                this.centerX = Math.floor(actualWidth / 2);
                this.centerY = Math.floor(actualHeight / 2);
                this.spriteSourceSizeX = destX;
                this.spriteSourceSizeY = destY;
                this.spriteSourceSizeW = destWidth;
                this.spriteSourceSizeH = destHeight;
            }
        },
        clone: function() {
            var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name, this.uuid);
            for (var prop in this) {
                if (this.hasOwnProperty(prop)) {
                    output[prop] = this[prop];
                }
            }
            return output;
        },
        getRect: function(out) {
            if (typeof out === "undefined") {
                out = new Phaser.Rectangle(this.x, this.y, this.width, this.height);
            } else {
                out.setTo(this.x, this.y, this.width, this.height);
            }
            return out;
        }
    };
    Phaser.Frame.prototype.constructor = Phaser.Frame;
    Phaser.FrameData = function() {
        this._frames = [];
        this._frameNames = [];
    };
    Phaser.FrameData.prototype = {
        addFrame: function(frame) {
            frame.index = this._frames.length;
            this._frames.push(frame);
            if (frame.name !== "") {
                this._frameNames[frame.name] = frame.index;
            }
            return frame;
        },
        getFrame: function(index) {
            if (index > this._frames.length) {
                index = 0;
            }
            return this._frames[index];
        },
        getFrameByName: function(name) {
            if (typeof this._frameNames[name] === "number") {
                return this._frames[this._frameNames[name]];
            }
            return null;
        },
        checkFrameName: function(name) {
            if (this._frameNames[name] == null) {
                return false;
            }
            return true;
        },
        clone: function() {
            var output = new Phaser.FrameData();
            for (var i = 0; i < this._frames.length; i++) {
                output._frames.push(this._frames[i].clone());
            }
            for (var i = 0; i < this._frameNames.length; i++) {
                output._frameNames.push(this._frameNames[i]);
            }
            return output;
        },
        getFrameRange: function(start, end, output) {
            if (typeof output === "undefined") {
                output = [];
            }
            for (var i = start; i <= end; i++) {
                output.push(this._frames[i]);
            }
            return output;
        },
        getFrames: function(frames, useNumericIndex, output) {
            if (typeof useNumericIndex === "undefined") {
                useNumericIndex = true;
            }
            if (typeof output === "undefined") {
                output = [];
            }
            if (typeof frames === "undefined" || frames.length === 0) {
                for (var i = 0; i < this._frames.length; i++) {
                    output.push(this._frames[i]);
                }
            } else {
                for (var i = 0, len = frames.length; i < len; i++) {
                    if (useNumericIndex) {
                        output.push(this.getFrame(frames[i]));
                    } else {
                        output.push(this.getFrameByName(frames[i]));
                    }
                }
            }
            return output;
        },
        getFrameIndexes: function(frames, useNumericIndex, output) {
            if (typeof useNumericIndex === "undefined") {
                useNumericIndex = true;
            }
            if (typeof output === "undefined") {
                output = [];
            }
            if (typeof frames === "undefined" || frames.length === 0) {
                for (var i = 0, len = this._frames.length; i < len; i++) {
                    output.push(this._frames[i].index);
                }
            } else {
                for (var i = 0, len = frames.length; i < len; i++) {
                    if (useNumericIndex) {
                        output.push(frames[i]);
                    } else {
                        if (this.getFrameByName(frames[i])) {
                            output.push(this.getFrameByName(frames[i]).index);
                        }
                    }
                }
            }
            return output;
        }
    };
    Phaser.FrameData.prototype.constructor = Phaser.FrameData;
    Object.defineProperty(Phaser.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length;
        }
    });
    Phaser.AnimationParser = {
        spriteSheet: function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
            var img = game.cache.getImage(key);
            if (img == null) {
                return null;
            }
            var width = img.width;
            var height = img.height;
            if (frameWidth <= 0) {
                frameWidth = Math.floor(-width / Math.min(-1, frameWidth));
            }
            if (frameHeight <= 0) {
                frameHeight = Math.floor(-height / Math.min(-1, frameHeight));
            }
            var row = Math.floor((width - margin) / (frameWidth + spacing));
            var column = Math.floor((height - margin) / (frameHeight + spacing));
            var total = row * column;
            if (frameMax !== -1) {
                total = frameMax;
            }
            if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0) {
                console.warn("Phaser.AnimationParser.spriteSheet: '" + key + "'s width/height zero or width/height < given frameWidth/frameHeight");
                return null;
            }
            var data = new Phaser.FrameData();
            var x = margin;
            var y = margin;
            for (var i = 0; i < total; i++) {
                var uuid = game.rnd.uuid();
                data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, "", uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                    x: x,
                    y: y,
                    width: frameWidth,
                    height: frameHeight
                });
                x += frameWidth + spacing;
                if (x + frameWidth > width) {
                    x = margin;
                    y += frameHeight + spacing;
                }
            }
            return data;
        },
        JSONData: function(game, json, cacheKey) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
                var uuid = game.rnd.uuid();
                newFrame = data.addFrame(new Phaser.Frame(i, frames[i].frame.x, frames[i].frame.y, frames[i].frame.w, frames[i].frame.h, frames[i].filename, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: frames[i].frame.x,
                    y: frames[i].frame.y,
                    width: frames[i].frame.w,
                    height: frames[i].frame.h
                });
                if (frames[i].trimmed) {
                    newFrame.setTrim(frames[i].trimmed, frames[i].sourceSize.w, frames[i].sourceSize.h, frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].spriteSourceSize.w, frames[i].spriteSourceSize.h);
                }
            }
            return data;
        },
        JSONDataHash: function(game, json, cacheKey) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            var i = 0;
            for (var key in frames) {
                var uuid = game.rnd.uuid();
                newFrame = data.addFrame(new Phaser.Frame(i, frames[key].frame.x, frames[key].frame.y, frames[key].frame.w, frames[key].frame.h, key, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: frames[key].frame.x,
                    y: frames[key].frame.y,
                    width: frames[key].frame.w,
                    height: frames[key].frame.h
                });
                if (frames[key].trimmed) {
                    newFrame.setTrim(frames[key].trimmed, frames[key].sourceSize.w, frames[key].sourceSize.h, frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].spriteSourceSize.w, frames[key].spriteSourceSize.h);
                }
                i++;
            }
            return data;
        },
        XMLData: function(game, xml, cacheKey) {
            if (!xml.getElementsByTagName("TextureAtlas")) {
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                return;
            }
            var data = new Phaser.FrameData();
            var frames = xml.getElementsByTagName("SubTexture");
            var newFrame;
            var uuid;
            var name;
            var frame;
            var x;
            var y;
            var width;
            var height;
            var frameX;
            var frameY;
            var frameWidth;
            var frameHeight;
            for (var i = 0; i < frames.length; i++) {
                uuid = game.rnd.uuid();
                frame = frames[i].attributes;
                name = frame.name.nodeValue;
                x = parseInt(frame.x.nodeValue, 10);
                y = parseInt(frame.y.nodeValue, 10);
                width = parseInt(frame.width.nodeValue, 10);
                height = parseInt(frame.height.nodeValue, 10);
                frameX = null;
                frameY = null;
                if (frame.frameX) {
                    frameX = Math.abs(parseInt(frame.frameX.nodeValue, 10));
                    frameY = Math.abs(parseInt(frame.frameY.nodeValue, 10));
                    frameWidth = parseInt(frame.frameWidth.nodeValue, 10);
                    frameHeight = parseInt(frame.frameHeight.nodeValue, 10);
                }
                newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (frameX !== null || frameY !== null) {
                    newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
                }
            }
            return data;
        }
    };
    Phaser.Cache = function(game) {
        this.game = game;
        this._canvases = {};
        this._images = {};
        this._textures = {};
        this._sounds = {};
        this._text = {};
        this._json = {};
        this._physics = {};
        this._tilemaps = {};
        this._binary = {};
        this._bitmapDatas = {};
        this._bitmapFont = {};
        this.addDefaultImage();
        this.addMissingImage();
        this.onSoundUnlock = new Phaser.Signal();
        this._cacheMap = [];
        this._cacheMap[Phaser.Cache.CANVAS] = this._canvases;
        this._cacheMap[Phaser.Cache.IMAGE] = this._images;
        this._cacheMap[Phaser.Cache.TEXTURE] = this._textures;
        this._cacheMap[Phaser.Cache.SOUND] = this._sounds;
        this._cacheMap[Phaser.Cache.TEXT] = this._text;
        this._cacheMap[Phaser.Cache.PHYSICS] = this._physics;
        this._cacheMap[Phaser.Cache.TILEMAP] = this._tilemaps;
        this._cacheMap[Phaser.Cache.BINARY] = this._binary;
        this._cacheMap[Phaser.Cache.BITMAPDATA] = this._bitmapDatas;
        this._cacheMap[Phaser.Cache.BITMAPFONT] = this._bitmapFont;
        this._cacheMap[Phaser.Cache.JSON] = this._json;
    };
    Phaser.Cache.CANVAS = 1;
    Phaser.Cache.IMAGE = 2;
    Phaser.Cache.TEXTURE = 3;
    Phaser.Cache.SOUND = 4;
    Phaser.Cache.TEXT = 5;
    Phaser.Cache.PHYSICS = 6;
    Phaser.Cache.TILEMAP = 7;
    Phaser.Cache.BINARY = 8;
    Phaser.Cache.BITMAPDATA = 9;
    Phaser.Cache.BITMAPFONT = 10;
    Phaser.Cache.JSON = 11;
    Phaser.Cache.prototype = {
        addCanvas: function(key, canvas, context) {
            this._canvases[key] = {
                canvas: canvas,
                context: context
            };
        },
        addBinary: function(key, binaryData) {
            this._binary[key] = binaryData;
        },
        addBitmapData: function(key, bitmapData) {
            this._bitmapDatas[key] = bitmapData;
            return bitmapData;
        },
        addRenderTexture: function(key, texture) {
            var frame = new Phaser.Frame(0, 0, 0, texture.width, texture.height, "", "");
            this._textures[key] = {
                texture: texture,
                frame: frame
            };
        },
        addSpriteSheet: function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
            this._images[key] = {
                url: url,
                data: data,
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                margin: margin,
                spacing: spacing
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            this._images[key].frameData = Phaser.AnimationParser.spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing);
        },
        addTilemap: function(key, url, mapData, format) {
            this._tilemaps[key] = {
                url: url,
                data: mapData,
                format: format
            };
        },
        addTextureAtlas: function(key, url, data, atlasData, format) {
            this._images[key] = {
                url: url,
                data: data
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY) {
                this._images[key].frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key);
            } else if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) {
                this._images[key].frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key);
            } else if (format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                this._images[key].frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key);
            }
        },
        addBitmapFont: function(key, url, data, xmlData, xSpacing, ySpacing) {
            this._images[key] = {
                url: url,
                data: data
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            Phaser.LoaderParser.bitmapFont(this.game, xmlData, key, xSpacing, ySpacing);
            this._bitmapFont[key] = PIXI.BitmapText.fonts[key];
        },
        addPhysicsData: function(key, url, JSONData, format) {
            this._physics[key] = {
                url: url,
                data: JSONData,
                format: format
            };
        },
        addDefaultImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            this._images["__default"] = {
                url: null,
                data: img
            };
            this._images["__default"].frame = new Phaser.Frame(0, 0, 0, 32, 32, "", "");
            this._images["__default"].frameData = new Phaser.FrameData();
            this._images["__default"].frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid()));
            PIXI.BaseTextureCache["__default"] = new PIXI.BaseTexture(img);
            PIXI.TextureCache["__default"] = new PIXI.Texture(PIXI.BaseTextureCache["__default"]);
        },
        addMissingImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            this._images["__missing"] = {
                url: null,
                data: img
            };
            this._images["__missing"].frame = new Phaser.Frame(0, 0, 0, 32, 32, "", "");
            this._images["__missing"].frameData = new Phaser.FrameData();
            this._images["__missing"].frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid()));
            PIXI.BaseTextureCache["__missing"] = new PIXI.BaseTexture(img);
            PIXI.TextureCache["__missing"] = new PIXI.Texture(PIXI.BaseTextureCache["__missing"]);
        },
        addText: function(key, url, data) {
            this._text[key] = {
                url: url,
                data: data
            };
        },
        addJSON: function(key, url, data) {
            this._json[key] = {
                url: url,
                data: data
            };
        },
        addImage: function(key, url, data) {
            this._images[key] = {
                url: url,
                data: data
            };
            this._images[key].frame = new Phaser.Frame(0, 0, 0, data.width, data.height, key, this.game.rnd.uuid());
            this._images[key].frameData = new Phaser.FrameData();
            this._images[key].frameData.addFrame(new Phaser.Frame(0, 0, 0, data.width, data.height, url, this.game.rnd.uuid()));
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
        },
        addSound: function(key, url, data, webAudio, audioTag) {
            webAudio = webAudio || true;
            audioTag = audioTag || false;
            var decoded = false;
            if (audioTag) {
                decoded = true;
            }
            this._sounds[key] = {
                url: url,
                data: data,
                isDecoding: false,
                decoded: decoded,
                webAudio: webAudio,
                audioTag: audioTag,
                locked: this.game.sound.touchLocked
            };
        },
        reloadSound: function(key) {
            var _this = this;
            if (this._sounds[key]) {
                this._sounds[key].data.src = this._sounds[key].url;
                this._sounds[key].data.addEventListener("canplaythrough", function() {
                    return _this.reloadSoundComplete(key);
                }, false);
                this._sounds[key].data.load();
            }
        },
        reloadSoundComplete: function(key) {
            if (this._sounds[key]) {
                this._sounds[key].locked = false;
                this.onSoundUnlock.dispatch(key);
            }
        },
        updateSound: function(key, property, value) {
            if (this._sounds[key]) {
                this._sounds[key][property] = value;
            }
        },
        decodedSound: function(key, data) {
            this._sounds[key].data = data;
            this._sounds[key].decoded = true;
            this._sounds[key].isDecoding = false;
        },
        getCanvas: function(key) {
            if (this._canvases[key]) {
                return this._canvases[key].canvas;
            } else {
                console.warn('Phaser.Cache.getCanvas: Invalid key: "' + key + '"');
            }
        },
        getBitmapData: function(key) {
            if (this._bitmapDatas[key]) {
                return this._bitmapDatas[key];
            } else {
                console.warn('Phaser.Cache.getBitmapData: Invalid key: "' + key + '"');
            }
        },
        getBitmapFont: function(key) {
            if (this._bitmapFont[key]) {
                return this._bitmapFont[key];
            } else {
                console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + key + '"');
            }
        },
        getPhysicsData: function(key, object, fixtureKey) {
            if (typeof object === "undefined" || object === null) {
                if (this._physics[key]) {
                    return this._physics[key].data;
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + key + '"');
                }
            } else {
                if (this._physics[key] && this._physics[key].data[object]) {
                    var fixtures = this._physics[key].data[object];
                    if (fixtures && fixtureKey) {
                        for (var fixture in fixtures) {
                            fixture = fixtures[fixture];
                            if (fixture.fixtureKey === fixtureKey) {
                                return fixture;
                            }
                        }
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + fixtureKey + " in " + key + '"');
                    } else {
                        return fixtures;
                    }
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + key + " / " + object + '"');
                }
            }
            return null;
        },
        checkKey: function(type, key) {
            if (this._cacheMap[type][key]) {
                return true;
            }
            return false;
        },
        checkCanvasKey: function(key) {
            return this.checkKey(Phaser.Cache.CANVAS, key);
        },
        checkImageKey: function(key) {
            return this.checkKey(Phaser.Cache.IMAGE, key);
        },
        checkTextureKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXTURE, key);
        },
        checkSoundKey: function(key) {
            return this.checkKey(Phaser.Cache.SOUND, key);
        },
        checkTextKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXT, key);
        },
        checkPhysicsKey: function(key) {
            return this.checkKey(Phaser.Cache.PHYSICS, key);
        },
        checkTilemapKey: function(key) {
            return this.checkKey(Phaser.Cache.TILEMAP, key);
        },
        checkBinaryKey: function(key) {
            return this.checkKey(Phaser.Cache.BINARY, key);
        },
        checkBitmapDataKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPDATA, key);
        },
        checkBitmapFontKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPFONT, key);
        },
        checkJSONKey: function(key) {
            return this.checkKey(Phaser.Cache.JSON, key);
        },
        getImage: function(key) {
            if (this._images[key]) {
                return this._images[key].data;
            } else {
                console.warn('Phaser.Cache.getImage: Invalid key: "' + key + '"');
                return null;
            }
        },
        getTilemapData: function(key) {
            if (this._tilemaps[key]) {
                return this._tilemaps[key];
            } else {
                console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + key + '"');
            }
        },
        getFrameData: function(key) {
            if (this._images[key]) {
                return this._images[key].frameData;
            }
            return null;
        },
        updateFrameData: function(key, frameData) {
            if (this._images[key]) {
                this._images[key].frameData = frameData;
            }
        },
        getFrameByIndex: function(key, frame) {
            if (this._images[key]) {
                return this._images[key].frameData.getFrame(frame);
            }
            return null;
        },
        getFrameByName: function(key, frame) {
            if (this._images[key]) {
                return this._images[key].frameData.getFrameByName(frame);
            }
            return null;
        },
        getFrame: function(key) {
            if (this._images[key]) {
                return this._images[key].frame;
            }
            return null;
        },
        getTextureFrame: function(key) {
            if (this._textures[key]) {
                return this._textures[key].frame;
            }
            return null;
        },
        getTexture: function(key) {
            if (this._textures[key]) {
                return this._textures[key];
            } else {
                console.warn('Phaser.Cache.getTexture: Invalid key: "' + key + '"');
            }
        },
        getSound: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key];
            } else {
                console.warn('Phaser.Cache.getSound: Invalid key: "' + key + '"');
            }
        },
        getSoundData: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key].data;
            } else {
                console.warn('Phaser.Cache.getSoundData: Invalid key: "' + key + '"');
            }
        },
        isSoundDecoded: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key].decoded;
            }
        },
        isSoundReady: function(key) {
            return this._sounds[key] && this._sounds[key].decoded && this.game.sound.touchLocked === false;
        },
        getFrameCount: function(key) {
            if (this._images[key]) {
                return this._images[key].frameData.total;
            }
            return 0;
        },
        getText: function(key) {
            if (this._text[key]) {
                return this._text[key].data;
            } else {
                console.warn('Phaser.Cache.getText: Invalid key: "' + key + '"');
            }
        },
        getJSON: function(key) {
            if (this._json[key]) {
                return this._json[key].data;
            } else {
                console.warn('Phaser.Cache.getJSON: Invalid key: "' + key + '"');
            }
        },
        getBinary: function(key) {
            if (this._binary[key]) {
                return this._binary[key];
            } else {
                console.warn('Phaser.Cache.getBinary: Invalid key: "' + key + '"');
            }
        },
        getKeys: function(type) {
            var array = null;
            switch (type) {
              case Phaser.Cache.CANVAS:
                array = this._canvases;
                break;

              case Phaser.Cache.IMAGE:
                array = this._images;
                break;

              case Phaser.Cache.TEXTURE:
                array = this._textures;
                break;

              case Phaser.Cache.SOUND:
                array = this._sounds;
                break;

              case Phaser.Cache.TEXT:
                array = this._text;
                break;

              case Phaser.Cache.PHYSICS:
                array = this._physics;
                break;

              case Phaser.Cache.TILEMAP:
                array = this._tilemaps;
                break;

              case Phaser.Cache.BINARY:
                array = this._binary;
                break;

              case Phaser.Cache.BITMAPDATA:
                array = this._bitmapDatas;
                break;

              case Phaser.Cache.BITMAPFONT:
                array = this._bitmapFont;
                break;

              case Phaser.Cache.JSON:
                array = this._json;
                break;
            }
            if (!array) {
                return;
            }
            var output = [];
            for (var item in array) {
                if (item !== "__default" && item !== "__missing") {
                    output.push(item);
                }
            }
            return output;
        },
        removeCanvas: function(key) {
            delete this._canvases[key];
        },
        removeImage: function(key) {
            delete this._images[key];
        },
        removeSound: function(key) {
            delete this._sounds[key];
        },
        removeText: function(key) {
            delete this._text[key];
        },
        removeJSON: function(key) {
            delete this._json[key];
        },
        removePhysics: function(key) {
            delete this._physics[key];
        },
        removeTilemap: function(key) {
            delete this._tilemaps[key];
        },
        removeBinary: function(key) {
            delete this._binary[key];
        },
        removeBitmapData: function(key) {
            delete this._bitmapDatas[key];
        },
        removeBitmapFont: function(key) {
            delete this._bitmapFont[key];
        },
        destroy: function() {
            for (var item in this._canvases) {
                delete this._canvases[item];
            }
            for (var item in this._images) {
                if (item !== "__default" && item !== "__missing") {
                    delete this._images[item];
                }
            }
            for (var item in this._sounds) {
                delete this._sounds[item];
            }
            for (var item in this._text) {
                delete this._text[item];
            }
            for (var item in this._json) {
                delete this._json[item];
            }
            for (var item in this._textures) {
                delete this._textures[item];
            }
            for (var item in this._physics) {
                delete this._physics[item];
            }
            for (var item in this._tilemaps) {
                delete this._tilemaps[item];
            }
            for (var item in this._binary) {
                delete this._binary[item];
            }
            for (var item in this._bitmapDatas) {
                delete this._bitmapDatas[item];
            }
            for (var item in this._bitmapFont) {
                delete this._bitmapFont[item];
            }
        }
    };
    Phaser.Cache.prototype.constructor = Phaser.Cache;
    Phaser.Loader = function(game) {
        this.game = game;
        this.isLoading = false;
        this.hasLoaded = false;
        this.progress = 0;
        this.progressFloat = 0;
        this.preloadSprite = null;
        this.crossOrigin = false;
        this.baseURL = "";
        this.onLoadStart = new Phaser.Signal();
        this.onFileStart = new Phaser.Signal();
        this.onFileComplete = new Phaser.Signal();
        this.onFileError = new Phaser.Signal();
        this.onLoadComplete = new Phaser.Signal();
        this.onPackComplete = new Phaser.Signal();
        this.useXDomainRequest = this.game.device.ieVersion === 9;
        this._packList = [];
        this._packIndex = 0;
        this._fileList = [];
        this._fileIndex = 0;
        this._progressChunk = 0;
        this._xhr = new XMLHttpRequest();
        this._ajax = null;
    };
    Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    Phaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    Phaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    Phaser.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    Phaser.Loader.PHYSICS_PHASER_JSON = 4;
    Phaser.Loader.prototype = {
        setPreloadSprite: function(sprite, direction) {
            direction = direction || 0;
            this.preloadSprite = {
                sprite: sprite,
                direction: direction,
                width: sprite.width,
                height: sprite.height,
                rect: null
            };
            if (direction === 0) {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, 1, sprite.height);
            } else {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, sprite.width, 1);
            }
            sprite.crop(this.preloadSprite.rect);
            sprite.visible = true;
        },
        checkKeyExists: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return true;
                    }
                }
            }
            return false;
        },
        getAssetIndex: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return i;
                    }
                }
            }
            return -1;
        },
        getAsset: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return {
                            index: i,
                            file: this._fileList[i]
                        };
                    }
                }
            }
            return false;
        },
        reset: function() {
            this.preloadSprite = null;
            this.isLoading = false;
            this._packList.length = 0;
            this._packIndex = 0;
            this._fileList.length = 0;
            this._fileIndex = 0;
        },
        addToFileList: function(type, key, url, properties) {
            var entry = {
                type: type,
                key: key,
                url: url,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof properties !== "undefined") {
                for (var prop in properties) {
                    entry[prop] = properties[prop];
                }
            }
            if (this.checkKeyExists(type, key) === false) {
                this._fileList.push(entry);
            }
        },
        replaceInFileList: function(type, key, url, properties) {
            var entry = {
                type: type,
                key: key,
                url: url,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof properties !== "undefined") {
                for (var prop in properties) {
                    entry[prop] = properties[prop];
                }
            }
            var index = this.getAssetIndex(type, key);
            if (index === -1) {
                this._fileList.push(entry);
            } else {
                this._fileList[index] = entry;
            }
        },
        pack: function(key, url, data, callbackContext) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof callbackContext === "undefined") {
                callbackContext = this;
            }
            if (url === null && data === null) {
                console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
            }
            this._packList.push({
                key: key,
                url: url,
                data: data,
                loaded: false,
                error: false,
                callbackContext: callbackContext
            });
            return this;
        },
        image: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("image", key, url);
            } else {
                this.addToFileList("image", key, url);
            }
            return this;
        },
        text: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("text", key, url);
            } else {
                this.addToFileList("text", key, url);
            }
            return this;
        },
        json: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("json", key, url);
            } else {
                this.addToFileList("json", key, url);
            }
            return this;
        },
        script: function(key, url, callback, callbackContext) {
            if (typeof callback === "undefined") {
                callback = false;
            }
            if (callback !== false && typeof callbackContext === "undefined") {
                callbackContext = callback;
            }
            this.addToFileList("script", key, url, {
                callback: callback,
                callbackContext: callbackContext
            });
            return this;
        },
        binary: function(key, url, callback, callbackContext) {
            if (typeof callback === "undefined") {
                callback = false;
            }
            if (callback !== false && typeof callbackContext === "undefined") {
                callbackContext = callback;
            }
            this.addToFileList("binary", key, url, {
                callback: callback,
                callbackContext: callbackContext
            });
            return this;
        },
        spritesheet: function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
            if (typeof frameMax === "undefined") {
                frameMax = -1;
            }
            if (typeof margin === "undefined") {
                margin = 0;
            }
            if (typeof spacing === "undefined") {
                spacing = 0;
            }
            this.addToFileList("spritesheet", key, url, {
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                frameMax: frameMax,
                margin: margin,
                spacing: spacing
            });
            return this;
        },
        audio: function(key, urls, autoDecode) {
            if (typeof autoDecode === "undefined") {
                autoDecode = true;
            }
            this.addToFileList("audio", key, urls, {
                buffer: null,
                autoDecode: autoDecode
            });
            return this;
        },
        tilemap: function(key, url, data, format) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Tilemap.CSV;
            }
            if (url == null && data == null) {
                console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                switch (format) {
                  case Phaser.Tilemap.CSV:
                    break;

                  case Phaser.Tilemap.TILED_JSON:
                    if (typeof data === "string") {
                        data = JSON.parse(data);
                    }
                    break;
                }
                this.game.cache.addTilemap(key, null, data, format);
            } else {
                this.addToFileList("tilemap", key, url, {
                    format: format
                });
            }
            return this;
        },
        physics: function(key, url, data, format) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Physics.LIME_CORONA_JSON;
            }
            if (url == null && data == null) {
                console.warn("Phaser.Loader.physics - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
                this.game.cache.addPhysicsData(key, null, data, format);
            } else {
                this.addToFileList("physics", key, url, {
                    format: format
                });
            }
            return this;
        },
        bitmapFont: function(key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {
            if (typeof xmlURL === "undefined") {
                xmlURL = null;
            }
            if (typeof xmlData === "undefined") {
                xmlData = null;
            }
            if (typeof xSpacing === "undefined") {
                xSpacing = 0;
            }
            if (typeof ySpacing === "undefined") {
                ySpacing = 0;
            }
            if (xmlURL) {
                this.addToFileList("bitmapfont", key, textureURL, {
                    xmlURL: xmlURL,
                    xSpacing: xSpacing,
                    ySpacing: ySpacing
                });
            } else {
                if (typeof xmlData === "string") {
                    var xml;
                    try {
                        if (window["DOMParser"]) {
                            var domparser = new DOMParser();
                            xml = domparser.parseFromString(xmlData, "text/xml");
                        } else {
                            xml = new ActiveXObject("Microsoft.XMLDOM");
                            xml.async = "false";
                            xml.loadXML(xmlData);
                        }
                    } catch (e) {
                        xml = undefined;
                    }
                    if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                        throw new Error("Phaser.Loader. Invalid Bitmap Font XML given");
                    } else {
                        this.addToFileList("bitmapfont", key, textureURL, {
                            xmlURL: null,
                            xmlData: xml,
                            xSpacing: xSpacing,
                            ySpacing: ySpacing
                        });
                    }
                }
            }
            return this;
        },
        atlasJSONArray: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function(key, textureURL, atlasURL, atlasData, format) {
            if (typeof atlasURL === "undefined") {
                atlasURL = null;
            }
            if (typeof atlasData === "undefined") {
                atlasData = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY;
            }
            if (atlasURL) {
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: atlasURL,
                    format: format
                });
            } else {
                switch (format) {
                  case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    if (typeof atlasData === "string") {
                        atlasData = JSON.parse(atlasData);
                    }
                    break;

                  case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if (typeof atlasData === "string") {
                        var xml;
                        try {
                            if (window["DOMParser"]) {
                                var domparser = new DOMParser();
                                xml = domparser.parseFromString(atlasData, "text/xml");
                            } else {
                                xml = new ActiveXObject("Microsoft.XMLDOM");
                                xml.async = "false";
                                xml.loadXML(atlasData);
                            }
                        } catch (e) {
                            xml = undefined;
                        }
                        if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                            throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        } else {
                            atlasData = xml;
                        }
                    }
                    break;
                }
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: null,
                    atlasData: atlasData,
                    format: format
                });
            }
            return this;
        },
        removeFile: function(type, key) {
            var file = this.getAsset(type, key);
            if (file !== false) {
                this._fileList.splice(file.index, 1);
            }
        },
        removeAll: function() {
            this._fileList.length = 0;
        },
        start: function() {
            if (this.isLoading) {
                return;
            }
            if (this._packList.length > 0) {
                this._packIndex = 0;
                this.loadPack();
            } else {
                this.beginLoad();
            }
        },
        beginLoad: function() {
            this.progress = 0;
            this.progressFloat = 0;
            this.hasLoaded = false;
            this.isLoading = true;
            this.onLoadStart.dispatch(this._fileList.length);
            if (this._fileList.length > 0) {
                this._fileIndex = 0;
                this._progressChunk = 100 / this._fileList.length;
                this.loadFile();
            } else {
                this.progress = 100;
                this.progressFloat = 100;
                this.hasLoaded = true;
                this.isLoading = false;
                this.onLoadComplete.dispatch();
            }
        },
        loadPack: function() {
            if (!this._packList[this._packIndex]) {
                console.warn("Phaser.Loader loadPackList invalid index " + this._packIndex);
                return;
            }
            var pack = this._packList[this._packIndex];
            if (pack.data !== null) {
                this.packLoadComplete(this._packIndex, false);
            } else {
                this.xhrLoad(this._packIndex, this.baseURL + pack.url, "text", "packLoadComplete", "packLoadError");
            }
        },
        packLoadComplete: function(index, parse) {
            if (typeof parse === "undefined") {
                parse = true;
            }
            if (!this._packList[index]) {
                console.warn("Phaser.Loader packLoadComplete invalid index " + index);
                return;
            }
            var pack = this._packList[index];
            pack.loaded = true;
            if (parse) {
                var data = JSON.parse(this._xhr.responseText);
            } else {
                var data = this._packList[index].data;
            }
            if (data[pack.key]) {
                var file;
                for (var i = 0; i < data[pack.key].length; i++) {
                    file = data[pack.key][i];
                    switch (file.type) {
                      case "image":
                        this.image(file.key, file.url, file.overwrite);
                        break;

                      case "text":
                        this.text(file.key, file.url, file.overwrite);
                        break;

                      case "json":
                        this.json(file.key, file.url, file.overwrite);
                        break;

                      case "script":
                        this.script(file.key, file.url, file.callback, pack.callbackContext);
                        break;

                      case "binary":
                        this.binary(file.key, file.url, file.callback, pack.callbackContext);
                        break;

                      case "spritesheet":
                        this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                        break;

                      case "audio":
                        this.audio(file.key, file.urls, file.autoDecode);
                        break;

                      case "tilemap":
                        this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);
                        break;

                      case "physics":
                        this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);
                        break;

                      case "bitmapFont":
                        this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.xmlData, file.xSpacing, file.ySpacing);
                        break;

                      case "atlasJSONArray":
                        this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlasJSONHash":
                        this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlasXML":
                        this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlas":
                        this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);
                        break;
                    }
                }
            }
            this.nextPack(index, true);
        },
        packError: function(index) {
            this._packList[index].loaded = true;
            this._packList[index].error = true;
            this.onFileError.dispatch(this._packList[index].key, this._packList[index]);
            console.warn("Phaser.Loader error loading pack file: " + this._packList[index].key + " from URL " + this._packList[index].url);
            this.nextPack(index, false);
        },
        nextPack: function(index, success) {
            this.onPackComplete.dispatch(this._packList[index].key, success, this.totalLoadedPacks(), this._packList.length);
            this._packIndex++;
            if (this._packIndex < this._packList.length) {
                this.loadPack();
            } else {
                this.beginLoad();
            }
        },
        loadFile: function() {
            if (!this._fileList[this._fileIndex]) {
                console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex);
                return;
            }
            var file = this._fileList[this._fileIndex];
            var _this = this;
            this.onFileStart.dispatch(this.progress, file.key);
            switch (file.type) {
              case "image":
              case "spritesheet":
              case "textureatlas":
              case "bitmapfont":
                file.data = new Image();
                file.data.name = file.key;
                file.data.onload = function() {
                    return _this.fileComplete(_this._fileIndex);
                };
                file.data.onerror = function() {
                    return _this.fileError(_this._fileIndex);
                };
                if (this.crossOrigin) {
                    file.data.crossOrigin = this.crossOrigin;
                }
                file.data.src = this.baseURL + file.url;
                break;

              case "audio":
                file.url = this.getAudioURL(file.url);
                if (file.url !== null) {
                    if (this.game.sound.usingWebAudio) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError");
                    } else if (this.game.sound.usingAudioTag) {
                        if (this.game.sound.touchLocked) {
                            file.data = new Audio();
                            file.data.name = file.key;
                            file.data.preload = "auto";
                            file.data.src = this.baseURL + file.url;
                            this.fileComplete(this._fileIndex);
                        } else {
                            file.data = new Audio();
                            file.data.name = file.key;
                            file.data.onerror = function() {
                                return _this.fileError(_this._fileIndex);
                            };
                            file.data.preload = "auto";
                            file.data.src = this.baseURL + file.url;
                            file.data.addEventListener("canplaythrough", Phaser.GAMES[this.game.id].load.fileComplete(this._fileIndex), false);
                            file.data.load();
                        }
                    }
                } else {
                    this.fileError(this._fileIndex);
                }
                break;

              case "json":
                if (this.useXDomainRequest && window.XDomainRequest) {
                    this._ajax = new window.XDomainRequest();
                    this._ajax.timeout = 3e3;
                    this._ajax.onerror = function() {
                        return _this.dataLoadError(_this._fileIndex);
                    };
                    this._ajax.ontimeout = function() {
                        return _this.dataLoadError(_this._fileIndex);
                    };
                    this._ajax.onprogress = function() {};
                    this._ajax.onload = function() {
                        return _this.jsonLoadComplete(_this._fileIndex);
                    };
                    this._ajax.open("GET", this.baseURL + file.url, true);
                    setTimeout(function() {
                        this._ajax.send();
                    }, 0);
                } else {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError");
                }
                break;

              case "tilemap":
                if (file.format === Phaser.Tilemap.TILED_JSON) {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError");
                } else if (file.format === Phaser.Tilemap.CSV) {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "csvLoadComplete", "dataLoadError");
                } else {
                    throw new Error("Phaser.Loader. Invalid Tilemap format: " + file.format);
                }
                break;

              case "text":
              case "script":
              case "physics":
                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "fileComplete", "fileError");
                break;

              case "binary":
                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError");
                break;
            }
        },
        xhrLoad: function(index, url, type, onload, onerror) {
            this._xhr.open("GET", url, true);
            this._xhr.responseType = type;
            var _this = this;
            this._xhr.onload = function() {
                return _this[onload](index);
            };
            this._xhr.onerror = function() {
                return _this[onerror](index);
            };
            this._xhr.send();
        },
        getAudioURL: function(urls) {
            var extension;
            if (typeof urls === "string") {
                urls = [ urls ];
            }
            for (var i = 0; i < urls.length; i++) {
                extension = urls[i].toLowerCase();
                extension = extension.substr((Math.max(0, extension.lastIndexOf(".")) || Infinity) + 1);
                if (this.game.device.canPlayAudio(extension)) {
                    return urls[i];
                }
            }
            return null;
        },
        fileError: function(index) {
            this._fileList[index].loaded = true;
            this._fileList[index].error = true;
            this.onFileError.dispatch(this._fileList[index].key, this._fileList[index]);
            console.warn("Phaser.Loader error loading file: " + this._fileList[index].key + " from URL " + this._fileList[index].url);
            this.nextFile(index, false);
        },
        fileComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader fileComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            file.loaded = true;
            var loadNext = true;
            switch (file.type) {
              case "image":
                this.game.cache.addImage(file.key, file.url, file.data);
                break;

              case "spritesheet":
                this.game.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                break;

              case "textureatlas":
                if (file.atlasURL == null) {
                    this.game.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format);
                } else {
                    loadNext = false;
                    if (file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "jsonLoadComplete", "dataLoadError");
                    } else if (file.format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "xmlLoadComplete", "dataLoadError");
                    } else {
                        throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + file.format);
                    }
                }
                break;

              case "bitmapfont":
                if (file.xmlURL == null) {
                    this.game.cache.addBitmapFont(file.key, file.url, file.data, file.xmlData, file.xSpacing, file.ySpacing);
                } else {
                    loadNext = false;
                    this.xhrLoad(this._fileIndex, this.baseURL + file.xmlURL, "text", "xmlLoadComplete", "dataLoadError");
                }
                break;

              case "audio":
                if (this.game.sound.usingWebAudio) {
                    file.data = this._xhr.response;
                    this.game.cache.addSound(file.key, file.url, file.data, true, false);
                    if (file.autoDecode) {
                        var that = this;
                        var key = file.key;
                        this.game.cache.updateSound(key, "isDecoding", true);
                        this.game.sound.context.decodeAudioData(file.data, function(buffer) {
                            if (buffer) {
                                that.game.cache.decodedSound(key, buffer);
                                that.game.sound.onSoundDecode.dispatch(key, that.game.cache.getSound(key));
                            }
                        });
                    }
                } else {
                    file.data.removeEventListener("canplaythrough", Phaser.GAMES[this.game.id].load.fileComplete);
                    this.game.cache.addSound(file.key, file.url, file.data, false, true);
                }
                break;

              case "text":
                file.data = this._xhr.responseText;
                this.game.cache.addText(file.key, file.url, file.data);
                break;

              case "physics":
                var data = JSON.parse(this._xhr.responseText);
                this.game.cache.addPhysicsData(file.key, file.url, data, file.format);
                break;

              case "script":
                file.data = document.createElement("script");
                file.data.language = "javascript";
                file.data.type = "text/javascript";
                file.data.defer = false;
                file.data.text = this._xhr.responseText;
                document.head.appendChild(file.data);
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.responseText);
                }
                break;

              case "binary":
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.response);
                } else {
                    file.data = this._xhr.response;
                }
                this.game.cache.addBinary(file.key, file.data);
                break;
            }
            if (loadNext) {
                this.nextFile(index, true);
            }
        },
        jsonLoadComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader jsonLoadComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            if (this._ajax && this._ajax.responseText) {
                var data = JSON.parse(this._ajax.responseText);
            } else {
                var data = JSON.parse(this._xhr.responseText);
            }
            file.loaded = true;
            if (file.type === "tilemap") {
                this.game.cache.addTilemap(file.key, file.url, data, file.format);
            } else if (file.type === "json") {
                this.game.cache.addJSON(file.key, file.url, data);
            } else {
                this.game.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);
            }
            this.nextFile(index, true);
        },
        csvLoadComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader csvLoadComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            var data = this._xhr.responseText;
            file.loaded = true;
            this.game.cache.addTilemap(file.key, file.url, data, file.format);
            this.nextFile(index, true);
        },
        dataLoadError: function(index) {
            var file = this._fileList[index];
            file.loaded = true;
            file.error = true;
            console.warn("Phaser.Loader dataLoadError: " + file.key);
            this.nextFile(index, true);
        },
        xmlLoadComplete: function(index) {
            var data = this._xhr.responseText;
            var xml;
            try {
                if (window["DOMParser"]) {
                    var domparser = new DOMParser();
                    xml = domparser.parseFromString(data, "text/xml");
                } else {
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = undefined;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                throw new Error("Phaser.Loader. Invalid XML given");
            }
            var file = this._fileList[index];
            file.loaded = true;
            if (file.type == "bitmapfont") {
                this.game.cache.addBitmapFont(file.key, file.url, file.data, xml, file.xSpacing, file.ySpacing);
            } else if (file.type == "textureatlas") {
                this.game.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);
            }
            this.nextFile(index, true);
        },
        nextFile: function(previousIndex, success) {
            this.progressFloat += this._progressChunk;
            this.progress = Math.round(this.progressFloat);
            if (this.progress > 100) {
                this.progress = 100;
            }
            if (this.preloadSprite !== null) {
                if (this.preloadSprite.direction === 0) {
                    this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
                } else {
                    this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
                }
                this.preloadSprite.sprite.updateCrop();
            }
            this.onFileComplete.dispatch(this.progress, this._fileList[previousIndex].key, success, this.totalLoadedFiles(), this._fileList.length);
            if (this.totalQueuedFiles() > 0) {
                this._fileIndex++;
                this.loadFile();
            } else {
                this.hasLoaded = true;
                this.isLoading = false;
                this.removeAll();
                this.onLoadComplete.dispatch();
            }
        },
        totalLoadedFiles: function() {
            var total = 0;
            for (var i = 0; i < this._fileList.length; i++) {
                if (this._fileList[i].loaded) {
                    total++;
                }
            }
            return total;
        },
        totalQueuedFiles: function() {
            var total = 0;
            for (var i = 0; i < this._fileList.length; i++) {
                if (this._fileList[i].loaded === false) {
                    total++;
                }
            }
            return total;
        },
        totalLoadedPacks: function() {
            var total = 0;
            for (var i = 0; i < this._packList.length; i++) {
                if (this._packList[i].loaded) {
                    total++;
                }
            }
            return total;
        },
        totalQueuedPacks: function() {
            var total = 0;
            for (var i = 0; i < this._packList.length; i++) {
                if (this._packList[i].loaded === false) {
                    total++;
                }
            }
            return total;
        }
    };
    Phaser.Loader.prototype.constructor = Phaser.Loader;
    Phaser.LoaderParser = {
        bitmapFont: function(game, xml, cacheKey, xSpacing, ySpacing) {
            var data = {};
            var info = xml.getElementsByTagName("info")[0];
            var common = xml.getElementsByTagName("common")[0];
            data.font = info.getAttribute("face");
            data.size = parseInt(info.getAttribute("size"), 10);
            data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10) + ySpacing;
            data.chars = {};
            var letters = xml.getElementsByTagName("char");
            for (var i = 0; i < letters.length; i++) {
                var charCode = parseInt(letters[i].getAttribute("id"), 10);
                var textureRect = new PIXI.Rectangle(parseInt(letters[i].getAttribute("x"), 10), parseInt(letters[i].getAttribute("y"), 10), parseInt(letters[i].getAttribute("width"), 10), parseInt(letters[i].getAttribute("height"), 10));
                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute("xoffset"), 10),
                    yOffset: parseInt(letters[i].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10) + xSpacing,
                    kerning: {},
                    texture: PIXI.TextureCache[cacheKey] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], textureRect)
                };
            }
            var kernings = xml.getElementsByTagName("kerning");
            for (i = 0; i < kernings.length; i++) {
                var first = parseInt(kernings[i].getAttribute("first"), 10);
                var second = parseInt(kernings[i].getAttribute("second"), 10);
                var amount = parseInt(kernings[i].getAttribute("amount"), 10);
                data.chars[second].kerning[first] = amount;
            }
            PIXI.BitmapText.fonts[cacheKey] = data;
        }
    };
    Phaser.Sound = function(game, key, volume, loop, connect) {
        if (typeof volume == "undefined") {
            volume = 1;
        }
        if (typeof loop == "undefined") {
            loop = false;
        }
        if (typeof connect === "undefined") {
            connect = game.sound.connectToMaster;
        }
        this.game = game;
        this.name = key;
        this.key = key;
        this.loop = loop;
        this.volume = volume;
        this.markers = {};
        this.context = null;
        this.autoplay = false;
        this.totalDuration = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.duration = 0;
        this.durationMS = 0;
        this.position = 0;
        this.stopTime = 0;
        this.paused = false;
        this.pausedPosition = 0;
        this.pausedTime = 0;
        this.isPlaying = false;
        this.currentMarker = "";
        this.pendingPlayback = false;
        this.override = false;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        this.externalNode = null;
        this.masterGainNode = null;
        this.gainNode = null;
        if (this.usingWebAudio) {
            this.context = this.game.sound.context;
            this.masterGainNode = this.game.sound.masterGain;
            if (typeof this.context.createGain === "undefined") {
                this.gainNode = this.context.createGainNode();
            } else {
                this.gainNode = this.context.createGain();
            }
            this.gainNode.gain.value = volume * this.game.sound.volume;
            if (connect) {
                this.gainNode.connect(this.masterGainNode);
            }
        } else {
            if (this.game.cache.getSound(key) && this.game.cache.isSoundReady(key)) {
                this._sound = this.game.cache.getSoundData(key);
                this.totalDuration = 0;
                if (this._sound.duration) {
                    this.totalDuration = this._sound.duration;
                }
            } else {
                this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
            }
        }
        this.onDecoded = new Phaser.Signal();
        this.onPlay = new Phaser.Signal();
        this.onPause = new Phaser.Signal();
        this.onResume = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onStop = new Phaser.Signal();
        this.onMute = new Phaser.Signal();
        this.onMarkerComplete = new Phaser.Signal();
        this._volume = volume;
        this._buffer = null;
        this._muted = false;
        this._tempMarker = 0;
        this._tempPosition = 0;
        this._tempVolume = 0;
        this._muteVolume = 0;
        this._tempLoop = 0;
        this._paused = false;
        this._onDecodedEventDispatched = false;
    };
    Phaser.Sound.prototype = {
        soundHasUnlocked: function(key) {
            if (key === this.key) {
                this._sound = this.game.cache.getSoundData(this.key);
                this.totalDuration = this._sound.duration;
            }
        },
        addMarker: function(name, start, duration, volume, loop) {
            if (typeof volume == "undefined") {
                volume = 1;
            }
            if (typeof loop == "undefined") {
                loop = false;
            }
            this.markers[name] = {
                name: name,
                start: start,
                stop: start + duration,
                volume: volume,
                duration: duration,
                durationMS: duration * 1e3,
                loop: loop
            };
        },
        removeMarker: function(name) {
            delete this.markers[name];
        },
        update: function() {
            if (this.isDecoded && !this._onDecodedEventDispatched) {
                this.onDecoded.dispatch(this);
                this._onDecodedEventDispatched = true;
            }
            if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
                this.pendingPlayback = false;
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
            }
            if (this.isPlaying) {
                this.currentTime = this.game.time.now - this.startTime;
                if (this.currentTime >= this.durationMS) {
                    if (this.usingWebAudio) {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            if (this.currentMarker === "") {
                                this.currentTime = 0;
                                this.startTime = this.game.time.now;
                            } else {
                                this.onMarkerComplete.dispatch(this.currentMarker, this);
                                this.play(this.currentMarker, 0, this.volume, true, true);
                            }
                        } else {
                            this.stop();
                        }
                    } else {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            this.play(this.currentMarker, 0, this.volume, true, true);
                        } else {
                            this.stop();
                        }
                    }
                }
            }
        },
        play: function(marker, position, volume, loop, forceRestart) {
            if (typeof marker === "undefined") {
                marker = "";
            }
            if (typeof forceRestart === "undefined") {
                forceRestart = true;
            }
            if (this.isPlaying && !forceRestart && !this.override) {
                return this;
            }
            if (this.isPlaying && (this.override || forceRestart)) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0);
                    } else {
                        this._sound.stop(0);
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            this.currentMarker = marker;
            if (marker !== "") {
                if (this.markers[marker]) {
                    this.position = this.markers[marker].start;
                    this.volume = this.markers[marker].volume;
                    this.loop = this.markers[marker].loop;
                    this.duration = this.markers[marker].duration;
                    this.durationMS = this.markers[marker].durationMS;
                    if (typeof volume !== "undefined") {
                        this.volume = volume;
                    }
                    if (typeof loop !== "undefined") {
                        this.loop = loop;
                    }
                    this._tempMarker = marker;
                    this._tempPosition = this.position;
                    this._tempVolume = this.volume;
                    this._tempLoop = this.loop;
                } else {
                    console.warn("Phaser.Sound.play: audio marker " + marker + " doesn't exist");
                    return this;
                }
            } else {
                position = position || 0;
                if (typeof volume === "undefined") {
                    volume = this._volume;
                }
                if (typeof loop === "undefined") {
                    loop = this.loop;
                }
                this.position = position;
                this.volume = volume;
                this.loop = loop;
                this.duration = 0;
                this.durationMS = 0;
                this._tempMarker = marker;
                this._tempPosition = position;
                this._tempVolume = volume;
                this._tempLoop = loop;
            }
            if (this.usingWebAudio) {
                if (this.game.cache.isSoundDecoded(this.key)) {
                    if (this._buffer === null) {
                        this._buffer = this.game.cache.getSoundData(this.key);
                    }
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    this.totalDuration = this._sound.buffer.duration;
                    if (this.duration === 0) {
                        this.duration = this.totalDuration;
                        this.durationMS = this.totalDuration * 1e3;
                    }
                    if (this.loop && marker === "") {
                        this._sound.loop = true;
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, this.position, this.duration);
                    } else {
                        this._sound.start(0, this.position, this.duration);
                    }
                    this.isPlaying = true;
                    this.startTime = this.game.time.now;
                    this.currentTime = 0;
                    this.stopTime = this.startTime + this.durationMS;
                    this.onPlay.dispatch(this);
                } else {
                    this.pendingPlayback = true;
                    if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false) {
                        this.game.sound.decode(this.key, this);
                    }
                }
            } else {
                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
                    this.game.cache.reloadSound(this.key);
                    this.pendingPlayback = true;
                } else {
                    if (this._sound && (this.game.device.cocoonJS || this._sound.readyState === 4)) {
                        this._sound.play();
                        this.totalDuration = this._sound.duration;
                        if (this.duration === 0) {
                            this.duration = this.totalDuration;
                            this.durationMS = this.totalDuration * 1e3;
                        }
                        this._sound.currentTime = this.position;
                        this._sound.muted = this._muted;
                        if (this._muted) {
                            this._sound.volume = 0;
                        } else {
                            this._sound.volume = this._volume;
                        }
                        this.isPlaying = true;
                        this.startTime = this.game.time.now;
                        this.currentTime = 0;
                        this.stopTime = this.startTime + this.durationMS;
                        this.onPlay.dispatch(this);
                    } else {
                        this.pendingPlayback = true;
                    }
                }
            }
            return this;
        },
        restart: function(marker, position, volume, loop) {
            marker = marker || "";
            position = position || 0;
            volume = volume || 1;
            if (typeof loop == "undefined") {
                loop = false;
            }
            this.play(marker, position, volume, loop, true);
        },
        pause: function() {
            if (this.isPlaying && this._sound) {
                this.paused = true;
                this.pausedPosition = this.currentTime;
                this.pausedTime = this.game.time.now;
                this.onPause.dispatch(this);
                this.stop();
            }
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var p = this.position + this.pausedPosition / 1e3;
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    if (this.loop) {
                        this._sound.loop = true;
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, p, this.duration);
                    } else {
                        this._sound.start(0, p, this.duration);
                    }
                } else {
                    this._sound.play();
                }
                this.isPlaying = true;
                this.paused = false;
                this.startTime += this.game.time.now - this.pausedTime;
                this.onResume.dispatch(this);
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0);
                    } else {
                        try {
                            this._sound.stop(0);
                        } catch (e) {}
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            this.isPlaying = false;
            var prevMarker = this.currentMarker;
            if (this.currentMarker !== "") {
                this.onMarkerComplete.dispatch(this.currentMarker, this);
            }
            this.currentMarker = "";
            if (!this.paused) {
                this.onStop.dispatch(this, prevMarker);
            }
        },
        destroy: function(remove) {
            if (typeof remove === "undefined") {
                remove = true;
            }
            this.stop();
            if (remove) {
                this.game.sound.remove(this);
            } else {
                this.markers = {};
                this.context = null;
                this._buffer = null;
                this.externalNode = null;
                this.onDecoded.dispose();
                this.onPlay.dispose();
                this.onPause.dispose();
                this.onResume.dispose();
                this.onLoop.dispose();
                this.onStop.dispose();
                this.onMute.dispose();
                this.onMarkerComplete.dispose();
            }
        }
    };
    Phaser.Sound.prototype.constructor = Phaser.Sound;
    Object.defineProperty(Phaser.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding;
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute;
        },
        set: function(value) {
            value = value || null;
            if (value) {
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.gainNode.gain.value;
                    this.gainNode.gain.value = 0;
                } else if (this.usingAudioTag && this._sound) {
                    this._muteVolume = this._sound.volume;
                    this._sound.volume = 0;
                }
            } else {
                this._muted = false;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = this._muteVolume;
                } else if (this.usingAudioTag && this._sound) {
                    this._sound.volume = this._muteVolume;
                }
            }
            this.onMute.dispatch(this);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(value) {
            if (this.usingWebAudio) {
                this._volume = value;
                this.gainNode.gain.value = value;
            } else if (this.usingAudioTag && this._sound) {
                if (value >= 0 && value <= 1) {
                    this._volume = value;
                    this._sound.volume = value;
                }
            }
        }
    });
    Phaser.SoundManager = function(game) {
        this.game = game;
        this.onSoundDecode = new Phaser.Signal();
        this._codeMuted = false;
        this._muted = false;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this.context = null;
        this.usingWebAudio = true;
        this.usingAudioTag = false;
        this.noAudio = false;
        this.connectToMaster = true;
        this.touchLocked = false;
        this.channels = 32;
    };
    Phaser.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && this.game.device.webAudio === false) {
                this.channels = 1;
            }
            if (!this.game.device.cocoonJS && this.game.device.iOS || window["PhaserGlobal"] && window["PhaserGlobal"].fakeiOSTouchLock) {
                this.game.input.touch.callbackContext = this;
                this.game.input.touch.touchStartCallback = this.unlock;
                this.game.input.mouse.callbackContext = this;
                this.game.input.mouse.mouseDownCallback = this.unlock;
                this.touchLocked = true;
            } else {
                this.touchLocked = false;
            }
            if (window["PhaserGlobal"]) {
                if (window["PhaserGlobal"].disableAudio === true) {
                    this.usingWebAudio = false;
                    this.noAudio = true;
                    return;
                }
                if (window["PhaserGlobal"].disableWebAudio === true) {
                    this.usingWebAudio = false;
                    this.usingAudioTag = true;
                    this.noAudio = false;
                    return;
                }
            }
            if (!!window["AudioContext"]) {
                try {
                    this.context = new window["AudioContext"]();
                } catch (error) {
                    this.context = null;
                    this.usingWebAudio = false;
                    this.noAudio = true;
                }
            } else if (!!window["webkitAudioContext"]) {
                try {
                    this.context = new window["webkitAudioContext"]();
                } catch (error) {
                    this.context = null;
                    this.usingWebAudio = false;
                    this.noAudio = true;
                }
            }
            if (!!window["Audio"] && this.context === null) {
                this.usingWebAudio = false;
                this.usingAudioTag = true;
                this.noAudio = false;
            }
            if (this.context !== null) {
                if (typeof this.context.createGain === "undefined") {
                    this.masterGain = this.context.createGainNode();
                } else {
                    this.masterGain = this.context.createGain();
                }
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this.context.destination);
            }
        },
        unlock: function() {
            if (this.touchLocked === false) {
                return;
            }
            if (this.game.device.webAudio === false || window["PhaserGlobal"] && window["PhaserGlobal"].disableWebAudio === true) {
                this.touchLocked = false;
                this._unlockSource = null;
                this.game.input.touch.callbackContext = null;
                this.game.input.touch.touchStartCallback = null;
                this.game.input.mouse.callbackContext = null;
                this.game.input.mouse.mouseDownCallback = null;
            } else {
                var buffer = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource();
                this._unlockSource.buffer = buffer;
                this._unlockSource.connect(this.context.destination);
                this._unlockSource.noteOn(0);
            }
        },
        stopAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].stop();
                }
            }
        },
        pauseAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].pause();
                }
            }
        },
        resumeAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].resume();
                }
            }
        },
        decode: function(key, sound) {
            sound = sound || null;
            var soundData = this.game.cache.getSoundData(key);
            if (soundData) {
                if (this.game.cache.isSoundDecoded(key) === false) {
                    this.game.cache.updateSound(key, "isDecoding", true);
                    var that = this;
                    this.context.decodeAudioData(soundData, function(buffer) {
                        that.game.cache.decodedSound(key, buffer);
                        if (sound) {
                            that.onSoundDecode.dispatch(key, sound);
                        }
                    });
                }
            }
        },
        update: function() {
            if (this.touchLocked) {
                if (this.game.device.webAudio && this._unlockSource !== null) {
                    if (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) {
                        this.touchLocked = false;
                        this._unlockSource = null;
                        this.game.input.touch.callbackContext = null;
                        this.game.input.touch.touchStartCallback = null;
                    }
                }
            }
            for (var i = 0; i < this._sounds.length; i++) {
                this._sounds[i].update();
            }
        },
        add: function(key, volume, loop, connect) {
            if (typeof volume === "undefined") {
                volume = 1;
            }
            if (typeof loop === "undefined") {
                loop = false;
            }
            if (typeof connect === "undefined") {
                connect = this.connectToMaster;
            }
            var sound = new Phaser.Sound(this.game, key, volume, loop, connect);
            this._sounds.push(sound);
            return sound;
        },
        remove: function(sound) {
            var i = this._sounds.length;
            while (i--) {
                if (this._sounds[i] === sound) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    return true;
                }
            }
            return false;
        },
        removeByKey: function(key) {
            var i = this._sounds.length;
            var removed = 0;
            while (i--) {
                if (this._sounds[i].key === key) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    removed++;
                }
            }
            return removed;
        },
        play: function(key, volume, loop) {
            var sound = this.add(key, volume, loop);
            sound.play();
            return sound;
        },
        setMute: function() {
            if (this._muted) {
                return;
            }
            this._muted = true;
            if (this.usingWebAudio) {
                this._muteVolume = this.masterGain.gain.value;
                this.masterGain.gain.value = 0;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = true;
                }
            }
        },
        unsetMute: function() {
            if (!this._muted || this._codeMuted) {
                return;
            }
            this._muted = false;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = this._muteVolume;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = false;
                }
            }
        },
        destroy: function() {
            this.stopAll();
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].destroy();
                }
            }
            this._sounds = [];
            this.onSoundDecode.dispose();
        }
    };
    Phaser.SoundManager.prototype.constructor = Phaser.SoundManager;
    Object.defineProperty(Phaser.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(value) {
            value = value || null;
            if (value) {
                if (this._muted) {
                    return;
                }
                this._codeMuted = true;
                this.setMute();
            } else {
                if (!this._muted) {
                    return;
                }
                this._codeMuted = false;
                this.unsetMute();
            }
        }
    });
    Object.defineProperty(Phaser.SoundManager.prototype, "volume", {
        get: function() {
            if (this.usingWebAudio) {
                return this.masterGain.gain.value;
            } else {
                return this._volume;
            }
        },
        set: function(value) {
            this._volume = value;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = value;
            } else {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i].usingAudioTag) {
                        this._sounds[i].volume = this._sounds[i].volume * value;
                    }
                }
            }
        }
    });
    Phaser.Utils.Debug = function(game) {
        this.game = game;
        this.sprite = null;
        this.canvas = null;
        this.baseTexture = null;
        this.texture = null;
        this.textureFrame = null;
        this.context = null;
        this.font = "14px Courier";
        this.columnWidth = 100;
        this.lineHeight = 16;
        this.renderShadow = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentAlpha = 1;
        this.dirty = false;
    };
    Phaser.Utils.Debug.prototype = {
        boot: function() {
            if (this.game.renderType === Phaser.CANVAS) {
                this.context = this.game.context;
            } else {
                this.canvas = Phaser.Canvas.create(this.game.width, this.game.height, "", true);
                this.context = this.canvas.getContext("2d");
                this.baseTexture = new PIXI.BaseTexture(this.canvas);
                this.texture = new PIXI.Texture(this.baseTexture);
                this.textureFrame = new Phaser.Frame(0, 0, 0, this.game.width, this.game.height, "debug", this.game.rnd.uuid());
                this.sprite = this.game.make.image(0, 0, this.texture, this.textureFrame);
                this.game.stage.addChild(this.sprite);
            }
        },
        preUpdate: function() {
            if (this.dirty && this.sprite) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
                this.dirty = false;
            }
        },
        reset: function() {
            if (this.context) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
            }
            if (this.sprite) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
            }
        },
        start: function(x, y, color, columnWidth) {
            if (typeof x !== "number") {
                x = 0;
            }
            if (typeof y !== "number") {
                y = 0;
            }
            color = color || "rgb(255,255,255)";
            if (typeof columnWidth === "undefined") {
                columnWidth = 0;
            }
            this.currentX = x;
            this.currentY = y;
            this.currentColor = color;
            this.currentAlpha = this.context.globalAlpha;
            this.columnWidth = columnWidth;
            if (this.sprite) {
                this.dirty = true;
            }
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.strokeStyle = color;
            this.context.fillStyle = color;
            this.context.font = this.font;
            this.context.globalAlpha = 1;
        },
        stop: function() {
            this.context.restore();
            this.context.globalAlpha = this.currentAlpha;
            if (this.sprite) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
            }
        },
        line: function() {
            var x = this.currentX;
            for (var i = 0; i < arguments.length; i++) {
                if (this.renderShadow) {
                    this.context.fillStyle = "rgb(0,0,0)";
                    this.context.fillText(arguments[i], x + 1, this.currentY + 1);
                    this.context.fillStyle = this.currentColor;
                }
                this.context.fillText(arguments[i], x, this.currentY);
                x += this.columnWidth;
            }
            this.currentY += this.lineHeight;
        },
        soundInfo: function(sound, x, y, color) {
            this.start(x, y, color);
            this.line("Sound: " + sound.key + " Locked: " + sound.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(sound.key) + " Pending Playback: " + sound.pendingPlayback);
            this.line("Decoded: " + sound.isDecoded + " Decoding: " + sound.isDecoding);
            this.line("Total Duration: " + sound.totalDuration + " Playing: " + sound.isPlaying);
            this.line("Time: " + sound.currentTime);
            this.line("Volume: " + sound.volume + " Muted: " + sound.mute);
            this.line("WebAudio: " + sound.usingWebAudio + " Audio: " + sound.usingAudioTag);
            if (sound.currentMarker !== "") {
                this.line("Marker: " + sound.currentMarker + " Duration: " + sound.duration + " (ms: " + sound.durationMS + ")");
                this.line("Start: " + sound.markers[sound.currentMarker].start + " Stop: " + sound.markers[sound.currentMarker].stop);
                this.line("Position: " + sound.position);
            }
            this.stop();
        },
        cameraInfo: function(camera, x, y, color) {
            this.start(x, y, color);
            this.line("Camera (" + camera.width + " x " + camera.height + ")");
            this.line("X: " + camera.x + " Y: " + camera.y);
            if (camera.bounds) {
                this.line("Bounds x: " + camera.bounds.x + " Y: " + camera.bounds.y + " w: " + camera.bounds.width + " h: " + camera.bounds.height);
            }
            this.line("View x: " + camera.view.x + " Y: " + camera.view.y + " w: " + camera.view.width + " h: " + camera.view.height);
            this.stop();
        },
        timer: function(timer, x, y, color) {
            this.start(x, y, color);
            this.line("Timer (running: " + timer.running + " expired: " + timer.expired + ")");
            this.line("Next Tick: " + timer.next + " Duration: " + timer.duration);
            this.line("Paused: " + timer.paused + " Length: " + timer.length);
            this.stop();
        },
        pointer: function(pointer, hideIfUp, downColor, upColor, color) {
            if (pointer == null) {
                return;
            }
            if (typeof hideIfUp === "undefined") {
                hideIfUp = false;
            }
            downColor = downColor || "rgba(0,255,0,0.5)";
            upColor = upColor || "rgba(255,0,0,0.5)";
            if (hideIfUp === true && pointer.isUp === true) {
                return;
            }
            this.start(pointer.x, pointer.y - 100, color);
            this.context.beginPath();
            this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2);
            if (pointer.active) {
                this.context.fillStyle = downColor;
            } else {
                this.context.fillStyle = upColor;
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y);
            this.context.lineTo(pointer.position.x, pointer.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + pointer.id + " Active: " + pointer.active);
            this.line("World X: " + pointer.worldX + " World Y: " + pointer.worldY);
            this.line("Screen X: " + pointer.x + " Screen Y: " + pointer.y);
            this.line("Duration: " + pointer.duration + " ms");
            this.line("is Down: " + pointer.isDown + " is Up: " + pointer.isUp);
            this.stop();
        },
        spriteInputInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite Input: (" + sprite.width + " x " + sprite.height + ")");
            this.line("x: " + sprite.input.pointerX().toFixed(1) + " y: " + sprite.input.pointerY().toFixed(1));
            this.line("over: " + sprite.input.pointerOver() + " duration: " + sprite.input.overDuration().toFixed(0));
            this.line("down: " + sprite.input.pointerDown() + " duration: " + sprite.input.downDuration().toFixed(0));
            this.line("just over: " + sprite.input.justOver() + " just out: " + sprite.input.justOut());
            this.stop();
        },
        key: function(key, x, y, color) {
            this.start(x, y, color, 150);
            this.line("Key:", key.keyCode, "isDown:", key.isDown);
            this.line("justPressed:", key.justPressed(), "justReleased:", key.justReleased());
            this.line("Time Down:", key.timeDown.toFixed(0), "duration:", key.duration.toFixed(0));
            this.stop();
        },
        inputInfo: function(x, y, color) {
            this.start(x, y, color);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop();
        },
        spriteBounds: function(sprite, color, filled) {
            var bounds = sprite.getBounds();
            bounds.x += this.game.camera.x;
            bounds.y += this.game.camera.y;
            this.rectangle(bounds, color, filled);
        },
        ropeSegments: function(rope, color, filled) {
            var segments = rope.segments;
            segments.forEach(function(segment) {
                this.rectangle(segment, color, filled);
            }, this);
        },
        spriteInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite: " + " (" + sprite.width + " x " + sprite.height + ") anchor: " + sprite.anchor.x + " x " + sprite.anchor.y);
            this.line("x: " + sprite.x.toFixed(1) + " y: " + sprite.y.toFixed(1));
            this.line("angle: " + sprite.angle.toFixed(1) + " rotation: " + sprite.rotation.toFixed(1));
            this.line("visible: " + sprite.visible + " in camera: " + sprite.inCamera);
            this.stop();
        },
        spriteCoords: function(sprite, x, y, color) {
            this.start(x, y, color, 100);
            if (sprite.name) {
                this.line(sprite.name);
            }
            this.line("x:", sprite.x.toFixed(2), "y:", sprite.y.toFixed(2));
            this.line("pos x:", sprite.position.x.toFixed(2), "pos y:", sprite.position.y.toFixed(2));
            this.line("world x:", sprite.world.x.toFixed(2), "world y:", sprite.world.y.toFixed(2));
            this.stop();
        },
        lineInfo: function(line, x, y, color) {
            this.start(x, y, color, 80);
            this.line("start.x:", line.start.x.toFixed(2), "start.y:", line.start.y.toFixed(2));
            this.line("end.x:", line.end.x.toFixed(2), "end.y:", line.end.y.toFixed(2));
            this.line("length:", line.length.toFixed(2), "angle:", line.angle);
            this.stop();
        },
        pixel: function(x, y, color, size) {
            size = size || 2;
            this.start();
            this.context.fillStyle = color;
            this.context.fillRect(x, y, size, size);
            this.stop();
        },
        geom: function(object, color, filled, forceType) {
            if (typeof filled === "undefined") {
                filled = true;
            }
            if (typeof forceType === "undefined") {
                forceType = 0;
            }
            color = color || "rgba(0,255,0,0.4)";
            this.start();
            this.context.fillStyle = color;
            this.context.strokeStyle = color;
            if (object instanceof Phaser.Rectangle || forceType === 1) {
                if (filled) {
                    this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                } else {
                    this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                }
            } else if (object instanceof Phaser.Circle || forceType === 2) {
                this.context.beginPath();
                this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false);
                this.context.closePath();
                if (filled) {
                    this.context.fill();
                } else {
                    this.context.stroke();
                }
            } else if (object instanceof Phaser.Point || forceType === 3) {
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4);
            } else if (object instanceof Phaser.Line || forceType === 4) {
                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(object.start.x + .5 - this.game.camera.x, object.start.y + .5 - this.game.camera.y);
                this.context.lineTo(object.end.x + .5 - this.game.camera.x, object.end.y + .5 - this.game.camera.y);
                this.context.closePath();
                this.context.stroke();
            }
            this.stop();
        },
        rectangle: function(object, color, filled) {
            if (typeof filled === "undefined") {
                filled = true;
            }
            color = color || "rgba(0, 255, 0, 0.4)";
            this.start();
            if (filled) {
                this.context.fillStyle = color;
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            } else {
                this.context.strokeStyle = color;
                this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            }
            this.stop();
        },
        text: function(text, x, y, color, font) {
            color = color || "rgb(255,255,255)";
            font = font || "16px Courier";
            this.start();
            this.context.font = font;
            if (this.renderShadow) {
                this.context.fillStyle = "rgb(0,0,0)";
                this.context.fillText(text, x + 1, y + 1);
            }
            this.context.fillStyle = color;
            this.context.fillText(text, x, y);
            this.stop();
        },
        quadTree: function(quadtree, color) {
            color = color || "rgba(255,0,0,0.3)";
            this.start();
            var bounds = quadtree.bounds;
            if (quadtree.nodes.length === 0) {
                this.context.strokeStyle = color;
                this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                this.text("size: " + quadtree.objects.length, bounds.x + 4, bounds.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var i = 0; i < quadtree.objects.length; i++) {
                    this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);
                }
            } else {
                for (var i = 0; i < quadtree.nodes.length; i++) {
                    this.quadTree(quadtree.nodes[i]);
                }
            }
            this.stop();
        },
        body: function(sprite, color, filled) {
            if (sprite.body) {
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    this.start();
                    Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled);
                    this.stop();
                } else if (sprite.body.type === Phaser.Physics.NINJA) {
                    this.start();
                    Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled);
                    this.stop();
                }
            }
        },
        bodyInfo: function(sprite, x, y, color) {
            if (sprite.body) {
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    this.start(x, y, color, 210);
                    Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body);
                    this.stop();
                }
            }
        }
    };
    Phaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug;
    Phaser.Color = {
        packPixel: function(r, g, b, a) {
            if (Phaser.Device.LITTLE_ENDIAN) {
                return (a << 24 | b << 16 | g << 8 | r) >>> 0;
            } else {
                return (r << 24 | g << 16 | b << 8 | a) >>> 0;
            }
        },
        unpackPixel: function(rgba, out, hsl, hsv) {
            if (typeof out === "undefined" || out === null) {
                out = Phaser.Color.createColor();
            }
            if (typeof hsl === "undefined" || hsl === null) {
                hsl = false;
            }
            if (typeof hsv === "undefined" || hsv === null) {
                hsv = false;
            }
            if (Phaser.Device.LITTLE_ENDIAN) {
                out.a = (rgba & 4278190080) >>> 24;
                out.b = (rgba & 16711680) >>> 16;
                out.g = (rgba & 65280) >>> 8;
                out.r = rgba & 255;
            } else {
                out.r = (rgba & 4278190080) >>> 24;
                out.g = (rgba & 16711680) >>> 16;
                out.b = (rgba & 65280) >>> 8;
                out.a = rgba & 255;
            }
            out.color = rgba;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a / 255 + ")";
            if (hsl) {
                Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out);
            }
            if (hsv) {
                Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out);
            }
            return out;
        },
        fromRGBA: function(rgba, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            out.r = (rgba & 4278190080) >>> 24;
            out.g = (rgba & 16711680) >>> 16;
            out.b = (rgba & 65280) >>> 8;
            out.a = rgba & 255;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        toRGBA: function(r, g, b, a) {
            return r << 24 | g << 16 | b << 8 | a;
        },
        RGBtoHSL: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 1);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            out.h = 0;
            out.s = 0;
            out.l = (max + min) / 2;
            if (max !== min) {
                var d = max - min;
                out.s = out.l > .5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSLtoRGB: function(h, s, l, out) {
            if (!out) {
                out = Phaser.Color.createColor(l, l, l);
            } else {
                out.r = l;
                out.g = l;
                out.b = l;
            }
            if (s !== 0) {
                var q = l < .5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3);
                out.g = Phaser.Color.hueToColor(p, q, h);
                out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);
            }
            out.r = Math.floor(out.r * 255 | 0);
            out.g = Math.floor(out.g * 255 | 0);
            out.b = Math.floor(out.b * 255 | 0);
            Phaser.Color.updateColor(out);
            return out;
        },
        RGBtoHSV: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 255);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var d = max - min;
            out.h = 0;
            out.s = max === 0 ? 0 : d / max;
            out.v = max;
            if (max !== min) {
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSVtoRGB: function(h, s, v, out) {
            if (typeof out === "undefined") {
                out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v);
            }
            var r, g, b;
            var i = Math.floor(h * 6);
            var f = h * 6 - i;
            var p = v * (1 - s);
            var q = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);
            switch (i % 6) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
            out.r = Math.floor(r * 255);
            out.g = Math.floor(g * 255);
            out.b = Math.floor(b * 255);
            Phaser.Color.updateColor(out);
            return out;
        },
        hueToColor: function(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        },
        createColor: function(r, g, b, a, h, s, l, v) {
            var out = {
                r: r || 0,
                g: g || 0,
                b: b || 0,
                a: a || 1,
                h: h || 0,
                s: s || 0,
                l: l || 0,
                v: v || 0,
                color: 0
            };
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        updateColor: function(out) {
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        getColor32: function(a, r, g, b) {
            return a << 24 | r << 16 | g << 8 | b;
        },
        getColor: function(r, g, b) {
            return r << 16 | g << 8 | b;
        },
        RGBtoString: function(r, g, b, a, prefix) {
            if (typeof a === "undefined") {
                a = 255;
            }
            if (typeof prefix === "undefined") {
                prefix = "#";
            }
            if (prefix === "#") {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            } else {
                return "0x" + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);
            }
        },
        hexToRGB: function(hex) {
            var rgb = Phaser.Color.hexToColor(hex);
            if (rgb) {
                return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b);
            }
        },
        hexToColor: function(hex, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                out.r = parseInt(result[1], 16);
                out.g = parseInt(result[2], 16);
                out.b = parseInt(result[3], 16);
            }
            return out;
        },
        componentToHex: function(color) {
            var hex = color.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        },
        HSVColorWheel: function(s, v) {
            if (typeof s === "undefined") {
                s = 1;
            }
            if (typeof v === "undefined") {
                v = 1;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));
            }
            return colors;
        },
        HSLColorWheel: function(s, l) {
            if (typeof s === "undefined") {
                s = .5;
            }
            if (typeof l === "undefined") {
                l = .5;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));
            }
            return colors;
        },
        interpolateColor: function(color1, color2, steps, currentStep, alpha) {
            if (typeof alpha === "undefined") {
                alpha = 255;
            }
            var src1 = Phaser.Color.getRGB(color1);
            var src2 = Phaser.Color.getRGB(color2);
            var r = (src2.red - src1.red) * currentStep / steps + src1.red;
            var g = (src2.green - src1.green) * currentStep / steps + src1.green;
            var b = (src2.blue - src1.blue) * currentStep / steps + src1.blue;
            return Phaser.Color.getColor32(alpha, r, g, b);
        },
        interpolateColorWithRGB: function(color, r, g, b, steps, currentStep) {
            var src = Phaser.Color.getRGB(color);
            var or = (r - src.red) * currentStep / steps + src.red;
            var og = (g - src.green) * currentStep / steps + src.green;
            var ob = (b - src.blue) * currentStep / steps + src.blue;
            return Phaser.Color.getColor(or, og, ob);
        },
        interpolateRGB: function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
            var r = (r2 - r1) * currentStep / steps + r1;
            var g = (g2 - g1) * currentStep / steps + g1;
            var b = (b2 - b1) * currentStep / steps + b1;
            return Phaser.Color.getColor(r, g, b);
        },
        getRandomColor: function(min, max, alpha) {
            if (typeof min === "undefined") {
                min = 0;
            }
            if (typeof max === "undefined") {
                max = 255;
            }
            if (typeof alpha === "undefined") {
                alpha = 255;
            }
            if (max > 255 || min > max) {
                return Phaser.Color.getColor(255, 255, 255);
            }
            var red = min + Math.round(Math.random() * (max - min));
            var green = min + Math.round(Math.random() * (max - min));
            var blue = min + Math.round(Math.random() * (max - min));
            return Phaser.Color.getColor32(alpha, red, green, blue);
        },
        getRGB: function(color) {
            if (color > 16777215) {
                return {
                    alpha: color >>> 24,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: color >>> 24,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            } else {
                return {
                    alpha: 255,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: 255,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            }
        },
        getWebRGB: function(color) {
            if (typeof color === "object") {
                return "rgba(" + color.r.toString() + "," + color.g.toString() + "," + color.b.toString() + "," + (color.a / 255).toString() + ")";
            } else {
                var rgb = Phaser.Color.getRGB(color);
                return "rgba(" + rgb.r.toString() + "," + rgb.g.toString() + "," + rgb.b.toString() + "," + (rgb.a / 255).toString() + ")";
            }
        },
        getAlpha: function(color) {
            return color >>> 24;
        },
        getAlphaFloat: function(color) {
            return (color >>> 24) / 255;
        },
        getRed: function(color) {
            return color >> 16 & 255;
        },
        getGreen: function(color) {
            return color >> 8 & 255;
        },
        getBlue: function(color) {
            return color & 255;
        }
    };
    Phaser.Physics = function(game, config) {
        config = config || {};
        this.game = game;
        this.config = config;
        this.arcade = null;
        this.p2 = null;
        this.ninja = null;
        this.box2d = null;
        this.chipmunk = null;
        this.parseConfig();
    };
    Phaser.Physics.ARCADE = 0;
    Phaser.Physics.P2JS = 1;
    Phaser.Physics.NINJA = 2;
    Phaser.Physics.BOX2D = 3;
    Phaser.Physics.CHIPMUNK = 5;
    Phaser.Physics.prototype = {
        parseConfig: function() {
            if ((!this.config.hasOwnProperty("arcade") || this.config["arcade"] === true) && Phaser.Physics.hasOwnProperty("Arcade")) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
                this.game.time.deltaCap = .2;
            }
            if (this.config.hasOwnProperty("ninja") && this.config["ninja"] === true && Phaser.Physics.hasOwnProperty("Ninja")) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            }
            if (this.config.hasOwnProperty("p2") && this.config["p2"] === true && Phaser.Physics.hasOwnProperty("P2")) {
                this.p2 = new Phaser.Physics.P2(this.game, this.config);
            }
        },
        startSystem: function(system) {
            if (system === Phaser.Physics.ARCADE) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
            } else if (system === Phaser.Physics.P2JS) {
                this.p2 = new Phaser.Physics.P2(this.game, this.config);
            }
            if (system === Phaser.Physics.NINJA) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            } else if (system === Phaser.Physics.BOX2D && this.box2d === null) {
                throw new Error("The Box2D physics system has not been implemented yet.");
            } else if (system === Phaser.Physics.CHIPMUNK && this.chipmunk === null) {
                throw new Error("The Chipmunk physics system has not been implemented yet.");
            }
        },
        enable: function(object, system, debug) {
            if (typeof system === "undefined") {
                system = Phaser.Physics.ARCADE;
            }
            if (typeof debug === "undefined") {
                debug = false;
            }
            if (system === Phaser.Physics.ARCADE) {
                this.arcade.enable(object);
            } else if (system === Phaser.Physics.P2JS && this.p2) {
                this.p2.enable(object, debug);
            } else if (system === Phaser.Physics.NINJA && this.ninja) {
                this.ninja.enableAABB(object);
            }
        },
        preUpdate: function() {
            if (this.p2) {
                this.p2.preUpdate();
            }
        },
        update: function() {
            if (this.p2) {
                this.p2.update();
            }
        },
        setBoundsToWorld: function() {
            if (this.arcade) {
                this.arcade.setBoundsToWorld();
            }
            if (this.ninja) {
                this.ninja.setBoundsToWorld();
            }
            if (this.p2) {
                this.p2.setBoundsToWorld();
            }
        },
        clear: function() {
            if (this.p2) {
                this.p2.clear();
            }
        },
        destroy: function() {
            if (this.p2) {
                this.p2.destroy();
            }
            this.arcade = null;
            this.ninja = null;
            this.p2 = null;
        }
    };
    Phaser.Physics.prototype.constructor = Phaser.Physics;
    Phaser.Physics.Arcade = function(game) {
        this.game = game;
        this.gravity = new Phaser.Point();
        this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height);
        this.checkCollision = {
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.OVERLAP_BIAS = 4;
        this.TILE_BIAS = 16;
        this.forceX = false;
        this.skipQuadTree = false;
        this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this._overlap = 0;
        this._maxOverlap = 0;
        this._velocity1 = 0;
        this._velocity2 = 0;
        this._newVelocity1 = 0;
        this._newVelocity2 = 0;
        this._average = 0;
        this._mapData = [];
        this._result = false;
        this._total = 0;
        this._angle = 0;
        this._dx = 0;
        this._dy = 0;
        this.setBoundsToWorld();
    };
    Phaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade;
    Phaser.Physics.Arcade.prototype = {
        setBounds: function(x, y, width, height) {
            this.bounds.setTo(x, y, width, height);
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
        },
        enable: function(object, children) {
            if (typeof children === "undefined") {
                children = true;
            }
            var i = 1;
            if (Array.isArray(object)) {
                i = object.length;
                while (i--) {
                    if (object[i] instanceof Phaser.Group) {
                        this.enable(object[i].children, children);
                    } else {
                        this.enableBody(object[i]);
                        if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                            this.enable(object[i], true);
                        }
                    }
                }
            } else {
                if (object instanceof Phaser.Group) {
                    this.enable(object.children, children);
                } else {
                    this.enableBody(object);
                    if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                        this.enable(object.children, true);
                    }
                }
            }
        },
        enableBody: function(object) {
            if (object.hasOwnProperty("body") && object.body === null) {
                object.body = new Phaser.Physics.Arcade.Body(object);
            }
        },
        updateMotion: function(body) {
            this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity;
            body.angularVelocity += this._velocityDelta;
            body.rotation += body.angularVelocity * this.game.time.physicsElapsed;
            body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x);
            body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y);
        },
        computeVelocity: function(axis, body, velocity, acceleration, drag, max) {
            max = max || 1e4;
            if (axis == 1 && body.allowGravity) {
                velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed;
            } else if (axis == 2 && body.allowGravity) {
                velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed;
            }
            if (acceleration) {
                velocity += acceleration * this.game.time.physicsElapsed;
            } else if (drag) {
                this._drag = drag * this.game.time.physicsElapsed;
                if (velocity - this._drag > 0) {
                    velocity -= this._drag;
                } else if (velocity + this._drag < 0) {
                    velocity += this._drag;
                } else {
                    velocity = 0;
                }
            }
            if (velocity > max) {
                velocity = max;
            } else if (velocity < -max) {
                velocity = -max;
            }
            return velocity;
        },
        overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
            overlapCallback = overlapCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || overlapCallback;
            this._result = false;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object2.length; i < len; i++) {
                    this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    this.collideHandler(object1[i], object2, overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    for (var j = 0, len2 = object2.length; j < len2; j++) {
                        this.collideHandler(object1[i], object2[j], overlapCallback, processCallback, callbackContext, true);
                    }
                }
            } else {
                this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);
            }
            return this._total > 0;
        },
        collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
            collideCallback = collideCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || collideCallback;
            this._result = false;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object2.length; i < len; i++) {
                    this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len1 = object1.length; i < len1; i++) {
                    for (var j = 0, len2 = object2.length; j < len2; j++) {
                        this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, false);
                    }
                }
            } else {
                this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);
            }
            return this._total > 0;
        },
        collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (typeof object2 === "undefined" && (object1.type === Phaser.GROUP || object1.type === Phaser.EMITTER)) {
                this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);
                return;
            }
            if (object1 && object2 && object1.exists && object2.exists) {
                if (object1.type == Phaser.SPRITE || object1.type == Phaser.TILESPRITE) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.GROUP) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.TILEMAPLAYER) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.EMITTER) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                }
            }
        },
        collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (!sprite1.body || !sprite2.body) {
                return false;
            }
            if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
                if (collideCallback) {
                    collideCallback.call(callbackContext, sprite1, sprite2);
                }
                this._total++;
            }
            return true;
        },
        collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0 || !sprite.body) {
                return;
            }
            if (sprite.body.skipQuadTree || this.skipQuadTree) {
                for (var i = 0, len = group.children.length; i < len; i++) {
                    if (group.children[i] && group.children[i].exists) {
                        this.collideSpriteVsSprite(sprite, group.children[i], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            } else {
                this.quadTree.clear();
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
                this.quadTree.populate(group);
                this._potentials = this.quadTree.retrieve(sprite);
                for (var i = 0, len = this._potentials.length; i < len; i++) {
                    if (this.separate(sprite.body, this._potentials[i], processCallback, callbackContext, overlapOnly)) {
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, this._potentials[i].sprite);
                        }
                        this._total++;
                    }
                }
            }
        },
        collideGroupVsSelf: function(group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0) {
                return;
            }
            var len = group.children.length;
            for (var i = 0; i < len; i++) {
                for (var j = i + 1; j <= len; j++) {
                    if (group.children[i] && group.children[j] && group.children[i].exists && group.children[j].exists) {
                        this.collideSpriteVsSprite(group.children[i], group.children[j], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            }
        },
        collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group1.length === 0 || group2.length === 0) {
                return;
            }
            for (var i = 0, len = group1.children.length; i < len; i++) {
                if (group1.children[i].exists) {
                    if (group1.children[i].type === Phaser.GROUP) {
                        this.collideGroupVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else {
                        this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            }
        },
        collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext) {
            if (!sprite.body) {
                return;
            }
            this._mapData = tilemapLayer.getTiles(sprite.body.position.x - sprite.body.tilePadding.x, sprite.body.position.y - sprite.body.tilePadding.y, sprite.body.width + sprite.body.tilePadding.x, sprite.body.height + sprite.body.tilePadding.y, false, false);
            if (this._mapData.length === 0) {
                return;
            }
            for (var i = 0; i < this._mapData.length; i++) {
                if (processCallback) {
                    if (processCallback.call(callbackContext, sprite, this._mapData[i])) {
                        if (this.separateTile(i, sprite.body, this._mapData[i])) {
                            this._total++;
                            if (collideCallback) {
                                collideCallback.call(callbackContext, sprite, this._mapData[i]);
                            }
                        }
                    }
                } else {
                    if (this.separateTile(i, sprite.body, this._mapData[i])) {
                        this._total++;
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, this._mapData[i]);
                        }
                    }
                }
            }
        },
        collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext) {
            if (group.length === 0) {
                return;
            }
            for (var i = 0, len = group.children.length; i < len; i++) {
                if (group.children[i].exists) {
                    this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext);
                }
            }
        },
        separate: function(body1, body2, processCallback, callbackContext, overlapOnly) {
            if (!body1.enable || !body2.enable || !this.intersects(body1, body2)) {
                return false;
            }
            if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) {
                return false;
            }
            if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                this._result = this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly);
            } else {
                this._result = this.separateY(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly);
            }
            if (overlapOnly) {
                return true;
            } else {
                return this._result;
            }
        },
        intersects: function(body1, body2) {
            if (body1.right <= body2.position.x) {
                return false;
            }
            if (body1.bottom <= body2.position.y) {
                return false;
            }
            if (body1.position.x >= body2.right) {
                return false;
            }
            if (body1.position.y >= body2.bottom) {
                return false;
            }
            return true;
        },
        separateX: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            this._overlap = 0;
            if (this.intersects(body1, body2)) {
                this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;
                if (body1.deltaX() === 0 && body2.deltaX() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaX() > body2.deltaX()) {
                    this._overlap = body1.right - body2.x;
                    if (this._overlap > this._maxOverlap || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.right = true;
                        body2.touching.none = false;
                        body2.touching.left = true;
                    }
                } else if (body1.deltaX() < body2.deltaX()) {
                    this._overlap = body1.x - body2.width - body2.x;
                    if (-this._overlap > this._maxOverlap || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.left = true;
                        body2.touching.none = false;
                        body2.touching.right = true;
                    }
                }
                body1.overlapX = this._overlap;
                body2.overlapX = this._overlap;
                if (this._overlap !== 0) {
                    if (overlapOnly || body1.customSeparateX || body2.customSeparateX) {
                        return true;
                    }
                    this._velocity1 = body1.velocity.x;
                    this._velocity2 = body2.velocity.x;
                    if (!body1.immovable && !body2.immovable) {
                        this._overlap *= .5;
                        body1.x = body1.x - this._overlap;
                        body2.x += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;
                        body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;
                    } else if (!body1.immovable) {
                        body1.x = body1.x - this._overlap;
                        body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;
                    } else if (!body2.immovable) {
                        body2.x += this._overlap;
                        body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;
                    }
                    return true;
                }
            }
            return false;
        },
        separateY: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            this._overlap = 0;
            if (this.intersects(body1, body2)) {
                this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;
                if (body1.deltaY() === 0 && body2.deltaY() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaY() > body2.deltaY()) {
                    this._overlap = body1.bottom - body2.y;
                    if (this._overlap > this._maxOverlap || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.down = true;
                        body2.touching.none = false;
                        body2.touching.up = true;
                    }
                } else if (body1.deltaY() < body2.deltaY()) {
                    this._overlap = body1.y - body2.bottom;
                    if (-this._overlap > this._maxOverlap || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.up = true;
                        body2.touching.none = false;
                        body2.touching.down = true;
                    }
                }
                body1.overlapY = this._overlap;
                body2.overlapY = this._overlap;
                if (this._overlap !== 0) {
                    if (overlapOnly || body1.customSeparateY || body2.customSeparateY) {
                        return true;
                    }
                    this._velocity1 = body1.velocity.y;
                    this._velocity2 = body2.velocity.y;
                    if (!body1.immovable && !body2.immovable) {
                        this._overlap *= .5;
                        body1.y = body1.y - this._overlap;
                        body2.y += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;
                        body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;
                    } else if (!body1.immovable) {
                        body1.y = body1.y - this._overlap;
                        body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;
                        if (body2.moves) {
                            body1.x += body2.x - body2.prev.x;
                        }
                    } else if (!body2.immovable) {
                        body2.y += this._overlap;
                        body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;
                        if (body1.moves) {
                            body2.x += body1.x - body1.prev.x;
                        }
                    }
                    return true;
                }
            }
            return false;
        },
        separateTile: function(i, body, tile) {
            if (!body.enable || !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                return false;
            }
            if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile)) {
                return false;
            } else if (tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile)) {
                return false;
            }
            if (!tile.faceLeft && !tile.faceRight && !tile.faceTop && !tile.faceBottom) {
                return false;
            }
            var ox = 0;
            var oy = 0;
            var minX = 0;
            var minY = 1;
            if (body.deltaAbsX() > body.deltaAbsY()) {
                minX = -1;
            } else if (body.deltaAbsX() < body.deltaAbsY()) {
                minY = -1;
            }
            if (body.deltaX() !== 0 && body.deltaY() !== 0 && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom)) {
                minX = Math.min(Math.abs(body.position.x - tile.right), Math.abs(body.right - tile.left));
                minY = Math.min(Math.abs(body.position.y - tile.bottom), Math.abs(body.bottom - tile.top));
            }
            if (minX < minY) {
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                    if (ox !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                }
            } else {
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                    if (oy !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                }
            }
            return ox !== 0 || oy !== 0;
        },
        tileCheckX: function(body, tile) {
            var ox = 0;
            if (body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left) {
                if (tile.faceRight && body.x < tile.right) {
                    ox = body.x - tile.right;
                    if (ox < -this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            } else if (body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right) {
                if (tile.faceLeft && body.right > tile.left) {
                    ox = body.right - tile.left;
                    if (ox > this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            }
            if (ox !== 0) {
                this.processTileSeparationX(body, ox);
            }
            return ox;
        },
        tileCheckY: function(body, tile) {
            var oy = 0;
            if (body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up) {
                if (tile.faceBottom && body.y < tile.bottom) {
                    oy = body.y - tile.bottom;
                    if (oy < -this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            } else if (body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down) {
                if (tile.faceTop && body.bottom > tile.top) {
                    oy = body.bottom - tile.top;
                    if (oy > this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            }
            if (oy !== 0) {
                this.processTileSeparationY(body, oy);
            }
            return oy;
        },
        processTileSeparationX: function(body, x) {
            if (x < 0) {
                body.blocked.left = true;
            } else if (x > 0) {
                body.blocked.right = true;
            }
            body.position.x -= x;
            if (body.bounce.x === 0) {
                body.velocity.x = 0;
            } else {
                body.velocity.x = -body.velocity.x * body.bounce.x;
            }
        },
        processTileSeparationY: function(body, y) {
            if (y < 0) {
                body.blocked.up = true;
            } else if (y > 0) {
                body.blocked.down = true;
            }
            body.position.y -= y;
            if (body.bounce.y === 0) {
                body.velocity.y = 0;
            } else {
                body.velocity.y = -body.velocity.y * body.bounce.y;
            }
        },
        getObjectsUnderPointer: function(pointer, group, callback, callbackContext) {
            if (group.length === 0 || !pointer.exists) {
                return;
            }
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(group);
            var rect = new Phaser.Rectangle(pointer.x, pointer.y, 1, 1);
            var output = [];
            this._potentials = this.quadTree.retrieve(rect);
            for (var i = 0, len = this._potentials.length; i < len; i++) {
                if (this._potentials[i].hitTest(pointer.x, pointer.y)) {
                    if (callback) {
                        callback.call(callbackContext, pointer, this._potentials[i].sprite);
                    }
                    output.push(this._potentials[i].sprite);
                }
            }
            return output;
        },
        moveToObject: function(displayObject, destination, speed, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceBetween(displayObject, destination) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        moveToPointer: function(displayObject, speed, pointer, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            pointer = pointer || this.game.input.activePointer;
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = this.angleToPointer(displayObject, pointer);
            if (maxTime > 0) {
                speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        moveToXY: function(displayObject, x, y, speed, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = Math.atan2(y - displayObject.y, x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        velocityFromAngle: function(angle, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(this.game.math.degToRad(angle)) * speed, Math.sin(this.game.math.degToRad(angle)) * speed);
        },
        velocityFromRotation: function(rotation, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerationFromRotation: function(rotation, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerateToObject: function(displayObject, destination, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleBetween(displayObject, destination);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        accelerateToPointer: function(displayObject, pointer, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof pointer === "undefined") {
                pointer = this.game.input.activePointer;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleToPointer(displayObject, pointer);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        accelerateToXY: function(displayObject, x, y, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleToXY(displayObject, x, y);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        distanceBetween: function(source, target) {
            this._dx = source.x - target.x;
            this._dy = source.y - target.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        distanceToXY: function(displayObject, x, y) {
            this._dx = displayObject.x - x;
            this._dy = displayObject.y - y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        distanceToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            this._dx = displayObject.x - pointer.x;
            this._dy = displayObject.y - pointer.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        angleBetween: function(source, target) {
            this._dx = target.x - source.x;
            this._dy = target.y - source.y;
            return Math.atan2(this._dy, this._dx);
        },
        angleToXY: function(displayObject, x, y) {
            this._dx = x - displayObject.x;
            this._dy = y - displayObject.y;
            return Math.atan2(this._dy, this._dx);
        },
        angleToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            this._dx = pointer.worldX - displayObject.x;
            this._dy = pointer.worldY - displayObject.y;
            return Math.atan2(this._dy, this._dx);
        }
    };
    Phaser.Physics.Arcade.Body = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.type = Phaser.Physics.ARCADE;
        this.enable = true;
        this.offset = new Phaser.Point();
        this.position = new Phaser.Point(sprite.x, sprite.y);
        this.prev = new Phaser.Point(this.position.x, this.position.y);
        this.allowRotation = true;
        this.rotation = sprite.rotation;
        this.preRotation = sprite.rotation;
        this.sourceWidth = sprite.texture.frame.width;
        this.sourceHeight = sprite.texture.frame.height;
        this.width = sprite.width;
        this.height = sprite.height;
        this.halfWidth = Math.abs(sprite.width / 2);
        this.halfHeight = Math.abs(sprite.height / 2);
        this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight);
        this.velocity = new Phaser.Point();
        this.newVelocity = new Phaser.Point(0, 0);
        this.deltaMax = new Phaser.Point(0, 0);
        this.acceleration = new Phaser.Point();
        this.drag = new Phaser.Point();
        this.allowGravity = true;
        this.gravity = new Phaser.Point(0, 0);
        this.bounce = new Phaser.Point();
        this.maxVelocity = new Phaser.Point(1e4, 1e4);
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.angularDrag = 0;
        this.maxAngular = 1e3;
        this.mass = 1;
        this.angle = 0;
        this.speed = 0;
        this.facing = Phaser.NONE;
        this.immovable = false;
        this.moves = true;
        this.customSeparateX = false;
        this.customSeparateY = false;
        this.overlapX = 0;
        this.overlapY = 0;
        this.embedded = false;
        this.collideWorldBounds = false;
        this.checkCollision = {
            none: false,
            any: true,
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.touching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.wasTouching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.blocked = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.tilePadding = new Phaser.Point();
        this.phase = 0;
        this.skipQuadTree = false;
        this._reset = true;
        this._sx = sprite.scale.x;
        this._sy = sprite.scale.y;
        this._dx = 0;
        this._dy = 0;
    };
    Phaser.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            var asx = Math.abs(this.sprite.scale.x);
            var asy = Math.abs(this.sprite.scale.y);
            if (asx !== this._sx || asy !== this._sy) {
                this.width = this.sourceWidth * asx;
                this.height = this.sourceHeight * asy;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this._sx = asx;
                this._sy = asy;
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this._reset = true;
            }
        },
        preUpdate: function() {
            if (!this.enable) {
                return;
            }
            this.phase = 1;
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = true;
            this.touching.up = false;
            this.touching.down = false;
            this.touching.left = false;
            this.touching.right = false;
            this.blocked.up = false;
            this.blocked.down = false;
            this.blocked.left = false;
            this.blocked.right = false;
            this.embedded = false;
            this.updateBounds();
            this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            if (this._reset || this.sprite._cache[4] === 1) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y;
            }
            if (this.moves) {
                this.game.physics.arcade.updateMotion(this);
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
                this.position.x += this.newVelocity.x;
                this.position.y += this.newVelocity.y;
                if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) {
                    this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
                if (this.collideWorldBounds) {
                    this.checkWorldBounds();
                }
            }
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            this._reset = false;
        },
        postUpdate: function() {
            if (!this.enable) {
                return;
            }
            if (this.phase === 2) {
                return;
            }
            this.phase = 2;
            if (this.deltaX() < 0) {
                this.facing = Phaser.LEFT;
            } else if (this.deltaX() > 0) {
                this.facing = Phaser.RIGHT;
            }
            if (this.deltaY() < 0) {
                this.facing = Phaser.UP;
            } else if (this.deltaY() > 0) {
                this.facing = Phaser.DOWN;
            }
            if (this.moves) {
                this._dx = this.deltaX();
                this._dy = this.deltaY();
                if (this.deltaMax.x !== 0 && this._dx !== 0) {
                    if (this._dx < 0 && this._dx < -this.deltaMax.x) {
                        this._dx = -this.deltaMax.x;
                    } else if (this._dx > 0 && this._dx > this.deltaMax.x) {
                        this._dx = this.deltaMax.x;
                    }
                }
                if (this.deltaMax.y !== 0 && this._dy !== 0) {
                    if (this._dy < 0 && this._dy < -this.deltaMax.y) {
                        this._dy = -this.deltaMax.y;
                    } else if (this._dy > 0 && this._dy > this.deltaMax.y) {
                        this._dy = this.deltaMax.y;
                    }
                }
                this.sprite.x += this._dx;
                this.sprite.y += this._dy;
            }
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            if (this.allowRotation) {
                this.sprite.angle += this.deltaZ();
            }
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
        },
        destroy: function() {
            this.sprite.body = null;
            this.sprite = null;
        },
        checkWorldBounds: function() {
            if (this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left) {
                this.position.x = this.game.physics.arcade.bounds.x;
                this.velocity.x *= -this.bounce.x;
                this.blocked.left = true;
            } else if (this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right) {
                this.position.x = this.game.physics.arcade.bounds.right - this.width;
                this.velocity.x *= -this.bounce.x;
                this.blocked.right = true;
            }
            if (this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up) {
                this.position.y = this.game.physics.arcade.bounds.y;
                this.velocity.y *= -this.bounce.y;
                this.blocked.up = true;
            } else if (this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down) {
                this.position.y = this.game.physics.arcade.bounds.bottom - this.height;
                this.velocity.y *= -this.bounce.y;
                this.blocked.down = true;
            }
        },
        setSize: function(width, height, offsetX, offsetY) {
            if (typeof offsetX === "undefined") {
                offsetX = this.offset.x;
            }
            if (typeof offsetY === "undefined") {
                offsetY = this.offset.y;
            }
            this.sourceWidth = width;
            this.sourceHeight = height;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(offsetX, offsetY);
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        reset: function(x, y) {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.position.x = x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = y - this.sprite.anchor.y * this.height + this.offset.y;
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            this._sx = this.sprite.scale.x;
            this._sy = this.sprite.scale.y;
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        hitTest: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        onFloor: function() {
            return this.blocked.down;
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function() {
            return this.position.x - this.prev.x;
        },
        deltaY: function() {
            return this.position.y - this.prev.y;
        },
        deltaZ: function() {
            return this.rotation - this.preRotation;
        }
    };
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    Phaser.Physics.Arcade.Body.render = function(context, body, color, filled) {
        if (typeof filled === "undefined") {
            filled = true;
        }
        color = color || "rgba(0,255,0,0.4)";
        if (filled) {
            context.fillStyle = color;
            context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        } else {
            context.strokeStyle = color;
            context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        }
    };
    Phaser.Physics.Arcade.Body.renderBodyInfo = function(debug, body) {
        debug.line("x: " + body.x.toFixed(2), "y: " + body.y.toFixed(2), "width: " + body.width, "height: " + body.height);
        debug.line("velocity x: " + body.velocity.x.toFixed(2), "y: " + body.velocity.y.toFixed(2), "deltaX: " + body._dx.toFixed(2), "deltaY: " + body._dy.toFixed(2));
        debug.line("acceleration x: " + body.acceleration.x.toFixed(2), "y: " + body.acceleration.y.toFixed(2), "speed: " + body.speed.toFixed(2), "angle: " + body.angle.toFixed(2));
        debug.line("gravity x: " + body.gravity.x, "y: " + body.gravity.y, "bounce x: " + body.bounce.x.toFixed(2), "y: " + body.bounce.y.toFixed(2));
        debug.line("touching left: " + body.touching.left, "right: " + body.touching.right, "up: " + body.touching.up, "down: " + body.touching.down);
        debug.line("blocked left: " + body.blocked.left, "right: " + body.blocked.right, "up: " + body.blocked.up, "down: " + body.blocked.down);
    };
    Phaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body;
    Phaser.Particles = function(game) {
        this.game = game;
        this.emitters = {};
        this.ID = 0;
    };
    Phaser.Particles.prototype = {
        add: function(emitter) {
            this.emitters[emitter.name] = emitter;
            return emitter;
        },
        remove: function(emitter) {
            delete this.emitters[emitter.name];
        },
        update: function() {
            for (var key in this.emitters) {
                if (this.emitters[key].exists) {
                    this.emitters[key].update();
                }
            }
        }
    };
    Phaser.Particles.prototype.constructor = Phaser.Particles;
    Phaser.Particles.Arcade = {};
    Phaser.Particles.Arcade.Emitter = function(game, x, y, maxParticles) {
        this.maxParticles = maxParticles || 50;
        Phaser.Group.call(this, game);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = Phaser.EMITTER;
        this.area = new Phaser.Rectangle(x, y, 1, 1);
        this.minParticleSpeed = new Phaser.Point(-100, -100);
        this.maxParticleSpeed = new Phaser.Point(100, 100);
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this.scaleData = null;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.minParticleAlpha = 1;
        this.maxParticleAlpha = 1;
        this.alphaData = null;
        this.gravity = 100;
        this.particleClass = Phaser.Particle;
        this.particleDrag = new Phaser.Point();
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2e3;
        this.bounce = new Phaser.Point();
        this.on = false;
        this.particleAnchor = new Phaser.Point(.5, .5);
        this.blendMode = Phaser.blendModes.NORMAL;
        this.emitX = x;
        this.emitY = y;
        this.autoScale = false;
        this.autoAlpha = false;
        this.particleBringToTop = false;
        this.particleSendToBack = false;
        this._minParticleScale = new Phaser.Point(1, 1);
        this._maxParticleScale = new Phaser.Point(1, 1);
        this._quantity = 0;
        this._timer = 0;
        this._counter = 0;
        this._explode = true;
        this._frames = null;
    };
    Phaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype);
    Phaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter;
    Phaser.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on) {
            if (this._explode) {
                this._counter = 0;
                do {
                    this.emitParticle();
                    this._counter++;
                } while (this._counter < this._quantity);
                this.on = false;
            } else {
                if (this.game.time.now >= this._timer) {
                    this.emitParticle();
                    this._counter++;
                    if (this._quantity > 0) {
                        if (this._counter >= this._quantity) {
                            this.on = false;
                        }
                    }
                    this._timer = this.game.time.now + this.frequency;
                }
            }
        }
        var i = this.children.length;
        while (i--) {
            if (this.children[i].exists) {
                this.children[i].update();
            }
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.makeParticles = function(keys, frames, quantity, collide, collideWorldBounds) {
        if (typeof frames === "undefined") {
            frames = 0;
        }
        if (typeof quantity === "undefined") {
            quantity = this.maxParticles;
        }
        if (typeof collide === "undefined") {
            collide = false;
        }
        if (typeof collideWorldBounds === "undefined") {
            collideWorldBounds = false;
        }
        var particle;
        var i = 0;
        var rndKey = keys;
        var rndFrame = frames;
        this._frames = frames;
        while (i < quantity) {
            if (Array.isArray(keys)) {
                rndKey = this.game.rnd.pick(keys);
            }
            if (Array.isArray(frames)) {
                rndFrame = this.game.rnd.pick(frames);
            }
            particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame);
            this.game.physics.arcade.enable(particle, false);
            if (collide) {
                particle.body.checkCollision.any = true;
                particle.body.checkCollision.none = false;
            } else {
                particle.body.checkCollision.none = true;
            }
            particle.body.collideWorldBounds = collideWorldBounds;
            particle.exists = false;
            particle.visible = false;
            particle.anchor.copyFrom(this.particleAnchor);
            this.add(particle);
            i++;
        }
        return this;
    };
    Phaser.Particles.Arcade.Emitter.prototype.kill = function() {
        this.on = false;
        this.alive = false;
        this.exists = false;
    };
    Phaser.Particles.Arcade.Emitter.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
    };
    Phaser.Particles.Arcade.Emitter.prototype.explode = function(lifespan, quantity) {
        this.start(true, lifespan, 0, quantity, false);
    };
    Phaser.Particles.Arcade.Emitter.prototype.flow = function(lifespan, frequency, quantity) {
        this.start(false, lifespan, frequency, quantity, true);
    };
    Phaser.Particles.Arcade.Emitter.prototype.start = function(explode, lifespan, frequency, quantity, forceQuantity) {
        if (typeof explode === "undefined") {
            explode = true;
        }
        if (typeof lifespan === "undefined") {
            lifespan = 0;
        }
        if (typeof frequency === "undefined" || frequency === null) {
            frequency = 250;
        }
        if (typeof quantity === "undefined") {
            quantity = 0;
        }
        if (typeof forceQuantity === "undefined") {
            forceQuantity = false;
        }
        this.revive();
        this.visible = true;
        this.on = true;
        this._explode = explode;
        this.lifespan = lifespan;
        this.frequency = frequency;
        if (explode || forceQuantity) {
            this._quantity = quantity;
        } else {
            this._quantity += quantity;
        }
        this._counter = 0;
        this._timer = this.game.time.now + frequency;
    };
    Phaser.Particles.Arcade.Emitter.prototype.emitParticle = function() {
        var particle = this.getFirstExists(false);
        if (particle === null) {
            return;
        }
        if (this.width > 1 || this.height > 1) {
            particle.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom));
        } else {
            particle.reset(this.emitX, this.emitY);
        }
        particle.angle = 0;
        particle.lifespan = this.lifespan;
        if (this.particleBringToTop) {
            this.bringToTop(particle);
        } else if (this.particleSendToBack) {
            this.sendToBack(particle);
        }
        if (this.autoScale) {
            particle.setScaleData(this.scaleData);
        } else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) {
            particle.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale));
        } else if (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) {
            particle.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y));
        }
        if (Array.isArray(this._frames === "object")) {
            particle.frame = this.game.rnd.pick(this._frames);
        } else {
            particle.frame = this._frames;
        }
        if (this.autoAlpha) {
            particle.setAlphaData(this.alphaData);
        } else {
            particle.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha);
        }
        particle.blendMode = this.blendMode;
        particle.body.updateBounds();
        particle.body.bounce.setTo(this.bounce.x, this.bounce.y);
        particle.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);
        particle.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y);
        particle.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation);
        particle.body.gravity.y = this.gravity;
        particle.body.drag.x = this.particleDrag.x;
        particle.body.drag.y = this.particleDrag.y;
        particle.body.angularDrag = this.angularDrag;
        particle.onEmit();
    };
    Phaser.Particles.Arcade.Emitter.prototype.setSize = function(width, height) {
        this.area.width = width;
        this.area.height = height;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setXSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.x = min;
        this.maxParticleSpeed.x = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setYSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.y = min;
        this.maxParticleSpeed.y = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setRotation = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minRotation = min;
        this.maxRotation = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setAlpha = function(min, max, rate, ease, yoyo) {
        if (typeof min === "undefined") {
            min = 1;
        }
        if (typeof max === "undefined") {
            max = 1;
        }
        if (typeof rate === "undefined") {
            rate = 0;
        }
        if (typeof ease === "undefined") {
            ease = Phaser.Easing.Linear.None;
        }
        if (typeof yoyo === "undefined") {
            yoyo = false;
        }
        this.minParticleAlpha = min;
        this.maxParticleAlpha = max;
        this.autoAlpha = false;
        if (rate > 0 && min !== max) {
            var tweenData = {
                v: min
            };
            var tween = this.game.make.tween(tweenData).to({
                v: max
            }, rate, ease);
            tween.yoyo(yoyo);
            this.alphaData = tween.generateData(60);
            this.alphaData.reverse();
            this.autoAlpha = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.setScale = function(minX, maxX, minY, maxY, rate, ease, yoyo) {
        if (typeof minX === "undefined") {
            minX = 1;
        }
        if (typeof maxX === "undefined") {
            maxX = 1;
        }
        if (typeof minY === "undefined") {
            minY = 1;
        }
        if (typeof maxY === "undefined") {
            maxY = 1;
        }
        if (typeof rate === "undefined") {
            rate = 0;
        }
        if (typeof ease === "undefined") {
            ease = Phaser.Easing.Linear.None;
        }
        if (typeof yoyo === "undefined") {
            yoyo = false;
        }
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this._minParticleScale.set(minX, minY);
        this._maxParticleScale.set(maxX, maxY);
        this.autoScale = false;
        if (rate > 0 && minX !== maxX || minY !== maxY) {
            var tweenData = {
                x: minX,
                y: minY
            };
            var tween = this.game.make.tween(tweenData).to({
                x: maxX,
                y: maxY
            }, rate, ease);
            tween.yoyo(yoyo);
            this.scaleData = tween.generateData(60);
            this.scaleData.reverse();
            this.autoScale = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.at = function(object) {
        if (object.center) {
            this.emitX = object.center.x;
            this.emitY = object.center.y;
        } else {
            this.emitX = object.world.x + object.anchor.x * object.width;
            this.emitY = object.world.y + object.anchor.y * object.height;
        }
    };
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width;
        },
        set: function(value) {
            this.area.width = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height;
        },
        set: function(value) {
            this.area.height = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX;
        },
        set: function(value) {
            this.emitX = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY;
        },
        set: function(value) {
            this.emitY = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2);
        }
    });
    Phaser.Tile = function(layer, index, x, y, width, height) {
        this.layer = layer;
        this.index = index;
        this.x = x;
        this.y = y;
        this.worldX = x * width;
        this.worldY = y * height;
        this.width = width;
        this.height = height;
        this.centerX = Math.abs(width / 2);
        this.centerY = Math.abs(height / 2);
        this.alpha = 1;
        this.properties = {};
        this.scanned = false;
        this.faceTop = false;
        this.faceBottom = false;
        this.faceLeft = false;
        this.faceRight = false;
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.collisionCallback = null;
        this.collisionCallbackContext = this;
    };
    Phaser.Tile.prototype = {
        containsPoint: function(x, y) {
            return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);
        },
        intersects: function(x, y, right, bottom) {
            if (right <= this.worldX) {
                return false;
            }
            if (bottom <= this.worldY) {
                return false;
            }
            if (x >= this.worldX + this.width) {
                return false;
            }
            if (y >= this.worldY + this.height) {
                return false;
            }
            return true;
        },
        setCollisionCallback: function(callback, context) {
            this.collisionCallback = callback;
            this.collisionCallbackContext = context;
        },
        destroy: function() {
            this.collisionCallback = null;
            this.collisionCallbackContext = null;
            this.properties = null;
        },
        setCollision: function(left, right, up, down) {
            this.collideLeft = left;
            this.collideRight = right;
            this.collideUp = up;
            this.collideDown = down;
            this.faceLeft = left;
            this.faceRight = right;
            this.faceTop = up;
            this.faceBottom = down;
        },
        resetCollision: function() {
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false;
        },
        isInteresting: function(collides, faces) {
            if (collides && faces) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback;
            } else if (collides) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
            } else if (faces) {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
            }
            return false;
        },
        copy: function(tile) {
            this.index = tile.index;
            this.alpha = tile.alpha;
            this.properties = tile.properties;
            this.collideUp = tile.collideUp;
            this.collideDown = tile.collideDown;
            this.collideLeft = tile.collideLeft;
            this.collideRight = tile.collideRight;
            this.collisionCallback = tile.collisionCallback;
            this.collisionCallbackContext = tile.collisionCallbackContext;
        }
    };
    Phaser.Tile.prototype.constructor = Phaser.Tile;
    Object.defineProperty(Phaser.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "left", {
        get: function() {
            return this.worldX;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "top", {
        get: function() {
            return this.worldY;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height;
        }
    });
    Phaser.Tilemap = function(game, key, tileWidth, tileHeight, width, height) {
        this.game = game;
        this.key = key;
        var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height);
        if (data === null) {
            return;
        }
        this.width = data.width;
        this.height = data.height;
        this.tileWidth = data.tileWidth;
        this.tileHeight = data.tileHeight;
        this.orientation = data.orientation;
        this.format = data.format;
        this.version = data.version;
        this.properties = data.properties;
        this.widthInPixels = data.widthInPixels;
        this.heightInPixels = data.heightInPixels;
        this.layers = data.layers;
        this.tilesets = data.tilesets;
        this.tiles = data.tiles;
        this.objects = data.objects;
        this.collideIndexes = [];
        this.collision = data.collision;
        this.images = data.images;
        this.currentLayer = 0;
        this.debugMap = [];
        this._results = [];
        this._tempA = 0;
        this._tempB = 0;
    };
    Phaser.Tilemap.CSV = 0;
    Phaser.Tilemap.TILED_JSON = 1;
    Phaser.Tilemap.NORTH = 0;
    Phaser.Tilemap.EAST = 1;
    Phaser.Tilemap.SOUTH = 2;
    Phaser.Tilemap.WEST = 3;
    Phaser.Tilemap.prototype = {
        create: function(name, width, height, tileWidth, tileHeight, group) {
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            this.width = width;
            this.height = height;
            this.setTileSize(tileWidth, tileHeight);
            this.layers.length = 0;
            return this.createBlankLayer(name, width, height, tileWidth, tileHeight, group);
        },
        setTileSize: function(tileWidth, tileHeight) {
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.widthInPixels = this.width * tileWidth;
            this.heightInPixels = this.height * tileHeight;
        },
        addTilesetImage: function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
            if (typeof tileWidth === "undefined") {
                tileWidth = this.tileWidth;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = this.tileHeight;
            }
            if (typeof tileMargin === "undefined") {
                tileMargin = 0;
            }
            if (typeof tileSpacing === "undefined") {
                tileSpacing = 0;
            }
            if (typeof gid === "undefined") {
                gid = 0;
            }
            if (tileWidth === 0) {
                tileWidth = 32;
            }
            if (tileHeight === 0) {
                tileHeight = 32;
            }
            if (typeof key === "undefined") {
                if (typeof tileset === "string") {
                    key = tileset;
                    if (!this.game.cache.checkImageKey(key)) {
                        console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + key + '"');
                        return null;
                    }
                } else {
                    return null;
                }
            }
            if (typeof tileset === "string") {
                tileset = this.getTilesetIndex(tileset);
                if (tileset === null && this.format === Phaser.Tilemap.TILED_JSON) {
                    console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + key + '"');
                    return null;
                }
            }
            if (this.tilesets[tileset]) {
                this.tilesets[tileset].setImage(this.game.cache.getImage(key));
                return this.tilesets[tileset];
            } else {
                var newSet = new Phaser.Tileset(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {});
                newSet.setImage(this.game.cache.getImage(key));
                this.tilesets.push(newSet);
                var i = this.tilesets.length - 1;
                var x = tileMargin;
                var y = tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = gid; t < gid + newSet.total; t++) {
                    this.tiles[t] = [ x, y, i ];
                    x += tileWidth + tileSpacing;
                    count++;
                    if (count === newSet.total) {
                        break;
                    }
                    countX++;
                    if (countX === newSet.columns) {
                        x = tileMargin;
                        y += tileHeight + tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === newSet.rows) {
                            break;
                        }
                    }
                }
                return newSet;
            }
            return null;
        },
        createFromObjects: function(name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
            if (typeof exists === "undefined") {
                exists = true;
            }
            if (typeof autoCull === "undefined") {
                autoCull = false;
            }
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            if (typeof CustomClass === "undefined") {
                CustomClass = Phaser.Sprite;
            }
            if (typeof adjustY === "undefined") {
                adjustY = true;
            }
            if (!this.objects[name]) {
                console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + name);
                return;
            }
            var sprite;
            for (var i = 0, len = this.objects[name].length; i < len; i++) {
                if (this.objects[name][i].gid === gid) {
                    sprite = new CustomClass(this.game, this.objects[name][i].x, this.objects[name][i].y, key, frame);
                    sprite.name = this.objects[name][i].name;
                    sprite.visible = this.objects[name][i].visible;
                    sprite.autoCull = autoCull;
                    sprite.exists = exists;
                    if (adjustY) {
                        sprite.y -= sprite.height;
                    }
                    group.add(sprite);
                    for (var property in this.objects[name][i].properties) {
                        group.set(sprite, property, this.objects[name][i].properties[property], false, false, 0, true);
                    }
                }
            }
        },
        createLayer: function(layer, width, height, group) {
            if (typeof width === "undefined") {
                width = this.game.width;
            }
            if (typeof height === "undefined") {
                height = this.game.height;
            }
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            var index = layer;
            if (typeof layer === "string") {
                index = this.getLayerIndex(layer);
            }
            if (index === null || index > this.layers.length) {
                console.warn("Tilemap.createLayer: Invalid layer ID given: " + index);
                return;
            }
            return group.add(new Phaser.TilemapLayer(this.game, this, index, width, height));
        },
        createBlankLayer: function(name, width, height, tileWidth, tileHeight, group) {
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            if (this.getLayerIndex(name) !== null) {
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                return;
            }
            var layer = {
                name: name,
                x: 0,
                y: 0,
                width: width,
                height: height,
                widthInPixels: width * tileWidth,
                heightInPixels: height * tileHeight,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            };
            var row;
            var output = [];
            for (var y = 0; y < height; y++) {
                row = [];
                for (var x = 0; x < width; x++) {
                    row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight));
                }
                output.push(row);
            }
            layer.data = output;
            this.layers.push(layer);
            this.currentLayer = this.layers.length - 1;
            var w = layer.widthInPixels;
            var h = layer.heightInPixels;
            if (w > this.game.width) {
                w = this.game.width;
            }
            if (h > this.game.height) {
                h = this.game.height;
            }
            var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h);
            output.name = name;
            return group.add(output);
        },
        getIndex: function(location, name) {
            for (var i = 0; i < location.length; i++) {
                if (location[i].name === name) {
                    return i;
                }
            }
            return null;
        },
        getLayerIndex: function(name) {
            return this.getIndex(this.layers, name);
        },
        getTilesetIndex: function(name) {
            return this.getIndex(this.tilesets, name);
        },
        getImageIndex: function(name) {
            return this.getIndex(this.images, name);
        },
        getObjectIndex: function(name) {
            return this.getIndex(this.objects, name);
        },
        setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                this.layers[layer].callbacks[indexes] = {
                    callback: callback,
                    callbackContext: callbackContext
                };
            } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                    this.layers[layer].callbacks[indexes[i]] = {
                        callback: callback,
                        callbackContext: callbackContext
                    };
                }
            }
        },
        setTileLocationCallback: function(x, y, width, height, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].setCollisionCallback(callback, callbackContext);
            }
        },
        setCollision: function(indexes, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                return this.setCollisionByIndex(indexes, collides, layer, true);
            } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                    this.setCollisionByIndex(indexes[i], collides, layer, false);
                }
                if (recalculate) {
                    this.calculateFaces(layer);
                }
            }
        },
        setCollisionBetween: function(start, stop, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (start > stop) {
                return;
            }
            for (var index = start; index <= stop; index++) {
                this.setCollisionByIndex(index, collides, layer, false);
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByExclusion: function(indexes, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            for (var i = 0, len = this.tiles.length; i < len; i++) {
                if (indexes.indexOf(i) === -1) {
                    this.setCollisionByIndex(i, collides, layer, false);
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByIndex: function(index, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof layer === "undefined") {
                layer = this.currentLayer;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            if (collides) {
                this.collideIndexes.push(index);
            } else {
                var i = this.collideIndexes.indexOf(index);
                if (i > -1) {
                    this.collideIndexes.splice(i, 1);
                }
            }
            for (var y = 0; y < this.layers[layer].height; y++) {
                for (var x = 0; x < this.layers[layer].width; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile && tile.index === index) {
                        if (collides) {
                            tile.setCollision(true, true, true, true);
                        } else {
                            tile.resetCollision();
                        }
                        tile.faceTop = collides;
                        tile.faceBottom = collides;
                        tile.faceLeft = collides;
                        tile.faceRight = collides;
                    }
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
            return layer;
        },
        getLayer: function(layer) {
            if (typeof layer === "undefined") {
                layer = this.currentLayer;
            } else if (typeof layer === "string") {
                layer = this.getLayerIndex(layer);
            } else if (layer instanceof Phaser.TilemapLayer) {
                layer = layer.index;
            }
            return layer;
        },
        setPreventRecalculate: function(value) {
            if (value === true && this.preventingRecalculate !== true) {
                this.preventingRecalculate = true;
                this.needToRecalculate = {};
            }
            if (value === false && this.preventingRecalculate === true) {
                this.preventingRecalculate = false;
                for (var i in this.needToRecalculate) {
                    this.calculateFaces(i);
                }
                this.needToRecalculate = false;
            }
        },
        calculateFaces: function(layer) {
            if (this.preventingRecalculate) {
                this.needToRecalculate[layer] = true;
                return;
            }
            var above = null;
            var below = null;
            var left = null;
            var right = null;
            for (var y = 0, h = this.layers[layer].height; y < h; y++) {
                for (var x = 0, w = this.layers[layer].width; x < w; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile) {
                        above = this.getTileAbove(layer, x, y);
                        below = this.getTileBelow(layer, x, y);
                        left = this.getTileLeft(layer, x, y);
                        right = this.getTileRight(layer, x, y);
                        if (tile.collides) {
                            tile.faceTop = true;
                            tile.faceBottom = true;
                            tile.faceLeft = true;
                            tile.faceRight = true;
                        }
                        if (above && above.collides) {
                            tile.faceTop = false;
                        }
                        if (below && below.collides) {
                            tile.faceBottom = false;
                        }
                        if (left && left.collides) {
                            tile.faceLeft = false;
                        }
                        if (right && right.collides) {
                            tile.faceRight = false;
                        }
                    }
                }
            }
        },
        getTileAbove: function(layer, x, y) {
            if (y > 0) {
                return this.layers[layer].data[y - 1][x];
            }
            return null;
        },
        getTileBelow: function(layer, x, y) {
            if (y < this.layers[layer].height - 1) {
                return this.layers[layer].data[y + 1][x];
            }
            return null;
        },
        getTileLeft: function(layer, x, y) {
            if (x > 0) {
                return this.layers[layer].data[y][x - 1];
            }
            return null;
        },
        getTileRight: function(layer, x, y) {
            if (x < this.layers[layer].width - 1) {
                return this.layers[layer].data[y][x + 1];
            }
            return null;
        },
        setLayer: function(layer) {
            layer = this.getLayer(layer);
            if (this.layers[layer]) {
                this.currentLayer = layer;
            }
        },
        hasTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            return this.layers[layer].data[y][x].index > -1;
        },
        removeTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.hasTile(x, y, layer)) {
                    var tile = this.layers[layer].data[y][x];
                    this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], -1, x, y, this.tileWidth, this.tileHeight);
                    this.layers[layer].dirty = true;
                    this.calculateFaces(layer);
                    return tile;
                }
            }
        },
        removeTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.removeTile(x, y, layer);
        },
        putTile: function(tile, x, y, layer) {
            if (tile === null) {
                return this.removeTile(x, y, layer);
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                var index;
                if (tile instanceof Phaser.Tile) {
                    index = tile.index;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].copy(tile);
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height);
                    }
                } else {
                    index = tile;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].index = index;
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight);
                    }
                }
                if (this.collideIndexes.indexOf(index) > -1) {
                    this.layers[layer].data[y][x].setCollision(true, true, true, true);
                } else {
                    this.layers[layer].data[y][x].resetCollision();
                }
                this.layers[layer].dirty = true;
                this.calculateFaces(layer);
                return this.layers[layer].data[y][x];
            }
            return null;
        },
        putTileWorldXY: function(tile, x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.putTile(tile, x, y, layer);
        },
        searchTileIndex: function(index, skip, reverse, layer) {
            if (typeof skip === "undefined") {
                skip = 0;
            }
            if (typeof reverse === "undefined") {
                reverse = false;
            }
            layer = this.getLayer(layer);
            var c = 0;
            if (reverse) {
                for (var y = this.layers[layer].height - 1; y >= 0; y--) {
                    for (var x = this.layers[layer].width - 1; x >= 0; x--) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            } else {
                for (var y = 0; y < this.layers[layer].height; y++) {
                    for (var x = 0; x < this.layers[layer].width; x++) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            }
            return null;
        },
        getTile: function(x, y, layer, nonNull) {
            if (typeof nonNull === "undefined") {
                nonNull = false;
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.layers[layer].data[y][x].index === -1) {
                    if (nonNull) {
                        return this.layers[layer].data[y][x];
                    } else {
                        return null;
                    }
                } else {
                    return this.layers[layer].data[y][x];
                }
            } else {
                return null;
            }
        },
        getTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
            if (typeof tileWidth === "undefined") {
                tileWidth = this.tileWidth;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = this.tileHeight;
            }
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.getTile(x, y, layer);
        },
        copy: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            if (!this.layers[layer]) {
                this._results.length = 0;
                return;
            }
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.layers[layer].width;
            }
            if (typeof height === "undefined") {
                height = this.layers[layer].height;
            }
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }
            if (width > this.layers[layer].width) {
                width = this.layers[layer].width;
            }
            if (height > this.layers[layer].height) {
                height = this.layers[layer].height;
            }
            this._results.length = 0;
            this._results.push({
                x: x,
                y: y,
                width: width,
                height: height,
                layer: layer
            });
            for (var ty = y; ty < y + height; ty++) {
                for (var tx = x; tx < x + width; tx++) {
                    this._results.push(this.layers[layer].data[ty][tx]);
                }
            }
            return this._results;
        },
        paste: function(x, y, tileblock, layer) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            layer = this.getLayer(layer);
            if (!tileblock || tileblock.length < 2) {
                return;
            }
            var diffX = tileblock[1].x - x;
            var diffY = tileblock[1].y - y;
            for (var i = 1; i < tileblock.length; i++) {
                this.layers[layer].data[diffY + tileblock[i].y][diffX + tileblock[i].x].copy(tileblock[i]);
            }
            this.layers[layer].dirty = true;
            this.calculateFaces(layer);
        },
        swap: function(tileA, tileB, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._tempA = tileA;
            this._tempB = tileB;
            this._results.forEach(this.swapHandler, this);
            this.paste(x, y, this._results, layer);
        },
        swapHandler: function(value) {
            if (value.index === this._tempA) {
                value.index = this._tempB;
            } else if (value.index === this._tempB) {
                value.index = this._tempA;
            }
        },
        forEach: function(callback, context, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._results.forEach(callback, context);
            this.paste(x, y, this._results, layer);
        },
        replace: function(source, dest, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                if (this._results[i].index === source) {
                    this._results[i].index = dest;
                }
            }
            this.paste(x, y, this._results, layer);
        },
        random: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    var idx = this._results[t].index;
                    if (indexes.indexOf(idx) === -1) {
                        indexes.push(idx);
                    }
                }
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = this.game.rnd.pick(indexes);
            }
            this.paste(x, y, this._results, layer);
        },
        shuffle: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    indexes.push(this._results[t].index);
                }
            }
            Phaser.Utils.shuffle(indexes);
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = indexes[i - 1];
            }
            this.paste(x, y, this._results, layer);
        },
        fill: function(index, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = index;
            }
            this.paste(x, y, this._results, layer);
        },
        removeAllLayers: function() {
            this.layers.length = 0;
            this.currentLayer = 0;
        },
        dump: function() {
            var txt = "";
            var args = [ "" ];
            for (var y = 0; y < this.layers[this.currentLayer].height; y++) {
                for (var x = 0; x < this.layers[this.currentLayer].width; x++) {
                    txt += "%c  ";
                    if (this.layers[this.currentLayer].data[y][x] > 1) {
                        if (this.debugMap[this.layers[this.currentLayer].data[y][x]]) {
                            args.push("background: " + this.debugMap[this.layers[this.currentLayer].data[y][x]]);
                        } else {
                            args.push("background: #ffffff");
                        }
                    } else {
                        args.push("background: rgb(0, 0, 0)");
                    }
                }
                txt += "\n";
            }
            args[0] = txt;
            console.log.apply(console, args);
        },
        destroy: function() {
            this.removeAllLayers();
            this.data = [];
            this.game = null;
        }
    };
    Phaser.Tilemap.prototype.constructor = Phaser.Tilemap;
    Object.defineProperty(Phaser.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer];
        },
        set: function(value) {
            if (value !== this.currentLayer) {
                this.setLayer(value);
            }
        }
    });
    Phaser.TilemapLayer = function(game, tilemap, index, width, height) {
        this.game = game;
        this.map = tilemap;
        this.index = index;
        this.layer = tilemap.layers[index];
        this.canvas = Phaser.Canvas.create(width, height, "", true);
        this.context = this.canvas.getContext("2d");
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "tilemapLayer", game.rnd.uuid());
        Phaser.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame);
        this.name = "";
        this.type = Phaser.TILEMAPLAYER;
        this.fixedToCamera = true;
        this.cameraOffset = new Phaser.Point(0, 0);
        this.tileColor = "rgb(255, 255, 255)";
        this.debug = false;
        this.debugAlpha = .5;
        this.debugColor = "rgba(0, 255, 0, 1)";
        this.debugFill = false;
        this.debugFillColor = "rgba(0, 255, 0, 0.2)";
        this.debugCallbackColor = "rgba(255, 0, 0, 1)";
        this.scrollFactorX = 1;
        this.scrollFactorY = 1;
        this.dirty = true;
        this.rayStepRate = 4;
        this.wrap = false;
        this._mc = {
            cw: tilemap.tileWidth,
            ch: tilemap.tileHeight,
            ga: 1,
            dx: 0,
            dy: 0,
            dw: 0,
            dh: 0,
            tx: 0,
            ty: 0,
            tw: 0,
            th: 0,
            tl: 0,
            maxX: 0,
            maxY: 0,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0
        };
        this._results = [];
        this.updateMax();
    };
    Phaser.TilemapLayer.prototype = Object.create(Phaser.Image.prototype);
    Phaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer;
    Phaser.TilemapLayer.prototype.postUpdate = function() {
        Phaser.Image.prototype.postUpdate.call(this);
        this.scrollX = this.game.camera.x * this.scrollFactorX;
        this.scrollY = this.game.camera.y * this.scrollFactorY;
        this.render();
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels);
    };
    Phaser.TilemapLayer.prototype._fixX = function(x) {
        if (x < 0) {
            x = 0;
        }
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._mc.x + (x - this._mc.x / this.scrollFactorX);
    };
    Phaser.TilemapLayer.prototype._unfixX = function(x) {
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._mc.x / this.scrollFactorX + (x - this._mc.x);
    };
    Phaser.TilemapLayer.prototype._fixY = function(y) {
        if (y < 0) {
            y = 0;
        }
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._mc.y + (y - this._mc.y / this.scrollFactorY);
    };
    Phaser.TilemapLayer.prototype._unfixY = function(y) {
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._mc.y / this.scrollFactorY + (y - this._mc.y);
    };
    Phaser.TilemapLayer.prototype.getTileX = function(x) {
        return this.game.math.snapToFloor(this._fixX(x), this.map.tileWidth) / this.map.tileWidth;
    };
    Phaser.TilemapLayer.prototype.getTileY = function(y) {
        return this.game.math.snapToFloor(this._fixY(y), this.map.tileHeight) / this.map.tileHeight;
    };
    Phaser.TilemapLayer.prototype.getTileXY = function(x, y, point) {
        point.x = this.getTileX(x);
        point.y = this.getTileY(y);
        return point;
    };
    Phaser.TilemapLayer.prototype.getRayCastTiles = function(line, stepRate, collides, interestingFace) {
        if (typeof stepRate === "undefined" || stepRate === null) {
            stepRate = this.rayStepRate;
        }
        if (typeof collides === "undefined") {
            collides = false;
        }
        if (typeof interestingFace === "undefined") {
            interestingFace = false;
        }
        var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);
        if (tiles.length === 0) {
            return [];
        }
        var coords = line.coordinatesOnLine(stepRate);
        var total = coords.length;
        var results = [];
        for (var i = 0; i < tiles.length; i++) {
            for (var t = 0; t < total; t++) {
                if (tiles[i].containsPoint(coords[t][0], coords[t][1])) {
                    results.push(tiles[i]);
                    break;
                }
            }
        }
        return results;
    };
    Phaser.TilemapLayer.prototype.getTiles = function(x, y, width, height, collides, interestingFace) {
        if (typeof collides === "undefined") {
            collides = false;
        }
        if (typeof interestingFace === "undefined") {
            interestingFace = false;
        }
        x = this._fixX(x);
        y = this._fixY(y);
        if (width > this.layer.widthInPixels) {
            width = this.layer.widthInPixels;
        }
        if (height > this.layer.heightInPixels) {
            height = this.layer.heightInPixels;
        }
        this._mc.tx = this.game.math.snapToFloor(x, this._mc.cw) / this._mc.cw;
        this._mc.ty = this.game.math.snapToFloor(y, this._mc.ch) / this._mc.ch;
        this._mc.tw = (this.game.math.snapToCeil(width, this._mc.cw) + this._mc.cw) / this._mc.cw;
        this._mc.th = (this.game.math.snapToCeil(height, this._mc.ch) + this._mc.ch) / this._mc.ch;
        this._results.length = 0;
        for (var wy = this._mc.ty; wy < this._mc.ty + this._mc.th; wy++) {
            for (var wx = this._mc.tx; wx < this._mc.tx + this._mc.tw; wx++) {
                if (this.layer.data[wy] && this.layer.data[wy][wx]) {
                    if (!collides && !interestingFace || this.layer.data[wy][wx].isInteresting(collides, interestingFace)) {
                        this._results.push(this.layer.data[wy][wx]);
                    }
                }
            }
        }
        return this._results;
    };
    Phaser.TilemapLayer.prototype.updateMax = function() {
        this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1;
        this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1;
        this.dirty = true;
    };
    Phaser.TilemapLayer.prototype.render = function() {
        if (this.layer.dirty) {
            this.dirty = true;
        }
        if (!this.dirty || !this.visible) {
            return;
        }
        this._mc.prevX = this._mc.dx;
        this._mc.prevY = this._mc.dy;
        this._mc.dx = -(this._mc.x - this._mc.startX * this.map.tileWidth);
        this._mc.dy = -(this._mc.y - this._mc.startY * this.map.tileHeight);
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillStyle = this.tileColor;
        var tile;
        var set;
        if (this.debug) {
            this.context.globalAlpha = this.debugAlpha;
        }
        for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++) {
            this._column = null;
            if (y < 0 && this.wrap) {
                this._column = this.layer.data[y + this.map.height];
            } else if (y >= this.map.height && this.wrap) {
                this._column = this.layer.data[y - this.map.height];
            } else if (this.layer.data[y]) {
                this._column = this.layer.data[y];
            }
            if (this._column) {
                for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++) {
                    var tile = null;
                    if (x < 0 && this.wrap) {
                        tile = this._column[x + this.map.width];
                    } else if (x >= this.map.width && this.wrap) {
                        tile = this._column[x - this.map.width];
                    } else if (this._column[x]) {
                        tile = this._column[x];
                    }
                    if (tile && tile.index > -1) {
                        set = this.map.tilesets[this.map.tiles[tile.index][2]];
                        if (this.debug === false && tile.alpha !== this.context.globalAlpha) {
                            this.context.globalAlpha = tile.alpha;
                        }
                        set.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), tile.index);
                        if (tile.debug) {
                            this.context.fillStyle = "rgba(0, 255, 0, 0.4)";
                            this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight);
                        }
                    }
                    this._mc.tx += this.map.tileWidth;
                }
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight;
        }
        if (this.debug) {
            this.context.globalAlpha = 1;
            this.renderDebug();
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
        }
        this.dirty = false;
        this.layer.dirty = false;
        return true;
    };
    Phaser.TilemapLayer.prototype.renderDebug = function() {
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.strokeStyle = this.debugColor;
        this.context.fillStyle = this.debugFillColor;
        for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++) {
            this._column = null;
            if (y < 0 && this.wrap) {
                this._column = this.layer.data[y + this.map.height];
            } else if (y >= this.map.height && this.wrap) {
                this._column = this.layer.data[y - this.map.height];
            } else if (this.layer.data[y]) {
                this._column = this.layer.data[y];
            }
            if (this._column) {
                for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++) {
                    var tile = null;
                    if (x < 0 && this.wrap) {
                        tile = this._column[x + this.map.width];
                    } else if (x >= this.map.width && this.wrap) {
                        tile = this._column[x - this.map.width];
                    } else if (this._column[x]) {
                        tile = this._column[x];
                    }
                    if (tile && (tile.faceTop || tile.faceBottom || tile.faceLeft || tile.faceRight)) {
                        this._mc.tx = Math.floor(this._mc.tx);
                        if (this.debugFill) {
                            this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch);
                        }
                        this.context.beginPath();
                        if (tile.faceTop) {
                            this.context.moveTo(this._mc.tx, this._mc.ty);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty);
                        }
                        if (tile.faceBottom) {
                            this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);
                        }
                        if (tile.faceLeft) {
                            this.context.moveTo(this._mc.tx, this._mc.ty);
                            this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch);
                        }
                        if (tile.faceRight) {
                            this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);
                        }
                        this.context.stroke();
                    }
                    this._mc.tx += this.map.tileWidth;
                }
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight;
        }
    };
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._mc.x;
        },
        set: function(value) {
            if (value !== this._mc.x) {
                this._mc.x = value;
                this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth);
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._mc.y;
        },
        set: function(value) {
            if (value !== this._mc.y) {
                this._mc.y = value;
                this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight);
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw;
        },
        set: function(value) {
            this._mc.cw = value;
            this.dirty = true;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch;
        },
        set: function(value) {
            this._mc.ch = value;
            this.dirty = true;
        }
    });
    Phaser.TilemapParser = {
        parse: function(game, key, tileWidth, tileHeight, width, height) {
            if (typeof tileWidth === "undefined") {
                tileWidth = 32;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = 32;
            }
            if (typeof width === "undefined") {
                width = 10;
            }
            if (typeof height === "undefined") {
                height = 10;
            }
            if (typeof key === "undefined") {
                return this.getEmptyData();
            }
            if (key === null) {
                return this.getEmptyData(tileWidth, tileHeight, width, height);
            }
            var map = game.cache.getTilemapData(key);
            if (map) {
                if (map.format === Phaser.Tilemap.CSV) {
                    return this.parseCSV(key, map.data, tileWidth, tileHeight);
                } else if (!map.format || map.format === Phaser.Tilemap.TILED_JSON) {
                    return this.parseTiledJSON(map.data);
                }
            } else {
                console.warn("Phaser.TilemapParser.parse - No map data found for key " + key);
            }
        },
        parseCSV: function(key, data, tileWidth, tileHeight) {
            var map = this.getEmptyData();
            data = data.trim();
            var output = [];
            var rows = data.split("\n");
            var height = rows.length;
            var width = 0;
            for (var y = 0; y < rows.length; y++) {
                output[y] = [];
                var column = rows[y].split(",");
                for (var x = 0; x < column.length; x++) {
                    output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight);
                }
                if (width === 0) {
                    width = column.length;
                }
            }
            map.format = Phaser.Tilemap.CSV;
            map.name = key;
            map.width = width;
            map.height = height;
            map.tileWidth = tileWidth;
            map.tileHeight = tileHeight;
            map.widthInPixels = width * tileWidth;
            map.heightInPixels = height * tileHeight;
            map.layers[0].width = width;
            map.layers[0].height = height;
            map.layers[0].widthInPixels = map.widthInPixels;
            map.layers[0].heightInPixels = map.heightInPixels;
            map.layers[0].data = output;
            return map;
        },
        getEmptyData: function(tileWidth, tileHeight, width, height) {
            var map = {};
            map.width = 0;
            map.height = 0;
            map.tileWidth = 0;
            map.tileHeight = 0;
            if (typeof tileWidth !== "undefined" && tileWidth !== null) {
                map.tileWidth = tileWidth;
            }
            if (typeof tileHeight !== "undefined" && tileHeight !== null) {
                map.tileHeight = tileHeight;
            }
            if (typeof width !== "undefined" && width !== null) {
                map.width = width;
            }
            if (typeof height !== "undefined" && height !== null) {
                map.height = height;
            }
            map.orientation = "orthogonal";
            map.version = "1";
            map.properties = {};
            map.widthInPixels = 0;
            map.heightInPixels = 0;
            var layers = [];
            var layer = {
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: []
            };
            layers.push(layer);
            map.layers = layers;
            map.images = [];
            map.objects = {};
            map.collision = {};
            map.tilesets = [];
            map.tiles = [];
            return map;
        },
        parseTiledJSON: function(json) {
            if (json.orientation !== "orthogonal") {
                console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser");
                return null;
            }
            var map = {};
            map.width = json.width;
            map.height = json.height;
            map.tileWidth = json.tilewidth;
            map.tileHeight = json.tileheight;
            map.orientation = json.orientation;
            map.format = Phaser.Tilemap.TILED_JSON;
            map.version = json.version;
            map.properties = json.properties;
            map.widthInPixels = map.width * map.tileWidth;
            map.heightInPixels = map.height * map.tileHeight;
            var layers = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "tilelayer") {
                    continue;
                }
                var layer = {
                    name: json.layers[i].name,
                    x: json.layers[i].x,
                    y: json.layers[i].y,
                    width: json.layers[i].width,
                    height: json.layers[i].height,
                    widthInPixels: json.layers[i].width * json.tilewidth,
                    heightInPixels: json.layers[i].height * json.tileheight,
                    alpha: json.layers[i].opacity,
                    visible: json.layers[i].visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                if (json.layers[i].properties) {
                    layer.properties = json.layers[i].properties;
                }
                var x = 0;
                var row = [];
                var output = [];
                for (var t = 0, len = json.layers[i].data.length; t < len; t++) {
                    if (json.layers[i].data[t] > 0) {
                        row.push(new Phaser.Tile(layer, json.layers[i].data[t], x, output.length, json.tilewidth, json.tileheight));
                    } else {
                        row.push(new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight));
                    }
                    x++;
                    if (x === json.layers[i].width) {
                        output.push(row);
                        x = 0;
                        row = [];
                    }
                }
                layer.data = output;
                layers.push(layer);
            }
            map.layers = layers;
            var images = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "imagelayer") {
                    continue;
                }
                var image = {
                    name: json.layers[i].name,
                    image: json.layers[i].image,
                    x: json.layers[i].x,
                    y: json.layers[i].y,
                    alpha: json.layers[i].opacity,
                    visible: json.layers[i].visible,
                    properties: {}
                };
                if (json.layers[i].properties) {
                    image.properties = json.layers[i].properties;
                }
                images.push(image);
            }
            map.images = images;
            var tilesets = [];
            for (var i = 0; i < json.tilesets.length; i++) {
                var set = json.tilesets[i];
                var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                if (set.tileproperties) {
                    newSet.tileProperties = set.tileproperties;
                }
                newSet.rows = Math.round((set.imageheight - set.margin) / (set.tileheight + set.spacing));
                newSet.columns = Math.round((set.imagewidth - set.margin) / (set.tilewidth + set.spacing));
                newSet.total = newSet.rows * newSet.columns;
                if (newSet.rows % 1 !== 0 || newSet.columns % 1 !== 0) {
                    console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.");
                } else {
                    tilesets.push(newSet);
                }
            }
            map.tilesets = tilesets;
            var objects = {};
            var collision = {};
            function slice(obj, fields) {
                var sliced = {};
                for (var k in fields) {
                    var key = fields[k];
                    sliced[key] = obj[key];
                }
                return sliced;
            }
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "objectgroup") {
                    continue;
                }
                objects[json.layers[i].name] = [];
                collision[json.layers[i].name] = [];
                for (var v = 0, len = json.layers[i].objects.length; v < len; v++) {
                    if (json.layers[i].objects[v].gid) {
                        var object = {
                            gid: json.layers[i].objects[v].gid,
                            name: json.layers[i].objects[v].name,
                            x: json.layers[i].objects[v].x,
                            y: json.layers[i].objects[v].y,
                            visible: json.layers[i].objects[v].visible,
                            properties: json.layers[i].objects[v].properties
                        };
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].polyline) {
                        var object = {
                            name: json.layers[i].objects[v].name,
                            type: json.layers[i].objects[v].type,
                            x: json.layers[i].objects[v].x,
                            y: json.layers[i].objects[v].y,
                            width: json.layers[i].objects[v].width,
                            height: json.layers[i].objects[v].height,
                            visible: json.layers[i].objects[v].visible,
                            properties: json.layers[i].objects[v].properties
                        };
                        object.polyline = [];
                        for (var p = 0; p < json.layers[i].objects[v].polyline.length; p++) {
                            object.polyline.push([ json.layers[i].objects[v].polyline[p].x, json.layers[i].objects[v].polyline[p].y ]);
                        }
                        collision[json.layers[i].name].push(object);
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].polygon) {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "visible", "properties" ]);
                        object.polygon = [];
                        for (var p = 0; p < json.layers[i].objects[v].polygon.length; p++) {
                            object.polygon.push([ json.layers[i].objects[v].polygon[p].x, json.layers[i].objects[v].polygon[p].y ]);
                        }
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].ellipse) {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "ellipse", "x", "y", "width", "height", "visible", "properties" ]);
                        objects[json.layers[i].name].push(object);
                    } else {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "width", "height", "visible", "properties" ]);
                        object.rectangle = true;
                        objects[json.layers[i].name].push(object);
                    }
                }
            }
            map.objects = objects;
            map.collision = collision;
            map.tiles = [];
            for (var i = 0; i < map.tilesets.length; i++) {
                var set = map.tilesets[i];
                var x = set.tileMargin;
                var y = set.tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                    map.tiles[t] = [ x, y, i ];
                    x += set.tileWidth + set.tileSpacing;
                    count++;
                    if (count === set.total) {
                        break;
                    }
                    countX++;
                    if (countX === set.columns) {
                        x = set.tileMargin;
                        y += set.tileHeight + set.tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === set.rows) {
                            break;
                        }
                    }
                }
            }
            var i, j, k;
            var layer, tile, sid, set;
            for (i = 0; i < map.layers.length; i++) {
                layer = map.layers[i];
                for (j = 0; j < layer.data.length; j++) {
                    row = layer.data[j];
                    for (k = 0; k < row.length; k++) {
                        tile = row[k];
                        if (tile.index < 0) {
                            continue;
                        }
                        sid = map.tiles[tile.index][2];
                        set = map.tilesets[sid];
                        if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                            tile.properties = set.tileProperties[tile.index - set.firstgid];
                        }
                    }
                }
            }
            return map;
        }
    };
    Phaser.Tileset = function(name, firstgid, width, height, margin, spacing, properties) {
        if (typeof width === "undefined" || width <= 0) {
            width = 32;
        }
        if (typeof height === "undefined" || height <= 0) {
            height = 32;
        }
        if (typeof margin === "undefined") {
            margin = 0;
        }
        if (typeof spacing === "undefined") {
            spacing = 0;
        }
        this.name = name;
        this.firstgid = firstgid;
        this.tileWidth = width;
        this.tileHeight = height;
        this.tileMargin = margin;
        this.tileSpacing = spacing;
        this.properties = properties;
        this.image = null;
        this.rows = 0;
        this.columns = 0;
        this.total = 0;
        this.drawCoords = [];
    };
    Phaser.Tileset.prototype = {
        draw: function(context, x, y, index) {
            if (!this.image || !this.drawCoords[index]) {
                return;
            }
            context.drawImage(this.image, this.drawCoords[index][0], this.drawCoords[index][1], this.tileWidth, this.tileHeight, x, y, this.tileWidth, this.tileHeight);
        },
        setImage: function(image) {
            this.image = image;
            this.rows = Math.round((image.height - this.tileMargin) / (this.tileHeight + this.tileSpacing));
            this.columns = Math.round((image.width - this.tileMargin) / (this.tileWidth + this.tileSpacing));
            this.total = this.rows * this.columns;
            this.drawCoords.length = 0;
            var tx = this.tileMargin;
            var ty = this.tileMargin;
            var i = this.firstgid;
            for (var y = 0; y < this.rows; y++) {
                for (var x = 0; x < this.columns; x++) {
                    this.drawCoords[i] = [ tx, ty ];
                    tx += this.tileWidth + this.tileSpacing;
                    i++;
                }
                tx = this.tileMargin;
                ty += this.tileHeight + this.tileSpacing;
            }
        },
        setSpacing: function(margin, spacing) {
            this.tileMargin = margin;
            this.tileSpacing = spacing;
            this.setImage(this.image);
        }
    };
    Phaser.Tileset.prototype.constructor = Phaser.Tileset;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = Phaser;
        }
        exports.Phaser = Phaser;
    } else if (typeof define !== "undefined" && define.amd) {
        define("Phaser", function() {
            return root.Phaser = Phaser;
        }());
    } else {
        root.Phaser = Phaser;
    }
}).call(this);

!function(e) {
    "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define("p2", function() {
        return this.p2 = e();
    }()) : "undefined" != typeof window ? window.p2 = e() : "undefined" != typeof global ? self.p2 = e() : "undefined" != typeof self && (self.p2 = e());
}(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'");
                }
                var f = n[o] = {
                    exports: {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            require = function e(t, n, r) {
                function s(o, u) {
                    if (!n[o]) {
                        if (!t[o]) {
                            var a = typeof require == "function" && require;
                            if (!u && a) return a(o, !0);
                            if (i) return i(o, !0);
                            throw new Error("Cannot find module '" + o + "'");
                        }
                        var f = n[o] = {
                            exports: {}
                        };
                        t[o][0].call(f.exports, function(e) {
                            var n = t[o][1][e];
                            return s(n ? n : e);
                        }, f, f.exports, e, t, n, r);
                    }
                    return n[o].exports;
                }
                var i = typeof require == "function" && require;
                for (var o = 0; o < r.length; o++) s(r[o]);
                return s;
            }({
                PcZj9L: [ function(require, module, exports) {
                    var TA = require("typedarray");
                    var xDataView = typeof DataView === "undefined" ? TA.DataView : DataView;
                    var xArrayBuffer = typeof ArrayBuffer === "undefined" ? TA.ArrayBuffer : ArrayBuffer;
                    var xUint8Array = typeof Uint8Array === "undefined" ? TA.Uint8Array : Uint8Array;
                    exports.Buffer = Buffer;
                    exports.SlowBuffer = Buffer;
                    exports.INSPECT_MAX_BYTES = 50;
                    Buffer.poolSize = 8192;
                    var browserSupport;
                    function Buffer(subject, encoding) {
                        var type = typeof subject;
                        if (encoding === "base64" && type === "string") {
                            subject = stringtrim(subject);
                            while (subject.length % 4 !== 0) {
                                subject = subject + "=";
                            }
                        }
                        var length;
                        if (type === "number") length = coerce(subject); else if (type === "string") length = Buffer.byteLength(subject, encoding); else if (type === "object") length = coerce(subject.length); else throw new Error("First argument needs to be a number, array or string.");
                        var buf = augment(new xUint8Array(length));
                        if (Buffer.isBuffer(subject)) {
                            buf.set(subject);
                        } else if (isArrayIsh(subject)) {
                            for (var i = 0; i < length; i++) {
                                if (Buffer.isBuffer(subject)) buf[i] = subject.readUInt8(i); else buf[i] = subject[i];
                            }
                        } else if (type === "string") {
                            buf.write(subject, 0, encoding);
                        }
                        return buf;
                    }
                    Buffer.isEncoding = function(encoding) {
                        switch ((encoding + "").toLowerCase()) {
                          case "hex":
                          case "utf8":
                          case "utf-8":
                          case "ascii":
                          case "binary":
                          case "base64":
                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                          case "raw":
                            return true;

                          default:
                            return false;
                        }
                    };
                    Buffer.isBuffer = function isBuffer(b) {
                        return b && b._isBuffer;
                    };
                    Buffer.byteLength = function(str, encoding) {
                        switch (encoding || "utf8") {
                          case "hex":
                            return str.length / 2;

                          case "utf8":
                          case "utf-8":
                            return utf8ToBytes(str).length;

                          case "ascii":
                          case "binary":
                            return str.length;

                          case "base64":
                            return base64ToBytes(str).length;

                          default:
                            throw new Error("Unknown encoding");
                        }
                    };
                    Buffer.concat = function(list, totalLength) {
                        if (!Array.isArray(list)) {
                            throw new Error("Usage: Buffer.concat(list, [totalLength])\n" + "list should be an Array.");
                        }
                        var i;
                        var buf;
                        if (list.length === 0) {
                            return new Buffer(0);
                        } else if (list.length === 1) {
                            return list[0];
                        }
                        if (typeof totalLength !== "number") {
                            totalLength = 0;
                            for (i = 0; i < list.length; i++) {
                                buf = list[i];
                                totalLength += buf.length;
                            }
                        }
                        var buffer = new Buffer(totalLength);
                        var pos = 0;
                        for (i = 0; i < list.length; i++) {
                            buf = list[i];
                            buf.copy(buffer, pos);
                            pos += buf.length;
                        }
                        return buffer;
                    };
                    function _hexWrite(buf, string, offset, length) {
                        offset = Number(offset) || 0;
                        var remaining = buf.length - offset;
                        if (!length) {
                            length = remaining;
                        } else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        var strLen = string.length;
                        if (strLen % 2 !== 0) {
                            throw new Error("Invalid hex string");
                        }
                        if (length > strLen / 2) {
                            length = strLen / 2;
                        }
                        for (var i = 0; i < length; i++) {
                            var byte = parseInt(string.substr(i * 2, 2), 16);
                            if (isNaN(byte)) throw new Error("Invalid hex string");
                            buf[offset + i] = byte;
                        }
                        Buffer._charsWritten = i * 2;
                        return i;
                    }
                    function _utf8Write(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
                    }
                    function _asciiWrite(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
                    }
                    function _binaryWrite(buf, string, offset, length) {
                        return _asciiWrite(buf, string, offset, length);
                    }
                    function _base64Write(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
                    }
                    function BufferWrite(string, offset, length, encoding) {
                        if (isFinite(offset)) {
                            if (!isFinite(length)) {
                                encoding = length;
                                length = undefined;
                            }
                        } else {
                            var swap = encoding;
                            encoding = offset;
                            offset = length;
                            length = swap;
                        }
                        offset = Number(offset) || 0;
                        var remaining = this.length - offset;
                        if (!length) {
                            length = remaining;
                        } else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        encoding = String(encoding || "utf8").toLowerCase();
                        switch (encoding) {
                          case "hex":
                            return _hexWrite(this, string, offset, length);

                          case "utf8":
                          case "utf-8":
                            return _utf8Write(this, string, offset, length);

                          case "ascii":
                            return _asciiWrite(this, string, offset, length);

                          case "binary":
                            return _binaryWrite(this, string, offset, length);

                          case "base64":
                            return _base64Write(this, string, offset, length);

                          default:
                            throw new Error("Unknown encoding");
                        }
                    }
                    function BufferToString(encoding, start, end) {
                        var self = this instanceof ProxyBuffer ? this._proxy : this;
                        encoding = String(encoding || "utf8").toLowerCase();
                        start = Number(start) || 0;
                        end = end !== undefined ? Number(end) : end = self.length;
                        if (end === start) return "";
                        switch (encoding) {
                          case "hex":
                            return _hexSlice(self, start, end);

                          case "utf8":
                          case "utf-8":
                            return _utf8Slice(self, start, end);

                          case "ascii":
                            return _asciiSlice(self, start, end);

                          case "binary":
                            return _binarySlice(self, start, end);

                          case "base64":
                            return _base64Slice(self, start, end);

                          default:
                            throw new Error("Unknown encoding");
                        }
                    }
                    function BufferToJSON() {
                        return {
                            type: "Buffer",
                            data: Array.prototype.slice.call(this, 0)
                        };
                    }
                    function BufferCopy(target, target_start, start, end) {
                        var source = this;
                        if (!start) start = 0;
                        if (!end && end !== 0) end = this.length;
                        if (!target_start) target_start = 0;
                        if (end === start) return;
                        if (target.length === 0 || source.length === 0) return;
                        if (end < start) throw new Error("sourceEnd < sourceStart");
                        if (target_start < 0 || target_start >= target.length) throw new Error("targetStart out of bounds");
                        if (start < 0 || start >= source.length) throw new Error("sourceStart out of bounds");
                        if (end < 0 || end > source.length) throw new Error("sourceEnd out of bounds");
                        if (end > this.length) end = this.length;
                        if (target.length - target_start < end - start) end = target.length - target_start + start;
                        for (var i = 0; i < end - start; i++) target[i + target_start] = this[i + start];
                    }
                    function _base64Slice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        return require("base64-js").fromByteArray(bytes);
                    }
                    function _utf8Slice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var res = "";
                        var tmp = "";
                        var i = 0;
                        while (i < bytes.length) {
                            if (bytes[i] <= 127) {
                                res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
                                tmp = "";
                            } else {
                                tmp += "%" + bytes[i].toString(16);
                            }
                            i++;
                        }
                        return res + decodeUtf8Char(tmp);
                    }
                    function _asciiSlice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var ret = "";
                        for (var i = 0; i < bytes.length; i++) ret += String.fromCharCode(bytes[i]);
                        return ret;
                    }
                    function _binarySlice(buf, start, end) {
                        return _asciiSlice(buf, start, end);
                    }
                    function _hexSlice(buf, start, end) {
                        var len = buf.length;
                        if (!start || start < 0) start = 0;
                        if (!end || end < 0 || end > len) end = len;
                        var out = "";
                        for (var i = start; i < end; i++) {
                            out += toHex(buf[i]);
                        }
                        return out;
                    }
                    function BufferSlice(start, end) {
                        var len = this.length;
                        start = clamp(start, len, 0);
                        end = clamp(end, len, len);
                        return augment(this.subarray(start, end));
                    }
                    function BufferReadUInt8(offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to read beyond buffer length");
                        }
                        if (offset >= buf.length) return;
                        return buf[offset];
                    }
                    function _readUInt16(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint8(0, buf[len - 1]);
                            return dv.getUint16(0, littleEndian);
                        } else {
                            return buf._dataview.getUint16(offset, littleEndian);
                        }
                    }
                    function BufferReadUInt16LE(offset, noAssert) {
                        return _readUInt16(this, offset, true, noAssert);
                    }
                    function BufferReadUInt16BE(offset, noAssert) {
                        return _readUInt16(this, offset, false, noAssert);
                    }
                    function _readUInt32(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            for (var i = 0; i + offset < len; i++) {
                                dv.setUint8(i, buf[i + offset]);
                            }
                            return dv.getUint32(0, littleEndian);
                        } else {
                            return buf._dataview.getUint32(offset, littleEndian);
                        }
                    }
                    function BufferReadUInt32LE(offset, noAssert) {
                        return _readUInt32(this, offset, true, noAssert);
                    }
                    function BufferReadUInt32BE(offset, noAssert) {
                        return _readUInt32(this, offset, false, noAssert);
                    }
                    function BufferReadInt8(offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to read beyond buffer length");
                        }
                        if (offset >= buf.length) return;
                        return buf._dataview.getInt8(offset);
                    }
                    function _readInt16(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint8(0, buf[len - 1]);
                            return dv.getInt16(0, littleEndian);
                        } else {
                            return buf._dataview.getInt16(offset, littleEndian);
                        }
                    }
                    function BufferReadInt16LE(offset, noAssert) {
                        return _readInt16(this, offset, true, noAssert);
                    }
                    function BufferReadInt16BE(offset, noAssert) {
                        return _readInt16(this, offset, false, noAssert);
                    }
                    function _readInt32(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            for (var i = 0; i + offset < len; i++) {
                                dv.setUint8(i, buf[i + offset]);
                            }
                            return dv.getInt32(0, littleEndian);
                        } else {
                            return buf._dataview.getInt32(offset, littleEndian);
                        }
                    }
                    function BufferReadInt32LE(offset, noAssert) {
                        return _readInt32(this, offset, true, noAssert);
                    }
                    function BufferReadInt32BE(offset, noAssert) {
                        return _readInt32(this, offset, false, noAssert);
                    }
                    function _readFloat(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        return buf._dataview.getFloat32(offset, littleEndian);
                    }
                    function BufferReadFloatLE(offset, noAssert) {
                        return _readFloat(this, offset, true, noAssert);
                    }
                    function BufferReadFloatBE(offset, noAssert) {
                        return _readFloat(this, offset, false, noAssert);
                    }
                    function _readDouble(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset + 7 < buf.length, "Trying to read beyond buffer length");
                        }
                        return buf._dataview.getFloat64(offset, littleEndian);
                    }
                    function BufferReadDoubleLE(offset, noAssert) {
                        return _readDouble(this, offset, true, noAssert);
                    }
                    function BufferReadDoubleBE(offset, noAssert) {
                        return _readDouble(this, offset, false, noAssert);
                    }
                    function BufferWriteUInt8(value, offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 255);
                        }
                        if (offset >= buf.length) return;
                        buf[offset] = value;
                    }
                    function _writeUInt16(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 65535);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint16(0, value, littleEndian);
                            buf[offset] = dv.getUint8(0);
                        } else {
                            buf._dataview.setUint16(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteUInt16LE(value, offset, noAssert) {
                        _writeUInt16(this, value, offset, true, noAssert);
                    }
                    function BufferWriteUInt16BE(value, offset, noAssert) {
                        _writeUInt16(this, value, offset, false, noAssert);
                    }
                    function _writeUInt32(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 4294967295);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setUint32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setUint32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteUInt32LE(value, offset, noAssert) {
                        _writeUInt32(this, value, offset, true, noAssert);
                    }
                    function BufferWriteUInt32BE(value, offset, noAssert) {
                        _writeUInt32(this, value, offset, false, noAssert);
                    }
                    function BufferWriteInt8(value, offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 127, -128);
                        }
                        if (offset >= buf.length) return;
                        buf._dataview.setInt8(offset, value);
                    }
                    function _writeInt16(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 32767, -32768);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setInt16(0, value, littleEndian);
                            buf[offset] = dv.getUint8(0);
                        } else {
                            buf._dataview.setInt16(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteInt16LE(value, offset, noAssert) {
                        _writeInt16(this, value, offset, true, noAssert);
                    }
                    function BufferWriteInt16BE(value, offset, noAssert) {
                        _writeInt16(this, value, offset, false, noAssert);
                    }
                    function _writeInt32(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 2147483647, -2147483648);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setInt32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setInt32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteInt32LE(value, offset, noAssert) {
                        _writeInt32(this, value, offset, true, noAssert);
                    }
                    function BufferWriteInt32BE(value, offset, noAssert) {
                        _writeInt32(this, value, offset, false, noAssert);
                    }
                    function _writeFloat(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
                            verifIEEE754(value, 3.4028234663852886e38, -3.4028234663852886e38);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setFloat32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setFloat32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteFloatLE(value, offset, noAssert) {
                        _writeFloat(this, value, offset, true, noAssert);
                    }
                    function BufferWriteFloatBE(value, offset, noAssert) {
                        _writeFloat(this, value, offset, false, noAssert);
                    }
                    function _writeDouble(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 7 < buf.length, "Trying to write beyond buffer length");
                            verifIEEE754(value, 1.7976931348623157e308, -1.7976931348623157e308);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 7 >= len) {
                            var dv = new xDataView(new xArrayBuffer(8));
                            dv.setFloat64(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setFloat64(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteDoubleLE(value, offset, noAssert) {
                        _writeDouble(this, value, offset, true, noAssert);
                    }
                    function BufferWriteDoubleBE(value, offset, noAssert) {
                        _writeDouble(this, value, offset, false, noAssert);
                    }
                    function BufferFill(value, start, end) {
                        if (!value) value = 0;
                        if (!start) start = 0;
                        if (!end) end = this.length;
                        if (typeof value === "string") {
                            value = value.charCodeAt(0);
                        }
                        if (typeof value !== "number" || isNaN(value)) {
                            throw new Error("value is not a number");
                        }
                        if (end < start) throw new Error("end < start");
                        if (end === start) return;
                        if (this.length === 0) return;
                        if (start < 0 || start >= this.length) {
                            throw new Error("start out of bounds");
                        }
                        if (end < 0 || end > this.length) {
                            throw new Error("end out of bounds");
                        }
                        for (var i = start; i < end; i++) {
                            this[i] = value;
                        }
                    }
                    function BufferInspect() {
                        var out = [];
                        var len = this.length;
                        for (var i = 0; i < len; i++) {
                            out[i] = toHex(this[i]);
                            if (i === exports.INSPECT_MAX_BYTES) {
                                out[i + 1] = "...";
                                break;
                            }
                        }
                        return "<Buffer " + out.join(" ") + ">";
                    }
                    function BufferToArrayBuffer() {
                        return new Buffer(this).buffer;
                    }
                    function stringtrim(str) {
                        if (str.trim) return str.trim();
                        return str.replace(/^\s+|\s+$/g, "");
                    }
                    function _browserSupport() {
                        var arr = new xUint8Array(0);
                        arr.foo = function() {
                            return 42;
                        };
                        try {
                            return 42 === arr.foo();
                        } catch (e) {
                            return false;
                        }
                    }
                    function ProxyBuffer(arr) {
                        this._arr = arr;
                        if (arr.byteLength !== 0) this._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength);
                    }
                    ProxyBuffer.prototype.write = BufferWrite;
                    ProxyBuffer.prototype.toString = BufferToString;
                    ProxyBuffer.prototype.toLocaleString = BufferToString;
                    ProxyBuffer.prototype.toJSON = BufferToJSON;
                    ProxyBuffer.prototype.copy = BufferCopy;
                    ProxyBuffer.prototype.slice = BufferSlice;
                    ProxyBuffer.prototype.readUInt8 = BufferReadUInt8;
                    ProxyBuffer.prototype.readUInt16LE = BufferReadUInt16LE;
                    ProxyBuffer.prototype.readUInt16BE = BufferReadUInt16BE;
                    ProxyBuffer.prototype.readUInt32LE = BufferReadUInt32LE;
                    ProxyBuffer.prototype.readUInt32BE = BufferReadUInt32BE;
                    ProxyBuffer.prototype.readInt8 = BufferReadInt8;
                    ProxyBuffer.prototype.readInt16LE = BufferReadInt16LE;
                    ProxyBuffer.prototype.readInt16BE = BufferReadInt16BE;
                    ProxyBuffer.prototype.readInt32LE = BufferReadInt32LE;
                    ProxyBuffer.prototype.readInt32BE = BufferReadInt32BE;
                    ProxyBuffer.prototype.readFloatLE = BufferReadFloatLE;
                    ProxyBuffer.prototype.readFloatBE = BufferReadFloatBE;
                    ProxyBuffer.prototype.readDoubleLE = BufferReadDoubleLE;
                    ProxyBuffer.prototype.readDoubleBE = BufferReadDoubleBE;
                    ProxyBuffer.prototype.writeUInt8 = BufferWriteUInt8;
                    ProxyBuffer.prototype.writeUInt16LE = BufferWriteUInt16LE;
                    ProxyBuffer.prototype.writeUInt16BE = BufferWriteUInt16BE;
                    ProxyBuffer.prototype.writeUInt32LE = BufferWriteUInt32LE;
                    ProxyBuffer.prototype.writeUInt32BE = BufferWriteUInt32BE;
                    ProxyBuffer.prototype.writeInt8 = BufferWriteInt8;
                    ProxyBuffer.prototype.writeInt16LE = BufferWriteInt16LE;
                    ProxyBuffer.prototype.writeInt16BE = BufferWriteInt16BE;
                    ProxyBuffer.prototype.writeInt32LE = BufferWriteInt32LE;
                    ProxyBuffer.prototype.writeInt32BE = BufferWriteInt32BE;
                    ProxyBuffer.prototype.writeFloatLE = BufferWriteFloatLE;
                    ProxyBuffer.prototype.writeFloatBE = BufferWriteFloatBE;
                    ProxyBuffer.prototype.writeDoubleLE = BufferWriteDoubleLE;
                    ProxyBuffer.prototype.writeDoubleBE = BufferWriteDoubleBE;
                    ProxyBuffer.prototype.fill = BufferFill;
                    ProxyBuffer.prototype.inspect = BufferInspect;
                    ProxyBuffer.prototype.toArrayBuffer = BufferToArrayBuffer;
                    ProxyBuffer.prototype._isBuffer = true;
                    ProxyBuffer.prototype.subarray = function() {
                        return this._arr.subarray.apply(this._arr, arguments);
                    };
                    ProxyBuffer.prototype.set = function() {
                        return this._arr.set.apply(this._arr, arguments);
                    };
                    var ProxyHandler = {
                        get: function(target, name) {
                            if (name in target) return target[name]; else return target._arr[name];
                        },
                        set: function(target, name, value) {
                            target._arr[name] = value;
                        }
                    };
                    function augment(arr) {
                        if (browserSupport === undefined) {
                            browserSupport = _browserSupport();
                        }
                        if (browserSupport) {
                            arr.write = BufferWrite;
                            arr.toString = BufferToString;
                            arr.toLocaleString = BufferToString;
                            arr.toJSON = BufferToJSON;
                            arr.copy = BufferCopy;
                            arr.slice = BufferSlice;
                            arr.readUInt8 = BufferReadUInt8;
                            arr.readUInt16LE = BufferReadUInt16LE;
                            arr.readUInt16BE = BufferReadUInt16BE;
                            arr.readUInt32LE = BufferReadUInt32LE;
                            arr.readUInt32BE = BufferReadUInt32BE;
                            arr.readInt8 = BufferReadInt8;
                            arr.readInt16LE = BufferReadInt16LE;
                            arr.readInt16BE = BufferReadInt16BE;
                            arr.readInt32LE = BufferReadInt32LE;
                            arr.readInt32BE = BufferReadInt32BE;
                            arr.readFloatLE = BufferReadFloatLE;
                            arr.readFloatBE = BufferReadFloatBE;
                            arr.readDoubleLE = BufferReadDoubleLE;
                            arr.readDoubleBE = BufferReadDoubleBE;
                            arr.writeUInt8 = BufferWriteUInt8;
                            arr.writeUInt16LE = BufferWriteUInt16LE;
                            arr.writeUInt16BE = BufferWriteUInt16BE;
                            arr.writeUInt32LE = BufferWriteUInt32LE;
                            arr.writeUInt32BE = BufferWriteUInt32BE;
                            arr.writeInt8 = BufferWriteInt8;
                            arr.writeInt16LE = BufferWriteInt16LE;
                            arr.writeInt16BE = BufferWriteInt16BE;
                            arr.writeInt32LE = BufferWriteInt32LE;
                            arr.writeInt32BE = BufferWriteInt32BE;
                            arr.writeFloatLE = BufferWriteFloatLE;
                            arr.writeFloatBE = BufferWriteFloatBE;
                            arr.writeDoubleLE = BufferWriteDoubleLE;
                            arr.writeDoubleBE = BufferWriteDoubleBE;
                            arr.fill = BufferFill;
                            arr.inspect = BufferInspect;
                            arr.toArrayBuffer = BufferToArrayBuffer;
                            arr._isBuffer = true;
                            if (arr.byteLength !== 0) arr._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength);
                            return arr;
                        } else {
                            var proxyBuffer = new ProxyBuffer(arr);
                            var proxy = new Proxy(proxyBuffer, ProxyHandler);
                            proxyBuffer._proxy = proxy;
                            return proxy;
                        }
                    }
                    function clamp(index, len, defaultValue) {
                        if (typeof index !== "number") return defaultValue;
                        index = ~~index;
                        if (index >= len) return len;
                        if (index >= 0) return index;
                        index += len;
                        if (index >= 0) return index;
                        return 0;
                    }
                    function coerce(length) {
                        length = ~~Math.ceil(+length);
                        return length < 0 ? 0 : length;
                    }
                    function isArrayIsh(subject) {
                        return Array.isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === "object" && typeof subject.length === "number";
                    }
                    function toHex(n) {
                        if (n < 16) return "0" + n.toString(16);
                        return n.toString(16);
                    }
                    function utf8ToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; i++) if (str.charCodeAt(i) <= 127) byteArray.push(str.charCodeAt(i)); else {
                            var h = encodeURIComponent(str.charAt(i)).substr(1).split("%");
                            for (var j = 0; j < h.length; j++) byteArray.push(parseInt(h[j], 16));
                        }
                        return byteArray;
                    }
                    function asciiToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; i++) {
                            byteArray.push(str.charCodeAt(i) & 255);
                        }
                        return byteArray;
                    }
                    function base64ToBytes(str) {
                        return require("base64-js").toByteArray(str);
                    }
                    function blitBuffer(src, dst, offset, length) {
                        var pos, i = 0;
                        while (i < length) {
                            if (i + offset >= dst.length || i >= src.length) break;
                            dst[i + offset] = src[i];
                            i++;
                        }
                        return i;
                    }
                    function decodeUtf8Char(str) {
                        try {
                            return decodeURIComponent(str);
                        } catch (err) {
                            return String.fromCharCode(65533);
                        }
                    }
                    function verifuint(value, max) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value >= 0, "specified a negative value for writing an unsigned value");
                        assert(value <= max, "value is larger than maximum value for type");
                        assert(Math.floor(value) === value, "value has a fractional component");
                    }
                    function verifsint(value, max, min) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value <= max, "value larger than maximum allowed value");
                        assert(value >= min, "value smaller than minimum allowed value");
                        assert(Math.floor(value) === value, "value has a fractional component");
                    }
                    function verifIEEE754(value, max, min) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value <= max, "value larger than maximum allowed value");
                        assert(value >= min, "value smaller than minimum allowed value");
                    }
                    function assert(test, message) {
                        if (!test) throw new Error(message || "Failed assertion");
                    }
                }, {
                    "base64-js": 3,
                    typedarray: 4
                } ],
                "native-buffer-browserify": [ function(require, module, exports) {
                    module.exports = require("PcZj9L");
                }, {} ],
                3: [ function(require, module, exports) {
                    (function(exports) {
                        "use strict";
                        var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                        function b64ToByteArray(b64) {
                            var i, j, l, tmp, placeHolders, arr;
                            if (b64.length % 4 > 0) {
                                throw "Invalid string. Length must be a multiple of 4";
                            }
                            placeHolders = b64.indexOf("=");
                            placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;
                            arr = [];
                            l = placeHolders > 0 ? b64.length - 4 : b64.length;
                            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                                tmp = lookup.indexOf(b64[i]) << 18 | lookup.indexOf(b64[i + 1]) << 12 | lookup.indexOf(b64[i + 2]) << 6 | lookup.indexOf(b64[i + 3]);
                                arr.push((tmp & 16711680) >> 16);
                                arr.push((tmp & 65280) >> 8);
                                arr.push(tmp & 255);
                            }
                            if (placeHolders === 2) {
                                tmp = lookup.indexOf(b64[i]) << 2 | lookup.indexOf(b64[i + 1]) >> 4;
                                arr.push(tmp & 255);
                            } else if (placeHolders === 1) {
                                tmp = lookup.indexOf(b64[i]) << 10 | lookup.indexOf(b64[i + 1]) << 4 | lookup.indexOf(b64[i + 2]) >> 2;
                                arr.push(tmp >> 8 & 255);
                                arr.push(tmp & 255);
                            }
                            return arr;
                        }
                        function uint8ToBase64(uint8) {
                            var i, extraBytes = uint8.length % 3, output = "", temp, length;
                            function tripletToBase64(num) {
                                return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                            }
                            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                                output += tripletToBase64(temp);
                            }
                            switch (extraBytes) {
                              case 1:
                                temp = uint8[uint8.length - 1];
                                output += lookup[temp >> 2];
                                output += lookup[temp << 4 & 63];
                                output += "==";
                                break;

                              case 2:
                                temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                                output += lookup[temp >> 10];
                                output += lookup[temp >> 4 & 63];
                                output += lookup[temp << 2 & 63];
                                output += "=";
                                break;
                            }
                            return output;
                        }
                        module.exports.toByteArray = b64ToByteArray;
                        module.exports.fromByteArray = uint8ToBase64;
                    })();
                }, {} ],
                4: [ function(require, module, exports) {
                    var undefined = void 0;
                    var MAX_ARRAY_LENGTH = 1e5;
                    var ECMAScript = function() {
                        var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
                        return {
                            Class: function(v) {
                                return opts.call(v).replace(/^\[object *|\]$/g, "");
                            },
                            HasProperty: function(o, p) {
                                return p in o;
                            },
                            HasOwnProperty: function(o, p) {
                                return ophop.call(o, p);
                            },
                            IsCallable: function(o) {
                                return typeof o === "function";
                            },
                            ToInt32: function(v) {
                                return v >> 0;
                            },
                            ToUint32: function(v) {
                                return v >>> 0;
                            }
                        };
                    }();
                    var LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
                    function configureProperties(obj) {
                        if (getOwnPropertyNames && defineProperty) {
                            var props = getOwnPropertyNames(obj), i;
                            for (i = 0; i < props.length; i += 1) {
                                defineProperty(obj, props[i], {
                                    value: obj[props[i]],
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                            }
                        }
                    }
                    var defineProperty = Object.defineProperty || function(o, p, desc) {
                        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
                        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
                            Object.prototype.__defineGetter__.call(o, p, desc.get);
                        }
                        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
                            Object.prototype.__defineSetter__.call(o, p, desc.set);
                        }
                        if (ECMAScript.HasProperty(desc, "value")) {
                            o[p] = desc.value;
                        }
                        return o;
                    };
                    var getOwnPropertyNames = Object.getOwnPropertyNames || function getOwnPropertyNames(o) {
                        if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
                        var props = [], p;
                        for (p in o) {
                            if (ECMAScript.HasOwnProperty(o, p)) {
                                props.push(p);
                            }
                        }
                        return props;
                    };
                    function makeArrayAccessors(obj) {
                        if (!defineProperty) {
                            return;
                        }
                        if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
                        function makeArrayAccessor(index) {
                            defineProperty(obj, index, {
                                get: function() {
                                    return obj._getter(index);
                                },
                                set: function(v) {
                                    obj._setter(index, v);
                                },
                                enumerable: true,
                                configurable: false
                            });
                        }
                        var i;
                        for (i = 0; i < obj.length; i += 1) {
                            makeArrayAccessor(i);
                        }
                    }
                    function as_signed(value, bits) {
                        var s = 32 - bits;
                        return value << s >> s;
                    }
                    function as_unsigned(value, bits) {
                        var s = 32 - bits;
                        return value << s >>> s;
                    }
                    function packI8(n) {
                        return [ n & 255 ];
                    }
                    function unpackI8(bytes) {
                        return as_signed(bytes[0], 8);
                    }
                    function packU8(n) {
                        return [ n & 255 ];
                    }
                    function unpackU8(bytes) {
                        return as_unsigned(bytes[0], 8);
                    }
                    function packU8Clamped(n) {
                        n = round(Number(n));
                        return [ n < 0 ? 0 : n > 255 ? 255 : n & 255 ];
                    }
                    function packI16(n) {
                        return [ n >> 8 & 255, n & 255 ];
                    }
                    function unpackI16(bytes) {
                        return as_signed(bytes[0] << 8 | bytes[1], 16);
                    }
                    function packU16(n) {
                        return [ n >> 8 & 255, n & 255 ];
                    }
                    function unpackU16(bytes) {
                        return as_unsigned(bytes[0] << 8 | bytes[1], 16);
                    }
                    function packI32(n) {
                        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255 ];
                    }
                    function unpackI32(bytes) {
                        return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
                    }
                    function packU32(n) {
                        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255 ];
                    }
                    function unpackU32(bytes) {
                        return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
                    }
                    function packIEEE754(v, ebits, fbits) {
                        var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
                        function roundToEven(n) {
                            var w = floor(n), f = n - w;
                            if (f < .5) return w;
                            if (f > .5) return w + 1;
                            return w % 2 ? w + 1 : w;
                        }
                        if (v !== v) {
                            e = (1 << ebits) - 1;
                            f = pow(2, fbits - 1);
                            s = 0;
                        } else if (v === Infinity || v === -Infinity) {
                            e = (1 << ebits) - 1;
                            f = 0;
                            s = v < 0 ? 1 : 0;
                        } else if (v === 0) {
                            e = 0;
                            f = 0;
                            s = 1 / v === -Infinity ? 1 : 0;
                        } else {
                            s = v < 0;
                            v = abs(v);
                            if (v >= pow(2, 1 - bias)) {
                                e = min(floor(log(v) / LN2), 1023);
                                f = roundToEven(v / pow(2, e) * pow(2, fbits));
                                if (f / pow(2, fbits) >= 2) {
                                    e = e + 1;
                                    f = 1;
                                }
                                if (e > bias) {
                                    e = (1 << ebits) - 1;
                                    f = 0;
                                } else {
                                    e = e + bias;
                                    f = f - pow(2, fbits);
                                }
                            } else {
                                e = 0;
                                f = roundToEven(v / pow(2, 1 - bias - fbits));
                            }
                        }
                        bits = [];
                        for (i = fbits; i; i -= 1) {
                            bits.push(f % 2 ? 1 : 0);
                            f = floor(f / 2);
                        }
                        for (i = ebits; i; i -= 1) {
                            bits.push(e % 2 ? 1 : 0);
                            e = floor(e / 2);
                        }
                        bits.push(s ? 1 : 0);
                        bits.reverse();
                        str = bits.join("");
                        bytes = [];
                        while (str.length) {
                            bytes.push(parseInt(str.substring(0, 8), 2));
                            str = str.substring(8);
                        }
                        return bytes;
                    }
                    function unpackIEEE754(bytes, ebits, fbits) {
                        var bits = [], i, j, b, str, bias, s, e, f;
                        for (i = bytes.length; i; i -= 1) {
                            b = bytes[i - 1];
                            for (j = 8; j; j -= 1) {
                                bits.push(b % 2 ? 1 : 0);
                                b = b >> 1;
                            }
                        }
                        bits.reverse();
                        str = bits.join("");
                        bias = (1 << ebits - 1) - 1;
                        s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
                        e = parseInt(str.substring(1, 1 + ebits), 2);
                        f = parseInt(str.substring(1 + ebits), 2);
                        if (e === (1 << ebits) - 1) {
                            return f !== 0 ? NaN : s * Infinity;
                        } else if (e > 0) {
                            return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
                        } else if (f !== 0) {
                            return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
                        } else {
                            return s < 0 ? -0 : 0;
                        }
                    }
                    function unpackF64(b) {
                        return unpackIEEE754(b, 11, 52);
                    }
                    function packF64(v) {
                        return packIEEE754(v, 11, 52);
                    }
                    function unpackF32(b) {
                        return unpackIEEE754(b, 8, 23);
                    }
                    function packF32(v) {
                        return packIEEE754(v, 8, 23);
                    }
                    (function() {
                        var ArrayBuffer = function ArrayBuffer(length) {
                            length = ECMAScript.ToInt32(length);
                            if (length < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
                            this.byteLength = length;
                            this._bytes = [];
                            this._bytes.length = length;
                            var i;
                            for (i = 0; i < this.byteLength; i += 1) {
                                this._bytes[i] = 0;
                            }
                            configureProperties(this);
                        };
                        exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
                        var ArrayBufferView = function ArrayBufferView() {};
                        function makeConstructor(bytesPerElement, pack, unpack) {
                            var ctor;
                            ctor = function(buffer, byteOffset, length) {
                                var array, sequence, i, s;
                                if (!arguments.length || typeof arguments[0] === "number") {
                                    this.length = ECMAScript.ToInt32(arguments[0]);
                                    if (length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
                                    array = arguments[0];
                                    this.length = array.length;
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                    for (i = 0; i < this.length; i += 1) {
                                        this._setter(i, array._getter(i));
                                    }
                                } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
                                    sequence = arguments[0];
                                    this.length = ECMAScript.ToUint32(sequence.length);
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                    for (i = 0; i < this.length; i += 1) {
                                        s = sequence[i];
                                        this._setter(i, Number(s));
                                    }
                                } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
                                    this.buffer = buffer;
                                    this.byteOffset = ECMAScript.ToUint32(byteOffset);
                                    if (this.byteOffset > this.buffer.byteLength) {
                                        throw new RangeError("byteOffset out of range");
                                    }
                                    if (this.byteOffset % this.BYTES_PER_ELEMENT) {
                                        throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
                                    }
                                    if (arguments.length < 3) {
                                        this.byteLength = this.buffer.byteLength - this.byteOffset;
                                        if (this.byteLength % this.BYTES_PER_ELEMENT) {
                                            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
                                        }
                                        this.length = this.byteLength / this.BYTES_PER_ELEMENT;
                                    } else {
                                        this.length = ECMAScript.ToUint32(length);
                                        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    }
                                    if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
                                        throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
                                    }
                                } else {
                                    throw new TypeError("Unexpected argument type(s)");
                                }
                                this.constructor = ctor;
                                configureProperties(this);
                                makeArrayAccessors(this);
                            };
                            ctor.prototype = new ArrayBufferView();
                            ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
                            ctor.prototype._pack = pack;
                            ctor.prototype._unpack = unpack;
                            ctor.BYTES_PER_ELEMENT = bytesPerElement;
                            ctor.prototype._getter = function(index) {
                                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                                index = ECMAScript.ToUint32(index);
                                if (index >= this.length) {
                                    return undefined;
                                }
                                var bytes = [], i, o;
                                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                                o += 1) {
                                    bytes.push(this.buffer._bytes[o]);
                                }
                                return this._unpack(bytes);
                            };
                            ctor.prototype.get = ctor.prototype._getter;
                            ctor.prototype._setter = function(index, value) {
                                if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
                                index = ECMAScript.ToUint32(index);
                                if (index >= this.length) {
                                    return undefined;
                                }
                                var bytes = this._pack(value), i, o;
                                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                                o += 1) {
                                    this.buffer._bytes[o] = bytes[i];
                                }
                            };
                            ctor.prototype.set = function(index, value) {
                                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                                var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
                                if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
                                    array = arguments[0];
                                    offset = ECMAScript.ToUint32(arguments[1]);
                                    if (offset + array.length > this.length) {
                                        throw new RangeError("Offset plus length of array is out of range");
                                    }
                                    byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
                                    byteLength = array.length * this.BYTES_PER_ELEMENT;
                                    if (array.buffer === this.buffer) {
                                        tmp = [];
                                        for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                                            tmp[i] = array.buffer._bytes[s];
                                        }
                                        for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                                            this.buffer._bytes[d] = tmp[i];
                                        }
                                    } else {
                                        for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, 
                                        d += 1) {
                                            this.buffer._bytes[d] = array.buffer._bytes[s];
                                        }
                                    }
                                } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
                                    sequence = arguments[0];
                                    len = ECMAScript.ToUint32(sequence.length);
                                    offset = ECMAScript.ToUint32(arguments[1]);
                                    if (offset + len > this.length) {
                                        throw new RangeError("Offset plus length of array is out of range");
                                    }
                                    for (i = 0; i < len; i += 1) {
                                        s = sequence[i];
                                        this._setter(offset + i, Number(s));
                                    }
                                } else {
                                    throw new TypeError("Unexpected argument type(s)");
                                }
                            };
                            ctor.prototype.subarray = function(start, end) {
                                function clamp(v, min, max) {
                                    return v < min ? min : v > max ? max : v;
                                }
                                start = ECMAScript.ToInt32(start);
                                end = ECMAScript.ToInt32(end);
                                if (arguments.length < 1) {
                                    start = 0;
                                }
                                if (arguments.length < 2) {
                                    end = this.length;
                                }
                                if (start < 0) {
                                    start = this.length + start;
                                }
                                if (end < 0) {
                                    end = this.length + end;
                                }
                                start = clamp(start, 0, this.length);
                                end = clamp(end, 0, this.length);
                                var len = end - start;
                                if (len < 0) {
                                    len = 0;
                                }
                                return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
                            };
                            return ctor;
                        }
                        var Int8Array = makeConstructor(1, packI8, unpackI8);
                        var Uint8Array = makeConstructor(1, packU8, unpackU8);
                        var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
                        var Int16Array = makeConstructor(2, packI16, unpackI16);
                        var Uint16Array = makeConstructor(2, packU16, unpackU16);
                        var Int32Array = makeConstructor(4, packI32, unpackI32);
                        var Uint32Array = makeConstructor(4, packU32, unpackU32);
                        var Float32Array = makeConstructor(4, packF32, unpackF32);
                        var Float64Array = makeConstructor(8, packF64, unpackF64);
                        exports.Int8Array = exports.Int8Array || Int8Array;
                        exports.Uint8Array = exports.Uint8Array || Uint8Array;
                        exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
                        exports.Int16Array = exports.Int16Array || Int16Array;
                        exports.Uint16Array = exports.Uint16Array || Uint16Array;
                        exports.Int32Array = exports.Int32Array || Int32Array;
                        exports.Uint32Array = exports.Uint32Array || Uint32Array;
                        exports.Float32Array = exports.Float32Array || Float32Array;
                        exports.Float64Array = exports.Float64Array || Float64Array;
                    })();
                    (function() {
                        function r(array, index) {
                            return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
                        }
                        var IS_BIG_ENDIAN = function() {
                            var u16array = new exports.Uint16Array([ 4660 ]), u8array = new exports.Uint8Array(u16array.buffer);
                            return r(u8array, 0) === 18;
                        }();
                        var DataView = function DataView(buffer, byteOffset, byteLength) {
                            if (arguments.length === 0) {
                                buffer = new ArrayBuffer(0);
                            } else if (!(buffer instanceof ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
                                throw new TypeError("TypeError");
                            }
                            this.buffer = buffer || new ArrayBuffer(0);
                            this.byteOffset = ECMAScript.ToUint32(byteOffset);
                            if (this.byteOffset > this.buffer.byteLength) {
                                throw new RangeError("byteOffset out of range");
                            }
                            if (arguments.length < 3) {
                                this.byteLength = this.buffer.byteLength - this.byteOffset;
                            } else {
                                this.byteLength = ECMAScript.ToUint32(byteLength);
                            }
                            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
                                throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
                            }
                            configureProperties(this);
                        };
                        function makeGetter(arrayType) {
                            return function(byteOffset, littleEndian) {
                                byteOffset = ECMAScript.ToUint32(byteOffset);
                                if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
                                    throw new RangeError("Array index out of range");
                                }
                                byteOffset += this.byteOffset;
                                var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
                                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
                                    bytes.push(r(uint8Array, i));
                                }
                                if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
                                    bytes.reverse();
                                }
                                return r(new arrayType(new Uint8Array(bytes).buffer), 0);
                            };
                        }
                        DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
                        DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
                        DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
                        DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
                        DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
                        DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
                        DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
                        DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
                        function makeSetter(arrayType) {
                            return function(byteOffset, value, littleEndian) {
                                byteOffset = ECMAScript.ToUint32(byteOffset);
                                if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
                                    throw new RangeError("Array index out of range");
                                }
                                var typeArray = new arrayType([ value ]), byteArray = new Uint8Array(typeArray.buffer), bytes = [], i, byteView;
                                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
                                    bytes.push(r(byteArray, i));
                                }
                                if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
                                    bytes.reverse();
                                }
                                byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
                                byteView.set(bytes);
                            };
                        }
                        DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
                        DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
                        DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
                        DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
                        DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
                        DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
                        DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
                        DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
                        exports.DataView = exports.DataView || DataView;
                    })();
                }, {} ]
            }, {}, []);
            module.exports = require("native-buffer-browserify").Buffer;
        }, {} ],
        2: [ function(require, module, exports) {
            var process = module.exports = {};
            process.nextTick = function() {
                var canSetImmediate = typeof window !== "undefined" && window.setImmediate;
                var canPost = typeof window !== "undefined" && window.postMessage && window.addEventListener;
                if (canSetImmediate) {
                    return function(f) {
                        return window.setImmediate(f);
                    };
                }
                if (canPost) {
                    var queue = [];
                    window.addEventListener("message", function(ev) {
                        if (ev.source === window && ev.data === "process-tick") {
                            ev.stopPropagation();
                            if (queue.length > 0) {
                                var fn = queue.shift();
                                fn();
                            }
                        }
                    }, true);
                    return function nextTick(fn) {
                        queue.push(fn);
                        window.postMessage("process-tick", "*");
                    };
                }
                return function nextTick(fn) {
                    setTimeout(fn, 0);
                };
            }();
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.binding = function(name) {
                throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
                return "/";
            };
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            };
        }, {} ],
        3: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Line.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            var Scalar = require("./Scalar");
            module.exports = Line;
            function Line() {}
            Line.lineInt = function(l1, l2, precision) {
                precision = precision || 0;
                var i = [ 0, 0 ];
                var a1, b1, c1, a2, b2, c2, det;
                a1 = l1[1][1] - l1[0][1];
                b1 = l1[0][0] - l1[1][0];
                c1 = a1 * l1[0][0] + b1 * l1[0][1];
                a2 = l2[1][1] - l2[0][1];
                b2 = l2[0][0] - l2[1][0];
                c2 = a2 * l2[0][0] + b2 * l2[0][1];
                det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, precision)) {
                    i[0] = (b2 * c1 - b1 * c2) / det;
                    i[1] = (a1 * c2 - a2 * c1) / det;
                }
                return i;
            };
            Line.segmentsIntersect = function(p1, p2, q1, q2) {
                var dx = p2[0] - p1[0];
                var dy = p2[1] - p1[1];
                var da = q2[0] - q1[0];
                var db = q2[1] - q1[1];
                if (da * dy - db * dx == 0) return false;
                var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
                var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
                return s >= 0 && s <= 1 && t >= 0 && t <= 1;
            };
        }, {
            "./Scalar": 6,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        4: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Point.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = Point;
            function Point() {}
            Point.area = function(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            };
            Point.left = function(a, b, c) {
                return Point.area(a, b, c) > 0;
            };
            Point.leftOn = function(a, b, c) {
                return Point.area(a, b, c) >= 0;
            };
            Point.right = function(a, b, c) {
                return Point.area(a, b, c) < 0;
            };
            Point.rightOn = function(a, b, c) {
                return Point.area(a, b, c) <= 0;
            };
            var tmpPoint1 = [], tmpPoint2 = [];
            Point.collinear = function(a, b, c, thresholdAngle) {
                if (!thresholdAngle) return Point.area(a, b, c) == 0; else {
                    var ab = tmpPoint1, bc = tmpPoint2;
                    ab[0] = b[0] - a[0];
                    ab[1] = b[1] - a[1];
                    bc[0] = c[0] - b[0];
                    bc[1] = c[1] - b[1];
                    var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
                    return angle < thresholdAngle;
                }
            };
            Point.sqdist = function(a, b) {
                var dx = b[0] - a[0];
                var dy = b[1] - a[1];
                return dx * dx + dy * dy;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        5: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Polygon.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            var Line = require("./Line"), Point = require("./Point"), Scalar = require("./Scalar");
            module.exports = Polygon;
            function Polygon() {
                this.vertices = [];
            }
            Polygon.prototype.at = function(i) {
                var v = this.vertices, s = v.length;
                return v[i < 0 ? i % s + s : i % s];
            };
            Polygon.prototype.first = function() {
                return this.vertices[0];
            };
            Polygon.prototype.last = function() {
                return this.vertices[this.vertices.length - 1];
            };
            Polygon.prototype.clear = function() {
                this.vertices.length = 0;
            };
            Polygon.prototype.append = function(poly, from, to) {
                if (typeof from == "undefined") throw new Error("From is not given!");
                if (typeof to == "undefined") throw new Error("To is not given!");
                if (to - 1 < from) throw new Error("lol1");
                if (to > poly.vertices.length) throw new Error("lol2");
                if (from < 0) throw new Error("lol3");
                for (var i = from; i < to; i++) {
                    this.vertices.push(poly.vertices[i]);
                }
            };
            Polygon.prototype.makeCCW = function() {
                var br = 0, v = this.vertices;
                for (var i = 1; i < this.vertices.length; ++i) {
                    if (v[i][1] < v[br][1] || v[i][1] == v[br][1] && v[i][0] > v[br][0]) {
                        br = i;
                    }
                }
                if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
                    this.reverse();
                }
            };
            Polygon.prototype.reverse = function() {
                var tmp = [];
                for (var i = 0, N = this.vertices.length; i !== N; i++) {
                    tmp.push(this.vertices.pop());
                }
                this.vertices = tmp;
            };
            Polygon.prototype.isReflex = function(i) {
                return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
            };
            var tmpLine1 = [], tmpLine2 = [];
            Polygon.prototype.canSee = function(a, b) {
                var p, dist, l1 = tmpLine1, l2 = tmpLine2;
                if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
                    return false;
                }
                dist = Point.sqdist(this.at(a), this.at(b));
                for (var i = 0; i !== this.vertices.length; ++i) {
                    if ((i + 1) % this.vertices.length === a || i === a) continue;
                    if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) {
                        l1[0] = this.at(a);
                        l1[1] = this.at(b);
                        l2[0] = this.at(i);
                        l2[1] = this.at(i + 1);
                        p = Line.lineInt(l1, l2);
                        if (Point.sqdist(this.at(a), p) < dist) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Polygon.prototype.copy = function(i, j, targetPoly) {
                var p = targetPoly || new Polygon();
                p.clear();
                if (i < j) {
                    for (var k = i; k <= j; k++) p.vertices.push(this.vertices[k]);
                } else {
                    for (var k = 0; k <= j; k++) p.vertices.push(this.vertices[k]);
                    for (var k = i; k < this.vertices.length; k++) p.vertices.push(this.vertices[k]);
                }
                return p;
            };
            Polygon.prototype.getCutEdges = function() {
                var min = [], tmp1 = [], tmp2 = [], tmpPoly = new Polygon();
                var nDiags = Number.MAX_VALUE;
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (this.isReflex(i)) {
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (this.canSee(i, j)) {
                                tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                                tmp2 = this.copy(j, i, tmpPoly).getCutEdges();
                                for (var k = 0; k < tmp2.length; k++) tmp1.push(tmp2[k]);
                                if (tmp1.length < nDiags) {
                                    min = tmp1;
                                    nDiags = tmp1.length;
                                    min.push([ this.at(i), this.at(j) ]);
                                }
                            }
                        }
                    }
                }
                return min;
            };
            Polygon.prototype.decomp = function() {
                var edges = this.getCutEdges();
                if (edges.length > 0) return this.slice(edges); else return [ this ];
            };
            Polygon.prototype.slice = function(cutEdges) {
                if (cutEdges.length == 0) return [ this ];
                if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length == 2 && cutEdges[0][0] instanceof Array) {
                    var polys = [ this ];
                    for (var i = 0; i < cutEdges.length; i++) {
                        var cutEdge = cutEdges[i];
                        for (var j = 0; j < polys.length; j++) {
                            var poly = polys[j];
                            var result = poly.slice(cutEdge);
                            if (result) {
                                polys.splice(j, 1);
                                polys.push(result[0], result[1]);
                                break;
                            }
                        }
                    }
                    return polys;
                } else {
                    var cutEdge = cutEdges;
                    var i = this.vertices.indexOf(cutEdge[0]);
                    var j = this.vertices.indexOf(cutEdge[1]);
                    if (i != -1 && j != -1) {
                        return [ this.copy(i, j), this.copy(j, i) ];
                    } else {
                        return false;
                    }
                }
            };
            Polygon.prototype.isSimple = function() {
                var path = this.vertices;
                for (var i = 0; i < path.length - 1; i++) {
                    for (var j = 0; j < i - 1; j++) {
                        if (Line.segmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                            return false;
                        }
                    }
                }
                for (var i = 1; i < path.length - 2; i++) {
                    if (Line.segmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                        return false;
                    }
                }
                return true;
            };
            function getIntersectionPoint(p1, p2, q1, q2, delta) {
                delta = delta || 0;
                var a1 = p2[1] - p1[1];
                var b1 = p1[0] - p2[0];
                var c1 = a1 * p1[0] + b1 * p1[1];
                var a2 = q2[1] - q1[1];
                var b2 = q1[0] - q2[0];
                var c2 = a2 * q1[0] + b2 * q1[1];
                var det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, delta)) return [ (b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det ]; else return [ 0, 0 ];
            }
            Polygon.prototype.quickDecomp = function(result, reflexVertices, steinerPoints, delta, maxlevel, level) {
                maxlevel = maxlevel || 100;
                level = level || 0;
                delta = delta || 25;
                result = typeof result != "undefined" ? result : [];
                reflexVertices = reflexVertices || [];
                steinerPoints = steinerPoints || [];
                var upperInt = [ 0, 0 ], lowerInt = [ 0, 0 ], p = [ 0, 0 ];
                var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
                var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
                var lowerPoly = new Polygon(), upperPoly = new Polygon();
                var poly = this, v = this.vertices;
                if (v.length < 3) return result;
                level++;
                if (level > maxlevel) {
                    console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
                    return result;
                }
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (poly.isReflex(i)) {
                        reflexVertices.push(poly.vertices[i]);
                        upperDist = lowerDist = Number.MAX_VALUE;
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) {
                                p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1));
                                if (Point.right(poly.at(i + 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < lowerDist) {
                                        lowerDist = d;
                                        lowerInt = p;
                                        lowerIndex = j;
                                    }
                                }
                            }
                            if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                                if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < upperDist) {
                                        upperDist = d;
                                        upperInt = p;
                                        upperIndex = j;
                                    }
                                }
                            }
                        }
                        if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                            p[0] = (lowerInt[0] + upperInt[0]) / 2;
                            p[1] = (lowerInt[1] + upperInt[1]) / 2;
                            steinerPoints.push(p);
                            if (i < upperIndex) {
                                lowerPoly.append(poly, i, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                if (lowerIndex != 0) {
                                    upperPoly.append(poly, lowerIndex, poly.vertices.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, poly.vertices.length);
                                }
                                lowerPoly.append(poly, 0, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                upperPoly.append(poly, lowerIndex, i + 1);
                            }
                        } else {
                            if (lowerIndex > upperIndex) {
                                upperIndex += this.vertices.length;
                            }
                            closestDist = Number.MAX_VALUE;
                            if (upperIndex < lowerIndex) {
                                return result;
                            }
                            for (var j = lowerIndex; j <= upperIndex; ++j) {
                                if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                    d = Point.sqdist(poly.at(i), poly.at(j));
                                    if (d < closestDist) {
                                        closestDist = d;
                                        closestIndex = j % this.vertices.length;
                                    }
                                }
                            }
                            if (i < closestIndex) {
                                lowerPoly.append(poly, i, closestIndex + 1);
                                if (closestIndex != 0) {
                                    upperPoly.append(poly, closestIndex, v.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, v.length);
                                }
                                lowerPoly.append(poly, 0, closestIndex + 1);
                                upperPoly.append(poly, closestIndex, i + 1);
                            }
                        }
                        if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        } else {
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        }
                        return result;
                    }
                }
                result.push(this);
                return result;
            };
            Polygon.prototype.removeCollinearPoints = function(precision) {
                var num = 0;
                for (var i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) {
                    if (Point.collinear(this.at(i - 1), this.at(i), this.at(i + 1), precision)) {
                        this.vertices.splice(i % this.vertices.length, 1);
                        i--;
                        num++;
                    }
                }
                return num;
            };
        }, {
            "./Line": 3,
            "./Point": 4,
            "./Scalar": 6,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        6: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Scalar.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = Scalar;
            function Scalar() {}
            Scalar.eq = function(a, b, precision) {
                precision = precision || 0;
                return Math.abs(a - b) < precision;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        7: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\index.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = {
                Polygon: require("./Polygon"),
                Point: require("./Point")
            };
        }, {
            "./Point": 4,
            "./Polygon": 5,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        8: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\package.json", __dirname = "/..";
            module.exports = {
                name: "p2",
                version: "0.6.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: [ "p2.js", "p2", "physics", "engine", "2d" ],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [ {
                    type: "MIT"
                } ],
                devDependencies: {
                    grunt: "~0.4.0",
                    "grunt-contrib-jshint": "~0.9.2",
                    "grunt-contrib-nodeunit": "~0.1.2",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        9: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\AABB.js", __dirname = "/collision";
            var vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = AABB;
            function AABB(options) {
                this.lowerBound = vec2.create();
                if (options && options.lowerBound) {
                    vec2.copy(this.lowerBound, options.lowerBound);
                }
                this.upperBound = vec2.create();
                if (options && options.upperBound) {
                    vec2.copy(this.upperBound, options.upperBound);
                }
            }
            var tmp = vec2.create();
            AABB.prototype.setFromPoints = function(points, position, angle, skinSize) {
                var l = this.lowerBound, u = this.upperBound;
                if (typeof angle !== "number") {
                    angle = 0;
                }
                if (angle !== 0) {
                    vec2.rotate(l, points[0], angle);
                } else {
                    vec2.copy(l, points[0]);
                }
                vec2.copy(u, l);
                var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
                for (var i = 1; i < points.length; i++) {
                    var p = points[i];
                    if (angle !== 0) {
                        var x = p[0], y = p[1];
                        tmp[0] = cosAngle * x - sinAngle * y;
                        tmp[1] = sinAngle * x + cosAngle * y;
                        p = tmp;
                    }
                    for (var j = 0; j < 2; j++) {
                        if (p[j] > u[j]) {
                            u[j] = p[j];
                        }
                        if (p[j] < l[j]) {
                            l[j] = p[j];
                        }
                    }
                }
                if (position) {
                    vec2.add(this.lowerBound, this.lowerBound, position);
                    vec2.add(this.upperBound, this.upperBound, position);
                }
                if (skinSize) {
                    this.lowerBound[0] -= skinSize;
                    this.lowerBound[1] -= skinSize;
                    this.upperBound[0] += skinSize;
                    this.upperBound[1] += skinSize;
                }
            };
            AABB.prototype.copy = function(aabb) {
                vec2.copy(this.lowerBound, aabb.lowerBound);
                vec2.copy(this.upperBound, aabb.upperBound);
            };
            AABB.prototype.extend = function(aabb) {
                var i = 2;
                while (i--) {
                    var l = aabb.lowerBound[i];
                    if (this.lowerBound[i] > l) {
                        this.lowerBound[i] = l;
                    }
                    var u = aabb.upperBound[i];
                    if (this.upperBound[i] < u) {
                        this.upperBound[i] = u;
                    }
                }
            };
            AABB.prototype.overlaps = function(aabb) {
                var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                return (l2[0] <= u1[0] && u1[0] <= u2[0] || l1[0] <= u2[0] && u2[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u2[1] || l1[1] <= u2[1] && u2[1] <= u1[1]);
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        10: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\Broadphase.js", __dirname = "/collision";
            var vec2 = require("../math/vec2");
            var Body = require("../objects/Body");
            module.exports = Broadphase;
            function Broadphase(type) {
                this.type = type;
                this.result = [];
                this.world = null;
                this.boundingVolumeType = Broadphase.AABB;
            }
            Broadphase.AABB = 1;
            Broadphase.BOUNDING_CIRCLE = 2;
            Broadphase.prototype.setWorld = function(world) {
                this.world = world;
            };
            Broadphase.prototype.getCollisionPairs = function(world) {
                throw new Error("getCollisionPairs must be implemented in a subclass!");
            };
            var dist = vec2.create();
            Broadphase.boundingRadiusCheck = function(bodyA, bodyB) {
                vec2.sub(dist, bodyA.position, bodyB.position);
                var d2 = vec2.squaredLength(dist), r = bodyA.boundingRadius + bodyB.boundingRadius;
                return d2 <= r * r;
            };
            Broadphase.aabbCheck = function(bodyA, bodyB) {
                return bodyA.getAABB().overlaps(bodyB.getAABB());
            };
            Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB) {
                var result;
                switch (this.boundingVolumeType) {
                  case Broadphase.BOUNDING_CIRCLE:
                    result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                    break;

                  case Broadphase.AABB:
                    result = Broadphase.aabbCheck(bodyA, bodyB);
                    break;

                  default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                }
                return result;
            };
            Broadphase.canCollide = function(bodyA, bodyB) {
                if (bodyA.type === Body.STATIC && bodyB.type === Body.STATIC) {
                    return false;
                }
                if (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC || bodyA.type === Body.STATIC && bodyB.type === Body.KINEMATIC) {
                    return false;
                }
                if (bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC || bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC) {
                    return false;
                }
                return true;
            };
            Broadphase.NAIVE = 1;
            Broadphase.SAP = 2;
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        11: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\GridBroadphase.js", __dirname = "/collision";
            var Circle = require("../shapes/Circle"), Plane = require("../shapes/Plane"), Particle = require("../shapes/Particle"), Broadphase = require("../collision/Broadphase"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = GridBroadphase;
            function GridBroadphase(options) {
                Broadphase.apply(this);
                options = Utils.defaults(options, {
                    xmin: -100,
                    xmax: 100,
                    ymin: -100,
                    ymax: 100,
                    nx: 10,
                    ny: 10
                });
                this.xmin = options.xmin;
                this.ymin = options.ymin;
                this.xmax = options.xmax;
                this.ymax = options.ymax;
                this.nx = options.nx;
                this.ny = options.ny;
                this.binsizeX = (this.xmax - this.xmin) / this.nx;
                this.binsizeY = (this.ymax - this.ymin) / this.ny;
            }
            GridBroadphase.prototype = new Broadphase();
            GridBroadphase.prototype.getCollisionPairs = function(world) {
                var result = [], bodies = world.bodies, Ncolliding = bodies.length, binsizeX = this.binsizeX, binsizeY = this.binsizeY, nx = this.nx, ny = this.ny, xmin = this.xmin, ymin = this.ymin, xmax = this.xmax, ymax = this.ymax;
                var bins = [], Nbins = nx * ny;
                for (var i = 0; i < Nbins; i++) {
                    bins.push([]);
                }
                var xmult = nx / (xmax - xmin);
                var ymult = ny / (ymax - ymin);
                for (var i = 0; i !== Ncolliding; i++) {
                    var bi = bodies[i];
                    var aabb = bi.aabb;
                    var lowerX = Math.max(aabb.lowerBound[0], xmin);
                    var lowerY = Math.max(aabb.lowerBound[1], ymin);
                    var upperX = Math.min(aabb.upperBound[0], xmax);
                    var upperY = Math.min(aabb.upperBound[1], ymax);
                    var xi1 = Math.floor(xmult * (lowerX - xmin));
                    var yi1 = Math.floor(ymult * (lowerY - ymin));
                    var xi2 = Math.floor(xmult * (upperX - xmin));
                    var yi2 = Math.floor(ymult * (upperY - ymin));
                    for (var j = xi1; j <= xi2; j++) {
                        for (var k = yi1; k <= yi2; k++) {
                            var xi = j;
                            var yi = k;
                            var idx = xi * (ny - 1) + yi;
                            if (idx >= 0 && idx < Nbins) {
                                bins[idx].push(bi);
                            }
                        }
                    }
                }
                for (var i = 0; i !== Nbins; i++) {
                    var bin = bins[i];
                    for (var j = 0, NbodiesInBin = bin.length; j !== NbodiesInBin; j++) {
                        var bi = bin[j];
                        for (var k = 0; k !== j; k++) {
                            var bj = bin[k];
                            if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                                result.push(bi, bj);
                            }
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../math/vec2": 31,
            "../shapes/Circle": 38,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        12: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\NaiveBroadphase.js", __dirname = "/collision";
            var Circle = require("../shapes/Circle"), Plane = require("../shapes/Plane"), Shape = require("../shapes/Shape"), Particle = require("../shapes/Particle"), Broadphase = require("../collision/Broadphase"), vec2 = require("../math/vec2");
            module.exports = NaiveBroadphase;
            function NaiveBroadphase() {
                Broadphase.call(this, Broadphase.NAIVE);
            }
            NaiveBroadphase.prototype = new Broadphase();
            NaiveBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = world.bodies, result = this.result;
                result.length = 0;
                for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
                    var bi = bodies[i];
                    for (var j = 0; j < i; j++) {
                        var bj = bodies[j];
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../math/vec2": 31,
            "../shapes/Circle": 38,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../shapes/Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        13: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\Narrowphase.js", __dirname = "/collision";
            var vec2 = require("../math/vec2"), sub = vec2.sub, add = vec2.add, dot = vec2.dot, Utils = require("../utils/Utils"), TupleDictionary = require("../utils/TupleDictionary"), Equation = require("../equations/Equation"), ContactEquation = require("../equations/ContactEquation"), FrictionEquation = require("../equations/FrictionEquation"), Circle = require("../shapes/Circle"), Convex = require("../shapes/Convex"), Shape = require("../shapes/Shape"), Body = require("../objects/Body"), Rectangle = require("../shapes/Rectangle");
            module.exports = Narrowphase;
            var yAxis = vec2.fromValues(0, 1);
            var tmp1 = vec2.fromValues(0, 0), tmp2 = vec2.fromValues(0, 0), tmp3 = vec2.fromValues(0, 0), tmp4 = vec2.fromValues(0, 0), tmp5 = vec2.fromValues(0, 0), tmp6 = vec2.fromValues(0, 0), tmp7 = vec2.fromValues(0, 0), tmp8 = vec2.fromValues(0, 0), tmp9 = vec2.fromValues(0, 0), tmp10 = vec2.fromValues(0, 0), tmp11 = vec2.fromValues(0, 0), tmp12 = vec2.fromValues(0, 0), tmp13 = vec2.fromValues(0, 0), tmp14 = vec2.fromValues(0, 0), tmp15 = vec2.fromValues(0, 0), tmp16 = vec2.fromValues(0, 0), tmp17 = vec2.fromValues(0, 0), tmp18 = vec2.fromValues(0, 0), tmpArray = [];
            function Narrowphase() {
                this.contactEquations = [];
                this.frictionEquations = [];
                this.enableFriction = true;
                this.slipForce = 10;
                this.frictionCoefficient = .3;
                this.surfaceVelocity = 0;
                this.reuseObjects = true;
                this.reusableContactEquations = [];
                this.reusableFrictionEquations = [];
                this.restitution = 0;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = Equation.DEFAULT_RELAXATION;
                this.enableFrictionReduction = true;
                this.collidingBodiesLastStep = new TupleDictionary();
                this.contactSkinSize = .01;
            }
            Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB) {
                var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
                return !!this.collidingBodiesLastStep.get(id1, id2);
            };
            Narrowphase.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                var eqs = this.contactEquations;
                var l = eqs.length;
                while (l--) {
                    var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
                    this.collidingBodiesLastStep.set(id1, id2, true);
                }
                if (this.reuseObjects) {
                    var ce = this.contactEquations, fe = this.frictionEquations, rfe = this.reusableFrictionEquations, rce = this.reusableContactEquations;
                    Utils.appendArray(rce, ce);
                    Utils.appendArray(rfe, fe);
                }
                this.contactEquations.length = this.frictionEquations.length = 0;
            };
            Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA, bodyB);
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.restitution = this.restitution;
                c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
                c.stiffness = this.stiffness;
                c.relaxation = this.relaxation;
                c.needsUpdate = true;
                c.enabled = true;
                c.offset = this.contactSkinSize;
                return c;
            };
            Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA, bodyB);
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.setSlipForce(this.slipForce);
                c.frictionCoefficient = this.frictionCoefficient;
                c.relativeVelocity = this.surfaceVelocity;
                c.enabled = true;
                c.needsUpdate = true;
                c.stiffness = this.frictionStiffness;
                c.relaxation = this.frictionRelaxation;
                c.contactEquations.length = 0;
                return c;
            };
            Narrowphase.prototype.createFrictionFromContact = function(c) {
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                vec2.copy(eq.contactPointA, c.contactPointA);
                vec2.copy(eq.contactPointB, c.contactPointB);
                vec2.rotate90cw(eq.t, c.normalA);
                eq.contactEquations.push(c);
                return eq;
            };
            Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
                if (!numContacts) {
                    throw new Error("numContacts == 0!");
                }
                var c = this.contactEquations[this.contactEquations.length - 1];
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                var bodyA = c.bodyA;
                var bodyB = c.bodyB;
                vec2.set(eq.contactPointA, 0, 0);
                vec2.set(eq.contactPointB, 0, 0);
                vec2.set(eq.t, 0, 0);
                for (var i = 0; i !== numContacts; i++) {
                    c = this.contactEquations[this.contactEquations.length - 1 - i];
                    if (c.bodyA === bodyA) {
                        vec2.add(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
                    } else {
                        vec2.sub(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
                    }
                    eq.contactEquations.push(c);
                }
                var invNumContacts = 1 / numContacts;
                vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
                vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
                vec2.normalize(eq.t, eq.t);
                vec2.rotate90cw(eq.t, eq.t);
                return eq;
            };
            Narrowphase.prototype[Shape.LINE | Shape.CONVEX] = Narrowphase.prototype.convexLine = function(convexBody, convexShape, convexOffset, convexAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] = Narrowphase.prototype.lineRectangle = function(lineBody, lineShape, lineOffset, lineAngle, rectangleBody, rectangleShape, rectangleOffset, rectangleAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
                vec2.set(convexShape.vertices[0], -capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[1], capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[2], capsuleShape.length * .5, capsuleShape.radius);
                vec2.set(convexShape.vertices[3], -capsuleShape.length * .5, capsuleShape.radius);
            }
            var convexCapsule_tempRect = new Rectangle(1, 1), convexCapsule_tempVec = vec2.create();
            Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] = Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] = Narrowphase.prototype.convexCapsule = function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                var circlePos = convexCapsule_tempVec;
                vec2.set(circlePos, capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                vec2.set(circlePos, -capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                if (justTest && (result1 || result2)) {
                    return true;
                }
                var r = convexCapsule_tempRect;
                setConvexToCapsuleShapeMiddle(r, capsuleShape);
                var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
                return result + result1 + result2;
            };
            Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] = Narrowphase.prototype.lineCapsule = function(lineBody, lineShape, linePosition, lineAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            var capsuleCapsule_tempVec1 = vec2.create();
            var capsuleCapsule_tempVec2 = vec2.create();
            var capsuleCapsule_tempRect1 = new Rectangle(1, 1);
            Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] = Narrowphase.prototype.capsuleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var enableFrictionBefore;
                var circlePosi = capsuleCapsule_tempVec1, circlePosj = capsuleCapsule_tempVec2;
                var numContacts = 0;
                for (var i = 0; i < 2; i++) {
                    vec2.set(circlePosi, (i === 0 ? -1 : 1) * si.length / 2, 0);
                    vec2.rotate(circlePosi, circlePosi, ai);
                    vec2.add(circlePosi, circlePosi, xi);
                    for (var j = 0; j < 2; j++) {
                        vec2.set(circlePosj, (j === 0 ? -1 : 1) * sj.length / 2, 0);
                        vec2.rotate(circlePosj, circlePosj, aj);
                        vec2.add(circlePosj, circlePosj, xj);
                        if (this.enableFrictionReduction) {
                            enableFrictionBefore = this.enableFriction;
                            this.enableFriction = false;
                        }
                        var result = this.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);
                        if (this.enableFrictionReduction) {
                            this.enableFriction = enableFrictionBefore;
                        }
                        if (justTest && result) {
                            return true;
                        }
                        numContacts += result;
                    }
                }
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var rect = capsuleCapsule_tempRect1;
                setConvexToCapsuleShapeMiddle(rect, si);
                var result1 = this.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result1) {
                    return true;
                }
                numContacts += result1;
                if (this.enableFrictionReduction) {
                    var enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                setConvexToCapsuleShapeMiddle(rect, sj);
                var result2 = this.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result2) {
                    return true;
                }
                numContacts += result2;
                if (this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.LINE | Shape.LINE] = Narrowphase.prototype.lineLine = function(bodyA, shapeA, positionA, angleA, bodyB, shapeB, positionB, angleB, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.PLANE | Shape.LINE] = Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, planeOffset);
                    var d = dot(dist, worldNormal);
                    if (d < 0) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                        numContacts++;
                        vec2.copy(c.normalA, worldNormal);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(dist, worldNormal, d);
                        sub(c.contactPointA, v, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (justTest) {
                    return false;
                }
                if (!this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] = Narrowphase.prototype.particleCapsule = function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                return this.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] = Narrowphase.prototype.circleLine = function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
                var lineRadius = lineRadius || 0, circleRadius = typeof circleRadius !== "undefined" ? circleRadius : circleShape.radius, orthoDist = tmp1, lineToCircleOrthoUnit = tmp2, projectedPoint = tmp3, centerDist = tmp4, worldTangent = tmp5, worldEdge = tmp6, worldEdgeUnit = tmp7, worldVertex0 = tmp8, worldVertex1 = tmp9, worldVertex01 = tmp10, worldVertex11 = tmp11, dist = tmp12, lineToCircle = tmp13, lineEndToLineRadius = tmp14, verts = tmpArray;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                sub(dist, circleOffset, worldVertex0);
                var d = dot(dist, worldTangent);
                sub(centerDist, worldVertex0, lineOffset);
                sub(lineToCircle, circleOffset, lineOffset);
                var radiusSum = circleRadius + lineRadius;
                if (Math.abs(d) < radiusSum) {
                    vec2.scale(orthoDist, worldTangent, d);
                    sub(projectedPoint, circleOffset, orthoDist);
                    vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
                    vec2.normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
                    vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
                    add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
                    var pos = dot(worldEdgeUnit, projectedPoint);
                    var pos0 = dot(worldEdgeUnit, worldVertex0);
                    var pos1 = dot(worldEdgeUnit, worldVertex1);
                    if (pos > pos0 && pos < pos1) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.scale(c.normalA, orthoDist, -1);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, projectedPoint, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, circleOffset);
                    if (vec2.squaredLength(dist) < Math.pow(radiusSum, 2)) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.copy(c.normalA, dist);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
                        add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] = Narrowphase.prototype.circleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                return this.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] = Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] = Narrowphase.prototype.circleConvex = function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
                var circleRadius = typeof circleRadius === "number" ? circleRadius : circleShape.radius;
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldNormal = tmp5, centerDist = tmp6, convexToCircle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, minCandidate = tmp16, found = false, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0;
                var verts = convexShape.vertices;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldNormal, worldEdgeUnit);
                    vec2.scale(candidate, worldNormal, -circleShape.radius);
                    add(candidate, candidate, circleOffset);
                    if (pointInConvex(candidate, convexShape, convexOffset, convexAngle)) {
                        vec2.sub(candidateDist, worldVertex0, candidate);
                        var candidateDistance = Math.abs(vec2.dot(candidateDist, worldNormal));
                        if (candidateDistance < minCandidateDistance) {
                            vec2.copy(minCandidate, candidate);
                            minCandidateDistance = candidateDistance;
                            vec2.scale(closestEdgeProjectedPoint, worldNormal, candidateDistance);
                            vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
                            found = true;
                        }
                    }
                }
                if (found) {
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    vec2.sub(c.normalA, minCandidate, circleOffset);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                if (circleRadius > 0) {
                    for (var i = 0; i < verts.length; i++) {
                        var localVertex = verts[i];
                        vec2.rotate(worldVertex, localVertex, convexAngle);
                        add(worldVertex, worldVertex, convexOffset);
                        sub(dist, worldVertex, circleOffset);
                        if (vec2.squaredLength(dist) < Math.pow(circleRadius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointA, c.normalA, circleRadius);
                            add(c.contactPointA, c.contactPointA, circleOffset);
                            sub(c.contactPointA, c.contactPointA, circleBody.position);
                            sub(c.contactPointB, worldVertex, convexOffset);
                            add(c.contactPointB, c.contactPointB, convexOffset);
                            sub(c.contactPointB, c.contactPointB, convexBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                            return 1;
                        }
                    }
                }
                return 0;
            };
            var pic_worldVertex0 = vec2.create(), pic_worldVertex1 = vec2.create(), pic_r0 = vec2.create(), pic_r1 = vec2.create();
            function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
                var worldVertex0 = pic_worldVertex0, worldVertex1 = pic_worldVertex1, r0 = pic_r0, r1 = pic_r1, point = worldPoint, verts = convexShape.vertices, lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(r0, worldVertex0, point);
                    sub(r1, worldVertex1, point);
                    var cross = vec2.crossLength(r0, r1);
                    if (lastCross === null) {
                        lastCross = cross;
                    }
                    if (cross * lastCross <= 0) {
                        return false;
                    }
                    lastCross = cross;
                }
                return true;
            }
            Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] = Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] = Narrowphase.prototype.particleConvex = function(particleBody, particleShape, particleOffset, particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, r0 = tmp14, r1 = tmp15, localPoint = tmp16, candidateDist = tmp17, minEdgeNormal = tmp18, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0, found = false, verts = convexShape.vertices;
                if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldTangent, worldEdgeUnit);
                    sub(dist, particleOffset, worldVertex0);
                    var d = dot(dist, worldTangent);
                    sub(centerDist, worldVertex0, convexOffset);
                    sub(convexToparticle, particleOffset, convexOffset);
                    vec2.sub(candidateDist, worldVertex0, particleOffset);
                    var candidateDistance = Math.abs(vec2.dot(candidateDist, worldTangent));
                    if (candidateDistance < minCandidateDistance) {
                        minCandidateDistance = candidateDistance;
                        vec2.scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                        vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                        vec2.copy(minEdgeNormal, worldTangent);
                        found = true;
                    }
                }
                if (found) {
                    var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
                    vec2.scale(c.normalA, minEdgeNormal, -1);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.set(c.contactPointA, 0, 0);
                    add(c.contactPointA, c.contactPointA, particleOffset);
                    sub(c.contactPointA, c.contactPointA, particleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE] = Narrowphase.prototype.circleCircle = function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, radiusB) {
                var dist = tmp1, radiusA = radiusA || shapeA.radius, radiusB = radiusB || shapeB.radius;
                sub(dist, offsetA, offsetB);
                var r = radiusA + radiusB;
                if (vec2.squaredLength(dist) > Math.pow(r, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                sub(c.normalA, offsetB, offsetA);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, radiusA);
                vec2.scale(c.contactPointB, c.normalA, -radiusB);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] = Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] = Narrowphase.prototype.planeConvex = function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3;
                var numReported = 0;
                vec2.rotate(worldNormal, yAxis, planeAngle);
                for (var i = 0; i !== convexShape.vertices.length; i++) {
                    var v = convexShape.vertices[i];
                    vec2.rotate(worldVertex, v, convexAngle);
                    add(worldVertex, worldVertex, convexOffset);
                    sub(dist, worldVertex, planeOffset);
                    if (dot(dist, worldNormal) <= 0) {
                        if (justTest) {
                            return true;
                        }
                        numReported++;
                        var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                        sub(dist, worldVertex, planeOffset);
                        vec2.copy(c.normalA, worldNormal);
                        var d = dot(dist, c.normalA);
                        vec2.scale(dist, c.normalA, d);
                        sub(c.contactPointB, worldVertex, convexBody.position);
                        sub(c.contactPointA, worldVertex, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numReported) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numReported));
                    }
                }
                return numReported;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] = Narrowphase.prototype.particlePlane = function(particleBody, particleShape, particleOffset, particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
                var dist = tmp1, worldNormal = tmp2;
                planeAngle = planeAngle || 0;
                sub(dist, particleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(dist, worldNormal);
                if (d > 0) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
                vec2.copy(c.normalA, worldNormal);
                vec2.scale(dist, c.normalA, d);
                sub(c.contactPointA, particleOffset, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] = Narrowphase.prototype.circleParticle = function(circleBody, circleShape, circleOffset, circleAngle, particleBody, particleShape, particleOffset, particleAngle, justTest) {
                var dist = tmp1;
                sub(dist, particleOffset, circleOffset);
                if (vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            var planeCapsule_tmpCircle = new Circle(1), planeCapsule_tmp1 = vec2.create(), planeCapsule_tmp2 = vec2.create(), planeCapsule_tmp3 = vec2.create();
            Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] = Narrowphase.prototype.planeCapsule = function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
                var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, dst = planeCapsule_tmp3;
                vec2.set(end1, -capsuleShape.length / 2, 0);
                vec2.rotate(end1, end1, capsuleAngle);
                add(end1, end1, capsuleOffset);
                vec2.set(end2, capsuleShape.length / 2, 0);
                vec2.rotate(end2, end2, capsuleAngle);
                add(end2, end2, capsuleOffset);
                circle.radius = capsuleShape.radius;
                var enableFrictionBefore;
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var numContacts1 = this.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest) {
                    return numContacts1 || numContacts2;
                } else {
                    var numTotal = numContacts1 + numContacts2;
                    if (this.enableFrictionReduction) {
                        if (numTotal) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                        }
                    }
                    return numTotal;
                }
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] = Narrowphase.prototype.circlePlane = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var circleBody = bi, circleShape = si, circleOffset = xi, planeBody = bj, shapeB = sj, planeOffset = xj, planeAngle = aj;
                planeAngle = planeAngle || 0;
                var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
                sub(planeToCircle, circleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(worldNormal, planeToCircle);
                if (d > circleShape.radius) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var contact = this.createContactEquation(planeBody, circleBody, sj, si);
                vec2.copy(contact.normalA, worldNormal);
                vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
                add(contact.contactPointB, contact.contactPointB, circleOffset);
                sub(contact.contactPointB, contact.contactPointB, circleBody.position);
                vec2.scale(temp, contact.normalA, d);
                sub(contact.contactPointA, planeToCircle, temp);
                add(contact.contactPointA, contact.contactPointA, planeOffset);
                sub(contact.contactPointA, contact.contactPointA, planeBody.position);
                this.contactEquations.push(contact);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(contact));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CONVEX] = Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] = Narrowphase.prototype[Shape.RECTANGLE] = Narrowphase.prototype.convexConvex = function(bi, si, xi, ai, bj, sj, xj, aj, justTest, precision) {
                var sepAxis = tmp1, worldPoint = tmp2, worldPoint0 = tmp3, worldPoint1 = tmp4, worldEdge = tmp5, projected = tmp6, penetrationVec = tmp7, dist = tmp8, worldNormal = tmp9, numContacts = 0, precision = typeof precision === "number" ? precision : 0;
                var found = Narrowphase.findSeparatingAxis(si, xi, ai, sj, xj, aj, sepAxis);
                if (!found) {
                    return 0;
                }
                sub(dist, xj, xi);
                if (dot(sepAxis, dist) > 0) {
                    vec2.scale(sepAxis, sepAxis, -1);
                }
                var closestEdge1 = Narrowphase.getClosestEdge(si, ai, sepAxis, true), closestEdge2 = Narrowphase.getClosestEdge(sj, aj, sepAxis);
                if (closestEdge1 === -1 || closestEdge2 === -1) {
                    return 0;
                }
                for (var k = 0; k < 2; k++) {
                    var closestEdgeA = closestEdge1, closestEdgeB = closestEdge2, shapeA = si, shapeB = sj, offsetA = xi, offsetB = xj, angleA = ai, angleB = aj, bodyA = bi, bodyB = bj;
                    if (k === 0) {
                        var tmp;
                        tmp = closestEdgeA;
                        closestEdgeA = closestEdgeB;
                        closestEdgeB = tmp;
                        tmp = shapeA;
                        shapeA = shapeB;
                        shapeB = tmp;
                        tmp = offsetA;
                        offsetA = offsetB;
                        offsetB = tmp;
                        tmp = angleA;
                        angleA = angleB;
                        angleB = tmp;
                        tmp = bodyA;
                        bodyA = bodyB;
                        bodyB = tmp;
                    }
                    for (var j = closestEdgeB; j < closestEdgeB + 2; j++) {
                        var v = shapeB.vertices[(j + shapeB.vertices.length) % shapeB.vertices.length];
                        vec2.rotate(worldPoint, v, angleB);
                        add(worldPoint, worldPoint, offsetB);
                        var insideNumEdges = 0;
                        for (var i = closestEdgeA - 1; i < closestEdgeA + 2; i++) {
                            var v0 = shapeA.vertices[(i + shapeA.vertices.length) % shapeA.vertices.length], v1 = shapeA.vertices[(i + 1 + shapeA.vertices.length) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(worldNormal, worldEdge);
                            vec2.normalize(worldNormal, worldNormal);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(worldNormal, dist);
                            if (i === closestEdgeA && d <= precision || i !== closestEdgeA && d <= 0) {
                                insideNumEdges++;
                            }
                        }
                        if (insideNumEdges >= 3) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                            numContacts++;
                            var v0 = shapeA.vertices[closestEdgeA % shapeA.vertices.length], v1 = shapeA.vertices[(closestEdgeA + 1) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(c.normalA, worldEdge);
                            vec2.normalize(c.normalA, c.normalA);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(c.normalA, dist);
                            vec2.scale(penetrationVec, c.normalA, d);
                            sub(c.contactPointA, worldPoint, offsetA);
                            sub(c.contactPointA, c.contactPointA, penetrationVec);
                            add(c.contactPointA, c.contactPointA, offsetA);
                            sub(c.contactPointA, c.contactPointA, bodyA.position);
                            sub(c.contactPointB, worldPoint, offsetB);
                            add(c.contactPointB, c.contactPointB, offsetB);
                            sub(c.contactPointB, c.contactPointB, bodyB.position);
                            this.contactEquations.push(c);
                            if (!this.enableFrictionReduction) {
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numContacts) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            var pcoa_tmp1 = vec2.fromValues(0, 0);
            Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result) {
                var max = null, min = null, v, value, localAxis = pcoa_tmp1;
                vec2.rotate(localAxis, worldAxis, -convexAngle);
                for (var i = 0; i < convexShape.vertices.length; i++) {
                    v = convexShape.vertices[i];
                    value = dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                var offset = dot(convexOffset, worldAxis);
                vec2.set(result, min + offset, max + offset);
            };
            var fsa_tmp1 = vec2.fromValues(0, 0), fsa_tmp2 = vec2.fromValues(0, 0), fsa_tmp3 = vec2.fromValues(0, 0), fsa_tmp4 = vec2.fromValues(0, 0), fsa_tmp5 = vec2.fromValues(0, 0), fsa_tmp6 = vec2.fromValues(0, 0);
            Narrowphase.findSeparatingAxis = function(c1, offset1, angle1, c2, offset2, angle2, sepAxis) {
                var maxDist = null, overlap = false, found = false, edge = fsa_tmp1, worldPoint0 = fsa_tmp2, worldPoint1 = fsa_tmp3, normal = fsa_tmp4, span1 = fsa_tmp5, span2 = fsa_tmp6;
                if (c1 instanceof Rectangle && c2 instanceof Rectangle) {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== 2; i++) {
                            if (i === 0) {
                                vec2.set(normal, 0, 1);
                            } else if (i === 1) {
                                vec2.set(normal, 1, 0);
                            }
                            if (angle !== 0) {
                                vec2.rotate(normal, normal, angle);
                            }
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                } else {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== c.vertices.length; i++) {
                            vec2.rotate(worldPoint0, c.vertices[i], angle);
                            vec2.rotate(worldPoint1, c.vertices[(i + 1) % c.vertices.length], angle);
                            sub(edge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(normal, edge);
                            vec2.normalize(normal, normal);
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                }
                return found;
            };
            var gce_tmp1 = vec2.fromValues(0, 0), gce_tmp2 = vec2.fromValues(0, 0), gce_tmp3 = vec2.fromValues(0, 0);
            Narrowphase.getClosestEdge = function(c, angle, axis, flip) {
                var localAxis = gce_tmp1, edge = gce_tmp2, normal = gce_tmp3;
                vec2.rotate(localAxis, axis, -angle);
                if (flip) {
                    vec2.scale(localAxis, localAxis, -1);
                }
                var closestEdge = -1, N = c.vertices.length, maxDot = -1;
                for (var i = 0; i !== N; i++) {
                    sub(edge, c.vertices[(i + 1) % N], c.vertices[i % N]);
                    vec2.rotate90cw(normal, edge);
                    vec2.normalize(normal, normal);
                    var d = dot(normal, localAxis);
                    if (closestEdge === -1 || d > maxDot) {
                        closestEdge = i % N;
                        maxDot = d;
                    }
                }
                return closestEdge;
            };
            var circleHeightfield_candidate = vec2.create(), circleHeightfield_dist = vec2.create(), circleHeightfield_v0 = vec2.create(), circleHeightfield_v1 = vec2.create(), circleHeightfield_minCandidate = vec2.create(), circleHeightfield_worldNormal = vec2.create(), circleHeightfield_minCandidateNormal = vec2.create();
            Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] = Narrowphase.prototype.circleHeightfield = function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, radius) {
                var data = hfShape.data, radius = radius || circleShape.radius, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
                var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (circlePos[1] - radius > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    vec2.sub(worldNormal, v1, v0);
                    vec2.rotate(worldNormal, worldNormal, Math.PI / 2);
                    vec2.normalize(worldNormal, worldNormal);
                    vec2.scale(candidate, worldNormal, -radius);
                    vec2.add(candidate, candidate, circlePos);
                    vec2.sub(dist, candidate, v0);
                    var d = vec2.dot(dist, worldNormal);
                    if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                        if (justTest) {
                            return true;
                        }
                        found = true;
                        vec2.scale(dist, worldNormal, -d);
                        vec2.add(minCandidate, candidate, dist);
                        vec2.copy(minCandidateNormal, worldNormal);
                        var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                        vec2.copy(c.normalA, minCandidateNormal);
                        vec2.scale(c.contactPointB, c.normalA, -radius);
                        add(c.contactPointB, c.contactPointB, circlePos);
                        sub(c.contactPointB, c.contactPointB, circleBody.position);
                        vec2.copy(c.contactPointA, minCandidate);
                        vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                    }
                }
                found = false;
                if (radius > 0) {
                    for (var i = idxA; i <= idxB; i++) {
                        vec2.set(v0, i * w, data[i]);
                        vec2.add(v0, v0, hfPos);
                        vec2.sub(dist, circlePos, v0);
                        if (vec2.squaredLength(dist) < Math.pow(radius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointB, c.normalA, -radius);
                            add(c.contactPointB, c.contactPointB, circlePos);
                            sub(c.contactPointB, c.contactPointB, circleBody.position);
                            sub(c.contactPointA, v0, hfPos);
                            add(c.contactPointA, c.contactPointA, hfPos);
                            sub(c.contactPointA, c.contactPointA, hfBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (found) {
                    return 1;
                }
                return 0;
            };
            var convexHeightfield_v0 = vec2.create(), convexHeightfield_v1 = vec2.create(), convexHeightfield_tilePos = vec2.create(), convexHeightfield_tempConvexShape = new Convex([ vec2.create(), vec2.create(), vec2.create(), vec2.create() ]);
            Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] = Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
                var data = hfShape.data, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
                var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (convexBody.aabb.lowerBound[1] > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                var numContacts = 0;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    var tileHeight = 100;
                    vec2.set(tilePos, (v1[0] + v0[0]) * .5, (v1[1] + v0[1] - tileHeight) * .5);
                    vec2.sub(tileConvex.vertices[0], v1, tilePos);
                    vec2.sub(tileConvex.vertices[1], v0, tilePos);
                    vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
                    vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
                    tileConvex.vertices[2][1] -= tileHeight;
                    tileConvex.vertices[3][1] -= tileHeight;
                    numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
                }
                return numContacts;
            };
        }, {
            "../equations/ContactEquation": 22,
            "../equations/Equation": 23,
            "../equations/FrictionEquation": 24,
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../shapes/Circle": 38,
            "../shapes/Convex": 39,
            "../shapes/Rectangle": 44,
            "../shapes/Shape": 45,
            "../utils/TupleDictionary": 49,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        14: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\SAPBroadphase.js", __dirname = "/collision";
            var Utils = require("../utils/Utils"), Broadphase = require("../collision/Broadphase");
            module.exports = SAPBroadphase;
            function SAPBroadphase() {
                Broadphase.call(this, Broadphase.SAP);
                this.axisList = [];
                this.axisIndex = 0;
                var that = this;
                this._addBodyHandler = function(e) {
                    that.axisList.push(e.body);
                };
                this._removeBodyHandler = function(e) {
                    var idx = that.axisList.indexOf(e.body);
                    if (idx !== -1) {
                        that.axisList.splice(idx, 1);
                    }
                };
            }
            SAPBroadphase.prototype = new Broadphase();
            SAPBroadphase.prototype.setWorld = function(world) {
                this.axisList.length = 0;
                Utils.appendArray(this.axisList, world.bodies);
                world.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                world.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                this.world = world;
            };
            SAPBroadphase.sortAxisList = function(a, axisIndex) {
                axisIndex = axisIndex | 0;
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };
            SAPBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
                result.length = 0;
                var l = bodies.length;
                while (l--) {
                    var b = bodies[l];
                    if (b.aabbNeedsUpdate) {
                        b.updateAABB();
                    }
                }
                SAPBroadphase.sortAxisList(bodies, axisIndex);
                for (var i = 0, N = bodies.length | 0; i !== N; i++) {
                    var bi = bodies[i];
                    for (var j = i + 1; j < N; j++) {
                        var bj = bodies[j];
                        var overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];
                        if (!overlaps) {
                            break;
                        }
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        15: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\Constraint.js", __dirname = "/constraints";
            module.exports = Constraint;
            var Utils = require("../utils/Utils");
            function Constraint(bodyA, bodyB, type, options) {
                this.type = type;
                options = Utils.defaults(options, {
                    collideConnected: true,
                    wakeUpBodies: true
                });
                this.equations = [];
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.collideConnected = options.collideConnected;
                if (options.wakeUpBodies) {
                    if (bodyA) {
                        bodyA.wakeUp();
                    }
                    if (bodyB) {
                        bodyB.wakeUp();
                    }
                }
            }
            Constraint.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            };
            Constraint.DISTANCE = 1;
            Constraint.GEAR = 2;
            Constraint.LOCK = 3;
            Constraint.PRISMATIC = 4;
            Constraint.REVOLUTE = 5;
            Constraint.prototype.setStiffness = function(stiffness) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.stiffness = stiffness;
                    eq.needsUpdate = true;
                }
            };
            Constraint.prototype.setRelaxation = function(relaxation) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.relaxation = relaxation;
                    eq.needsUpdate = true;
                }
            };
        }, {
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        16: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\DistanceConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = DistanceConstraint;
            function DistanceConstraint(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    localAnchorA: [ 0, 0 ],
                    localAnchorB: [ 0, 0 ]
                });
                Constraint.call(this, bodyA, bodyB, Constraint.DISTANCE, options);
                this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);
                this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);
                var localAnchorA = this.localAnchorA;
                var localAnchorB = this.localAnchorB;
                this.distance = 0;
                if (typeof options.distance === "number") {
                    this.distance = options.distance;
                } else {
                    var worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), r = vec2.create();
                    vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
                    vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);
                    vec2.add(r, bodyB.position, worldAnchorB);
                    vec2.sub(r, r, worldAnchorA);
                    vec2.sub(r, r, bodyA.position);
                    this.distance = vec2.length(r);
                }
                var maxForce;
                if (typeof options.maxForce === "undefined") {
                    maxForce = Number.MAX_VALUE;
                } else {
                    maxForce = options.maxForce;
                }
                var normal = new Equation(bodyA, bodyB, -maxForce, maxForce);
                this.equations = [ normal ];
                this.maxForce = maxForce;
                var r = vec2.create();
                var ri = vec2.create();
                var rj = vec2.create();
                var that = this;
                normal.computeGq = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(r, xj, rj);
                    vec2.sub(r, r, ri);
                    vec2.sub(r, r, xi);
                    return vec2.length(r) - that.distance;
                };
                this.setMaxForce(maxForce);
                this.upperLimitEnabled = false;
                this.upperLimit = 1;
                this.lowerLimitEnabled = false;
                this.lowerLimit = 0;
                this.position = 0;
            }
            DistanceConstraint.prototype = new Constraint();
            var n = vec2.create();
            var ri = vec2.create();
            var rj = vec2.create();
            DistanceConstraint.prototype.update = function() {
                var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, distance = this.distance, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
                vec2.rotate(ri, this.localAnchorA, bodyA.angle);
                vec2.rotate(rj, this.localAnchorB, bodyB.angle);
                vec2.add(n, xj, rj);
                vec2.sub(n, n, ri);
                vec2.sub(n, n, xi);
                this.position = vec2.length(n);
                var violating = false;
                if (this.upperLimitEnabled) {
                    if (this.position > this.upperLimit) {
                        normalEquation.maxForce = 0;
                        normalEquation.minForce = -this.maxForce;
                        this.distance = this.upperLimit;
                        violating = true;
                    }
                }
                if (this.lowerLimitEnabled) {
                    if (this.position < this.lowerLimit) {
                        normalEquation.maxForce = this.maxForce;
                        normalEquation.minForce = 0;
                        this.distance = this.lowerLimit;
                        violating = true;
                    }
                }
                if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
                    normalEquation.enabled = false;
                    return;
                }
                normalEquation.enabled = true;
                vec2.normalize(n, n);
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
            };
            DistanceConstraint.prototype.setMaxForce = function(f) {
                var normal = this.equations[0];
                normal.minForce = -f;
                normal.maxForce = f;
            };
            DistanceConstraint.prototype.getMaxForce = function(f) {
                var normal = this.equations[0];
                return normal.maxForce;
            };
        }, {
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        17: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\GearConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), AngleLockEquation = require("../equations/AngleLockEquation"), vec2 = require("../math/vec2");
            module.exports = GearConstraint;
            function GearConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);
                this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                this.angle = typeof options.angle === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;
                options.angle = this.angle;
                options.ratio = this.ratio;
                this.equations = [ new AngleLockEquation(bodyA, bodyB, options) ];
                if (typeof options.maxTorque === "number") {
                    this.setMaxTorque(options.maxTorque);
                }
            }
            GearConstraint.prototype = new Constraint();
            GearConstraint.prototype.update = function() {
                var eq = this.equations[0];
                if (eq.ratio !== this.ratio) {
                    eq.setRatio(this.ratio);
                }
                eq.angle = this.angle;
            };
            GearConstraint.prototype.setMaxTorque = function(torque) {
                this.equations[0].setMaxTorque(torque);
            };
            GearConstraint.prototype.getMaxTorque = function(torque) {
                return this.equations[0].maxForce;
            };
        }, {
            "../equations/AngleLockEquation": 21,
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        18: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\LockConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), vec2 = require("../math/vec2"), Equation = require("../equations/Equation");
            module.exports = LockConstraint;
            function LockConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.LOCK, options);
                var maxForce = typeof options.maxForce === "undefined" ? Number.MAX_VALUE : options.maxForce;
                var localAngleB = options.localAngleB || 0;
                var x = new Equation(bodyA, bodyB, -maxForce, maxForce), y = new Equation(bodyA, bodyB, -maxForce, maxForce), rot = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var l = vec2.create(), g = vec2.create(), that = this;
                x.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[0];
                };
                y.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[1];
                };
                var r = vec2.create(), t = vec2.create();
                rot.computeGq = function() {
                    vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
                    vec2.scale(r, r, -1);
                    vec2.sub(g, bodyA.position, bodyB.position);
                    vec2.add(g, g, r);
                    vec2.rotate(t, r, -Math.PI / 2);
                    vec2.normalize(t, t);
                    return vec2.dot(g, t);
                };
                this.localOffsetB = vec2.create();
                if (options.localOffsetB) {
                    vec2.copy(this.localOffsetB, options.localOffsetB);
                } else {
                    vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
                    vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
                }
                this.localAngleB = 0;
                if (typeof options.localAngleB === "number") {
                    this.localAngleB = options.localAngleB;
                } else {
                    this.localAngleB = bodyB.angle - bodyA.angle;
                }
                this.equations.push(x, y, rot);
                this.setMaxForce(maxForce);
            }
            LockConstraint.prototype = new Constraint();
            LockConstraint.prototype.setMaxForce = function(force) {
                var eqs = this.equations;
                for (var i = 0; i < this.equations.length; i++) {
                    eqs[i].maxForce = force;
                    eqs[i].minForce = -force;
                }
            };
            LockConstraint.prototype.getMaxForce = function() {
                return this.equations[0].maxForce;
            };
            var l = vec2.create();
            var r = vec2.create();
            var t = vec2.create();
            var xAxis = vec2.fromValues(1, 0);
            var yAxis = vec2.fromValues(0, 1);
            LockConstraint.prototype.update = function() {
                var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
                vec2.rotate(l, this.localOffsetB, bodyA.angle);
                vec2.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
                vec2.scale(r, r, -1);
                vec2.rotate(t, r, Math.PI / 2);
                vec2.normalize(t, t);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(l, xAxis);
                x.G[3] = 1;
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(l, yAxis);
                y.G[4] = 1;
                rot.G[0] = -t[0];
                rot.G[1] = -t[1];
                rot.G[3] = t[0];
                rot.G[4] = t[1];
                rot.G[5] = vec2.crossLength(r, t);
            };
        }, {
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        19: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\PrismaticConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), ContactEquation = require("../equations/ContactEquation"), Equation = require("../equations/Equation"), vec2 = require("../math/vec2"), RotationalLockEquation = require("../equations/RotationalLockEquation");
            module.exports = PrismaticConstraint;
            function PrismaticConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.PRISMATIC, options);
                var localAnchorA = vec2.fromValues(0, 0), localAxisA = vec2.fromValues(1, 0), localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(localAnchorA, options.localAnchorA);
                }
                if (options.localAxisA) {
                    vec2.copy(localAxisA, options.localAxisA);
                }
                if (options.localAnchorB) {
                    vec2.copy(localAnchorB, options.localAnchorB);
                }
                this.localAnchorA = localAnchorA;
                this.localAnchorB = localAnchorB;
                this.localAxisA = localAxisA;
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                var trans = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var ri = new vec2.create(), rj = new vec2.create(), gg = new vec2.create(), t = new vec2.create();
                trans.computeGq = function() {
                    return vec2.dot(gg, t);
                };
                trans.updateJacobian = function() {
                    var G = this.G, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(gg, xj, rj);
                    vec2.sub(gg, gg, xi);
                    vec2.sub(gg, gg, ri);
                    vec2.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
                    G[0] = -t[0];
                    G[1] = -t[1];
                    G[2] = -vec2.crossLength(ri, t) + vec2.crossLength(t, gg);
                    G[3] = t[0];
                    G[4] = t[1];
                    G[5] = vec2.crossLength(rj, t);
                };
                this.equations.push(trans);
                if (!options.disableRotationalLock) {
                    var rot = new RotationalLockEquation(bodyA, bodyB, -maxForce, maxForce);
                    this.equations.push(rot);
                }
                this.position = 0;
                this.velocity = 0;
                this.lowerLimitEnabled = typeof options.lowerLimit !== "undefined" ? true : false;
                this.upperLimitEnabled = typeof options.upperLimit !== "undefined" ? true : false;
                this.lowerLimit = typeof options.lowerLimit !== "undefined" ? options.lowerLimit : 0;
                this.upperLimit = typeof options.upperLimit !== "undefined" ? options.upperLimit : 1;
                this.upperLimitEquation = new ContactEquation(bodyA, bodyB);
                this.lowerLimitEquation = new ContactEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;
                this.motorEquation = new Equation(bodyA, bodyB);
                this.motorEnabled = false;
                this.motorSpeed = 0;
                var that = this;
                var motorEquation = this.motorEquation;
                var old = motorEquation.computeGW;
                motorEquation.computeGq = function() {
                    return 0;
                };
                motorEquation.computeGW = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                    return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
                };
            }
            PrismaticConstraint.prototype = new Constraint();
            var worldAxisA = vec2.create(), worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), orientedAnchorA = vec2.create(), orientedAnchorB = vec2.create(), tmp = vec2.create();
            PrismaticConstraint.prototype.update = function() {
                var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
                trans.updateJacobian();
                vec2.rotate(worldAxisA, localAxisA, bodyA.angle);
                vec2.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
                vec2.add(worldAnchorA, orientedAnchorA, bodyA.position);
                vec2.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
                vec2.add(worldAnchorB, orientedAnchorB, bodyB.position);
                var relPosition = this.position = vec2.dot(worldAnchorB, worldAxisA) - vec2.dot(worldAnchorA, worldAxisA);
                if (this.motorEnabled) {
                    var G = this.motorEquation.G;
                    G[0] = worldAxisA[0];
                    G[1] = worldAxisA[1];
                    G[2] = vec2.crossLength(worldAxisA, orientedAnchorB);
                    G[3] = -worldAxisA[0];
                    G[4] = -worldAxisA[1];
                    G[5] = -vec2.crossLength(worldAxisA, orientedAnchorA);
                }
                if (this.upperLimitEnabled && relPosition > upperLimit) {
                    vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
                    vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, upperLimit);
                    vec2.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relPosition < lowerLimit) {
                    vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
                    vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, lowerLimit);
                    vec2.sub(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
            };
            PrismaticConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            PrismaticConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            PrismaticConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
        }, {
            "../equations/ContactEquation": 22,
            "../equations/Equation": 23,
            "../equations/RotationalLockEquation": 25,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        20: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\RevoluteConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), RotationalVelocityEquation = require("../equations/RotationalVelocityEquation"), RotationalLockEquation = require("../equations/RotationalLockEquation"), vec2 = require("../math/vec2");
            module.exports = RevoluteConstraint;
            var worldPivotA = vec2.create(), worldPivotB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1), g = vec2.create();
            function RevoluteConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.REVOLUTE, options);
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                this.pivotA = vec2.create();
                this.pivotB = vec2.create();
                if (options.worldPivot) {
                    vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
                    vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
                    vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
                    vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
                } else {
                    vec2.copy(this.pivotA, options.localPivotA);
                    vec2.copy(this.pivotB, options.localPivotB);
                }
                var eqs = this.equations = [ new Equation(bodyA, bodyB, -maxForce, maxForce), new Equation(bodyA, bodyB, -maxForce, maxForce) ];
                var x = eqs[0];
                var y = eqs[1];
                var that = this;
                x.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, xAxis);
                };
                y.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, yAxis);
                };
                y.minForce = x.minForce = -maxForce;
                y.maxForce = x.maxForce = maxForce;
                this.motorEquation = new RotationalVelocityEquation(bodyA, bodyB);
                this.motorEnabled = false;
                this.angle = 0;
                this.lowerLimitEnabled = false;
                this.upperLimitEnabled = false;
                this.lowerLimit = 0;
                this.upperLimit = 0;
                this.upperLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.lowerLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = 0;
                this.lowerLimitEquation.maxForce = 0;
            }
            RevoluteConstraint.prototype = new Constraint();
            RevoluteConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
            RevoluteConstraint.prototype.update = function() {
                var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, normal = eqs[0], tangent = eqs[1], x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
                var relAngle = this.angle = bodyB.angle - bodyA.angle;
                if (this.upperLimitEnabled && relAngle > upperLimit) {
                    upperLimitEquation.angle = upperLimit;
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relAngle < lowerLimit) {
                    lowerLimitEquation.angle = lowerLimit;
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                vec2.rotate(worldPivotA, pivotA, bodyA.angle);
                vec2.rotate(worldPivotB, pivotB, bodyB.angle);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(worldPivotA, xAxis);
                x.G[3] = 1;
                x.G[4] = 0;
                x.G[5] = vec2.crossLength(worldPivotB, xAxis);
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(worldPivotA, yAxis);
                y.G[3] = 0;
                y.G[4] = 1;
                y.G[5] = vec2.crossLength(worldPivotB, yAxis);
            };
            RevoluteConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            RevoluteConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            RevoluteConstraint.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled;
            };
            RevoluteConstraint.prototype.setMotorSpeed = function(speed) {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations[i].relativeVelocity = speed;
            };
            RevoluteConstraint.prototype.getMotorSpeed = function() {
                if (!this.motorEnabled) {
                    return false;
                }
                return this.motorEquation.relativeVelocity;
            };
        }, {
            "../equations/Equation": 23,
            "../equations/RotationalLockEquation": 25,
            "../equations/RotationalVelocityEquation": 26,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        21: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\AngleLockEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = AngleLockEquation;
            function AngleLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                this.setRatio(this.ratio);
            }
            AngleLockEquation.prototype = new Equation();
            AngleLockEquation.prototype.constructor = AngleLockEquation;
            AngleLockEquation.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
            };
            AngleLockEquation.prototype.setRatio = function(ratio) {
                var G = this.G;
                G[2] = ratio;
                G[5] = -1;
                this.ratio = ratio;
            };
            AngleLockEquation.prototype.setMaxTorque = function(torque) {
                this.maxForce = torque;
                this.minForce = -torque;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        22: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\ContactEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = ContactEquation;
            function ContactEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);
                this.contactPointA = vec2.create();
                this.penetrationVec = vec2.create();
                this.contactPointB = vec2.create();
                this.normalA = vec2.create();
                this.restitution = 0;
                this.firstImpact = false;
                this.shapeA = null;
                this.shapeB = null;
            }
            ContactEquation.prototype = new Equation();
            ContactEquation.prototype.constructor = ContactEquation;
            ContactEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = bi.position, xj = bj.position;
                var penetrationVec = this.penetrationVec, n = this.normalA, G = this.G;
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
                vec2.add(penetrationVec, xj, rj);
                vec2.sub(penetrationVec, penetrationVec, xi);
                vec2.sub(penetrationVec, penetrationVec, ri);
                var GW, Gq;
                if (this.firstImpact && this.restitution !== 0) {
                    Gq = 0;
                    GW = 1 / b * (1 + this.restitution) * this.computeGW();
                } else {
                    Gq = vec2.dot(n, penetrationVec) + this.offset;
                    GW = this.computeGW();
                }
                var GiMf = this.computeGiMf();
                var B = -Gq * a - GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        23: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\Equation.js", __dirname = "/equations";
            module.exports = Equation;
            var vec2 = require("../math/vec2"), Utils = require("../utils/Utils"), Body = require("../objects/Body");
            function Equation(bodyA, bodyB, minForce, maxForce) {
                this.minForce = typeof minForce === "undefined" ? -Number.MAX_VALUE : minForce;
                this.maxForce = typeof maxForce === "undefined" ? Number.MAX_VALUE : maxForce;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.G = new Utils.ARRAY_TYPE(6);
                for (var i = 0; i < 6; i++) {
                    this.G[i] = 0;
                }
                this.offset = 0;
                this.a = 0;
                this.b = 0;
                this.epsilon = 0;
                this.timeStep = 1 / 60;
                this.needsUpdate = true;
                this.multiplier = 0;
                this.relativeVelocity = 0;
                this.enabled = true;
            }
            Equation.prototype.constructor = Equation;
            Equation.DEFAULT_STIFFNESS = 1e6;
            Equation.DEFAULT_RELAXATION = 4;
            Equation.prototype.update = function() {
                var k = this.stiffness, d = this.relaxation, h = this.timeStep;
                this.a = 4 / (h * (1 + 4 * d));
                this.b = 4 * d / (1 + 4 * d);
                this.epsilon = 4 / (h * h * k * (1 + 4 * d));
                this.needsUpdate = false;
            };
            Equation.prototype.gmult = function(G, vi, wi, vj, wj) {
                return G[0] * vi[0] + G[1] * vi[1] + G[2] * wi + G[3] * vj[0] + G[4] * vj[1] + G[5] * wj;
            };
            Equation.prototype.computeB = function(a, b, h) {
                var GW = this.computeGW();
                var Gq = this.computeGq();
                var GiMf = this.computeGiMf();
                return -Gq * a - GW * b - GiMf * h;
            };
            var qi = vec2.create(), qj = vec2.create();
            Equation.prototype.computeGq = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, xi = bi.position, xj = bj.position, ai = bi.angle, aj = bj.angle;
                return this.gmult(G, qi, ai, qj, aj) + this.offset;
            };
            Equation.prototype.computeGW = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
            };
            Equation.prototype.computeGWlambda = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
                return this.gmult(G, vi, wi, vj, wj);
            };
            var iMfi = vec2.create(), iMfj = vec2.create();
            Equation.prototype.computeGiMf = function() {
                var bi = this.bodyA, bj = this.bodyB, fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                vec2.scale(iMfi, fi, invMassi);
                vec2.scale(iMfj, fj, invMassj);
                return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
            };
            Equation.prototype.computeGiMGt = function() {
                var bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                return G[0] * G[0] * invMassi + G[1] * G[1] * invMassi + G[2] * G[2] * invIi + G[3] * G[3] * invMassj + G[4] * G[4] * invMassj + G[5] * G[5] * invIj;
            };
            var addToWlambda_temp = vec2.create(), addToWlambda_Gi = vec2.create(), addToWlambda_Gj = vec2.create(), addToWlambda_ri = vec2.create(), addToWlambda_rj = vec2.create(), addToWlambda_Mdiag = vec2.create();
            Equation.prototype.addToWlambda = function(deltalambda) {
                var bi = this.bodyA, bj = this.bodyB, temp = addToWlambda_temp, Gi = addToWlambda_Gi, Gj = addToWlambda_Gj, ri = addToWlambda_ri, rj = addToWlambda_rj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, Mdiag = addToWlambda_Mdiag, G = this.G;
                Gi[0] = G[0];
                Gi[1] = G[1];
                Gj[0] = G[3];
                Gj[1] = G[4];
                vec2.scale(temp, Gi, invMassi * deltalambda);
                vec2.add(bi.vlambda, bi.vlambda, temp);
                bi.wlambda += invIi * G[2] * deltalambda;
                vec2.scale(temp, Gj, invMassj * deltalambda);
                vec2.add(bj.vlambda, bj.vlambda, temp);
                bj.wlambda += invIj * G[5] * deltalambda;
            };
            Equation.prototype.computeInvC = function(eps) {
                return 1 / (this.computeGiMGt() + eps);
            };
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        24: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\FrictionEquation.js", __dirname = "/equations";
            var vec2 = require("../math/vec2"), Equation = require("./Equation"), Utils = require("../utils/Utils");
            module.exports = FrictionEquation;
            function FrictionEquation(bodyA, bodyB, slipForce) {
                Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
                this.contactPointA = vec2.create();
                this.contactPointB = vec2.create();
                this.t = vec2.create();
                this.contactEquations = [];
                this.shapeA = null;
                this.shapeB = null;
                this.frictionCoefficient = .3;
            }
            FrictionEquation.prototype = new Equation();
            FrictionEquation.prototype.constructor = FrictionEquation;
            FrictionEquation.prototype.setSlipForce = function(slipForce) {
                this.maxForce = slipForce;
                this.minForce = -slipForce;
            };
            FrictionEquation.prototype.getSlipForce = function() {
                return this.maxForce;
            };
            FrictionEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
                G[0] = -t[0];
                G[1] = -t[1];
                G[2] = -vec2.crossLength(ri, t);
                G[3] = t[0];
                G[4] = t[1];
                G[5] = vec2.crossLength(rj, t);
                var GW = this.computeGW(), GiMf = this.computeGiMf();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        25: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\RotationalLockEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = RotationalLockEquation;
            function RotationalLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                var G = this.G;
                G[2] = 1;
                G[5] = -1;
            }
            RotationalLockEquation.prototype = new Equation();
            RotationalLockEquation.prototype.constructor = RotationalLockEquation;
            var worldVectorA = vec2.create(), worldVectorB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1);
            RotationalLockEquation.prototype.computeGq = function() {
                vec2.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
                vec2.rotate(worldVectorB, yAxis, this.bodyB.angle);
                return vec2.dot(worldVectorA, worldVectorB);
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        26: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\RotationalVelocityEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = RotationalVelocityEquation;
            function RotationalVelocityEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.relativeVelocity = 1;
                this.ratio = 1;
            }
            RotationalVelocityEquation.prototype = new Equation();
            RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
            RotationalVelocityEquation.prototype.computeB = function(a, b, h) {
                var G = this.G;
                G[2] = -1;
                G[5] = this.ratio;
                var GiMf = this.computeGiMf();
                var GW = this.computeGW();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        27: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/events\\EventEmitter.js", __dirname = "/events";
            var EventEmitter = function() {};
            module.exports = EventEmitter;
            EventEmitter.prototype = {
                constructor: EventEmitter,
                on: function(type, listener, context) {
                    listener.context = context || this;
                    if (this._listeners === undefined) {
                        this._listeners = {};
                    }
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = [];
                    }
                    if (listeners[type].indexOf(listener) === -1) {
                        listeners[type].push(listener);
                    }
                    return this;
                },
                has: function(type, listener) {
                    if (this._listeners === undefined) {
                        return false;
                    }
                    var listeners = this._listeners;
                    if (listener) {
                        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                            return true;
                        }
                    } else {
                        if (listeners[type] !== undefined) {
                            return true;
                        }
                    }
                    return false;
                },
                off: function(type, listener) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var index = listeners[type].indexOf(listener);
                    if (index !== -1) {
                        listeners[type].splice(index, 1);
                    }
                    return this;
                },
                emit: function(event) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        for (var i = 0, l = listenerArray.length; i < l; i++) {
                            var listener = listenerArray[i];
                            listener.call(listener.context, event);
                        }
                    }
                    return this;
                }
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        28: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/material\\ContactMaterial.js", __dirname = "/material";
            var Material = require("./Material");
            var Equation = require("../equations/Equation");
            module.exports = ContactMaterial;
            function ContactMaterial(materialA, materialB, options) {
                options = options || {};
                if (!(materialA instanceof Material) || !(materialB instanceof Material)) {
                    throw new Error("First two arguments must be Material instances.");
                }
                this.id = ContactMaterial.idCounter++;
                this.materialA = materialA;
                this.materialB = materialB;
                this.friction = typeof options.friction !== "undefined" ? Number(options.friction) : .3;
                this.restitution = typeof options.restitution !== "undefined" ? Number(options.restitution) : 0;
                this.stiffness = typeof options.stiffness !== "undefined" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;
                this.relaxation = typeof options.relaxation !== "undefined" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = typeof options.frictionStiffness !== "undefined" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = typeof options.frictionRelaxation !== "undefined" ? Number(options.frictionRelaxation) : Equation.DEFAULT_RELAXATION;
                this.surfaceVelocity = typeof options.surfaceVelocity !== "undefined" ? Number(options.surfaceVelocity) : 0;
                this.contactSkinSize = .005;
            }
            ContactMaterial.idCounter = 0;
        }, {
            "../equations/Equation": 23,
            "./Material": 29,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        29: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/material\\Material.js", __dirname = "/material";
            module.exports = Material;
            function Material(id) {
                this.id = id || Material.idCounter++;
            }
            Material.idCounter = 0;
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        30: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/math\\polyk.js", __dirname = "/math";
            var PolyK = {};
            PolyK.GetArea = function(p) {
                if (p.length < 6) return 0;
                var l = p.length - 2;
                var sum = 0;
                for (var i = 0; i < l; i += 2) sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
                sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
                return -sum * .5;
            };
            PolyK.Triangulate = function(p) {
                var n = p.length >> 1;
                if (n < 3) return [];
                var tgs = [];
                var avl = [];
                for (var i = 0; i < n; i++) avl.push(i);
                var i = 0;
                var al = n;
                while (al > 3) {
                    var i0 = avl[(i + 0) % al];
                    var i1 = avl[(i + 1) % al];
                    var i2 = avl[(i + 2) % al];
                    var ax = p[2 * i0], ay = p[2 * i0 + 1];
                    var bx = p[2 * i1], by = p[2 * i1 + 1];
                    var cx = p[2 * i2], cy = p[2 * i2 + 1];
                    var earFound = false;
                    if (PolyK._convex(ax, ay, bx, by, cx, cy)) {
                        earFound = true;
                        for (var j = 0; j < al; j++) {
                            var vi = avl[j];
                            if (vi == i0 || vi == i1 || vi == i2) continue;
                            if (PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                                earFound = false;
                                break;
                            }
                        }
                    }
                    if (earFound) {
                        tgs.push(i0, i1, i2);
                        avl.splice((i + 1) % al, 1);
                        al--;
                        i = 0;
                    } else if (i++ > 3 * al) break;
                }
                tgs.push(avl[0], avl[1], avl[2]);
                return tgs;
            };
            PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
                var v0x = cx - ax;
                var v0y = cy - ay;
                var v1x = bx - ax;
                var v1y = by - ay;
                var v2x = px - ax;
                var v2y = py - ay;
                var dot00 = v0x * v0x + v0y * v0y;
                var dot01 = v0x * v1x + v0y * v1y;
                var dot02 = v0x * v2x + v0y * v2y;
                var dot11 = v1x * v1x + v1y * v1y;
                var dot12 = v1x * v2x + v1y * v2y;
                var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return u >= 0 && v >= 0 && u + v < 1;
            };
            PolyK._convex = function(ax, ay, bx, by, cx, cy) {
                return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
            };
            module.exports = PolyK;
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        31: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/math\\vec2.js", __dirname = "/math";
            var vec2 = module.exports = {};
            var Utils = require("../utils/Utils");
            vec2.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0];
            };
            vec2.crossVZ = function(out, vec, zcomp) {
                vec2.rotate(out, vec, -Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.crossZV = function(out, zcomp, vec) {
                vec2.rotate(out, vec, Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.rotate = function(out, a, angle) {
                if (angle !== 0) {
                    var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
                    out[0] = c * x - s * y;
                    out[1] = s * x + c * y;
                } else {
                    out[0] = a[0];
                    out[1] = a[1];
                }
            };
            vec2.rotate90cw = function(out, a) {
                var x = a[0];
                var y = a[1];
                out[0] = y;
                out[1] = -x;
            };
            vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle) {
                vec2.copy(out, worldPoint);
                vec2.sub(out, out, framePosition);
                vec2.rotate(out, out, -frameAngle);
            };
            vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle) {
                vec2.copy(out, localPoint);
                vec2.rotate(out, out, frameAngle);
                vec2.add(out, out, framePosition);
            };
            vec2.centroid = function(out, a, b, c) {
                vec2.add(out, a, b);
                vec2.add(out, out, c);
                vec2.scale(out, out, 1 / 3);
                return out;
            };
            vec2.create = function() {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = 0;
                out[1] = 0;
                return out;
            };
            vec2.clone = function(a) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.fromValues = function(x, y) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.set = function(out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            };
            vec2.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            };
            vec2.sub = vec2.subtract;
            vec2.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                return out;
            };
            vec2.mul = vec2.multiply;
            vec2.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                return out;
            };
            vec2.div = vec2.divide;
            vec2.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            };
            vec2.distance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.dist = vec2.distance;
            vec2.squaredDistance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return x * x + y * y;
            };
            vec2.sqrDist = vec2.squaredDistance;
            vec2.length = function(a) {
                var x = a[0], y = a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.len = vec2.length;
            vec2.squaredLength = function(a) {
                var x = a[0], y = a[1];
                return x * x + y * y;
            };
            vec2.sqrLen = vec2.squaredLength;
            vec2.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            };
            vec2.normalize = function(out, a) {
                var x = a[0], y = a[1];
                var len = x * x + y * y;
                if (len > 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            };
            vec2.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1];
            };
            vec2.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")";
            };
        }, {
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        32: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\Body.js", __dirname = "/objects";
            var vec2 = require("../math/vec2"), decomp = require("poly-decomp"), Convex = require("../shapes/Convex"), AABB = require("../collision/AABB"), EventEmitter = require("../events/EventEmitter");
            module.exports = Body;
            function Body(options) {
                options = options || {};
                EventEmitter.call(this);
                this.id = ++Body._idCounter;
                this.world = null;
                this.shapes = [];
                this.shapeOffsets = [];
                this.shapeAngles = [];
                this.mass = options.mass || 0;
                this.invMass = 0;
                this.inertia = 0;
                this.invInertia = 0;
                this.invMassSolve = 0;
                this.invInertiaSolve = 0;
                this.fixedRotation = !!options.fixedRotation;
                this.position = vec2.fromValues(0, 0);
                if (options.position) {
                    vec2.copy(this.position, options.position);
                }
                this.interpolatedPosition = vec2.fromValues(0, 0);
                this.interpolatedAngle = 0;
                this.previousPosition = vec2.fromValues(0, 0);
                this.previousAngle = 0;
                this.velocity = vec2.fromValues(0, 0);
                if (options.velocity) {
                    vec2.copy(this.velocity, options.velocity);
                }
                this.vlambda = vec2.fromValues(0, 0);
                this.wlambda = 0;
                this.angle = options.angle || 0;
                this.angularVelocity = options.angularVelocity || 0;
                this.force = vec2.create();
                if (options.force) {
                    vec2.copy(this.force, options.force);
                }
                this.angularForce = options.angularForce || 0;
                this.damping = typeof options.damping === "number" ? options.damping : .1;
                this.angularDamping = typeof options.angularDamping === "number" ? options.angularDamping : .1;
                this.type = Body.STATIC;
                if (typeof options.type !== "undefined") {
                    this.type = options.type;
                } else if (!options.mass) {
                    this.type = Body.STATIC;
                } else {
                    this.type = Body.DYNAMIC;
                }
                this.boundingRadius = 0;
                this.aabb = new AABB();
                this.aabbNeedsUpdate = true;
                this.allowSleep = true;
                this.wantsToSleep = false;
                this.sleepState = Body.AWAKE;
                this.sleepSpeedLimit = .2;
                this.sleepTimeLimit = 1;
                this.gravityScale = 1;
                this.timeLastSleepy = 0;
                this.concavePath = null;
                this._wakeUpAfterNarrowphase = false;
                this.updateMassProperties();
            }
            Body.prototype = new EventEmitter();
            Body._idCounter = 0;
            Body.prototype.updateSolveMassProperties = function() {
                if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                    this.invMassSolve = 0;
                    this.invInertiaSolve = 0;
                } else {
                    this.invMassSolve = this.invMass;
                    this.invInertiaSolve = this.invInertia;
                }
            };
            Body.prototype.setDensity = function(density) {
                var totalArea = this.getArea();
                this.mass = totalArea * density;
                this.updateMassProperties();
            };
            Body.prototype.getArea = function() {
                var totalArea = 0;
                for (var i = 0; i < this.shapes.length; i++) {
                    totalArea += this.shapes[i].area;
                }
                return totalArea;
            };
            Body.prototype.getAABB = function() {
                if (this.aabbNeedsUpdate) {
                    this.updateAABB();
                }
                return this.aabb;
            };
            var shapeAABB = new AABB(), tmp = vec2.create();
            Body.prototype.updateAABB = function() {
                var shapes = this.shapes, shapeOffsets = this.shapeOffsets, shapeAngles = this.shapeAngles, N = shapes.length, offset = tmp, bodyAngle = this.angle;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], angle = shapeAngles[i] + bodyAngle;
                    vec2.rotate(offset, shapeOffsets[i], bodyAngle);
                    vec2.add(offset, offset, this.position);
                    shape.computeAABB(shapeAABB, offset, angle);
                    if (i === 0) {
                        this.aabb.copy(shapeAABB);
                    } else {
                        this.aabb.extend(shapeAABB);
                    }
                }
                this.aabbNeedsUpdate = false;
            };
            Body.prototype.updateBoundingRadius = function() {
                var shapes = this.shapes, shapeOffsets = this.shapeOffsets, N = shapes.length, radius = 0;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], offset = vec2.length(shapeOffsets[i]), r = shape.boundingRadius;
                    if (offset + r > radius) {
                        radius = offset + r;
                    }
                }
                this.boundingRadius = radius;
            };
            Body.prototype.addShape = function(shape, offset, angle) {
                angle = angle || 0;
                if (offset) {
                    offset = vec2.fromValues(offset[0], offset[1]);
                } else {
                    offset = vec2.fromValues(0, 0);
                }
                this.shapes.push(shape);
                this.shapeOffsets.push(offset);
                this.shapeAngles.push(angle);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = true;
            };
            Body.prototype.removeShape = function(shape) {
                var idx = this.shapes.indexOf(shape);
                if (idx !== -1) {
                    this.shapes.splice(idx, 1);
                    this.shapeOffsets.splice(idx, 1);
                    this.shapeAngles.splice(idx, 1);
                    this.aabbNeedsUpdate = true;
                    return true;
                } else {
                    return false;
                }
            };
            Body.prototype.updateMassProperties = function() {
                if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
                    this.mass = Number.MAX_VALUE;
                    this.invMass = 0;
                    this.inertia = Number.MAX_VALUE;
                    this.invInertia = 0;
                } else {
                    var shapes = this.shapes, N = shapes.length, m = this.mass / N, I = 0;
                    if (!this.fixedRotation) {
                        for (var i = 0; i < N; i++) {
                            var shape = shapes[i], r2 = vec2.squaredLength(this.shapeOffsets[i]), Icm = shape.computeMomentOfInertia(m);
                            I += Icm + m * r2;
                        }
                        this.inertia = I;
                        this.invInertia = I > 0 ? 1 / I : 0;
                    } else {
                        this.inertia = Number.MAX_VALUE;
                        this.invInertia = 0;
                    }
                    this.invMass = 1 / this.mass;
                }
            };
            var Body_applyForce_r = vec2.create();
            Body.prototype.applyForce = function(force, worldPoint) {
                var r = Body_applyForce_r;
                vec2.sub(r, worldPoint, this.position);
                vec2.add(this.force, this.force, force);
                var rotForce = vec2.crossLength(r, force);
                this.angularForce += rotForce;
            };
            Body.prototype.toLocalFrame = function(out, worldPoint) {
                vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
            };
            Body.prototype.toWorldFrame = function(out, localPoint) {
                vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
            };
            Body.prototype.fromPolygon = function(path, options) {
                options = options || {};
                for (var i = this.shapes.length; i >= 0; --i) {
                    this.removeShape(this.shapes[i]);
                }
                var p = new decomp.Polygon();
                p.vertices = path;
                p.makeCCW();
                if (typeof options.removeCollinearPoints === "number") {
                    p.removeCollinearPoints(options.removeCollinearPoints);
                }
                if (typeof options.skipSimpleCheck === "undefined") {
                    if (!p.isSimple()) {
                        return false;
                    }
                }
                this.concavePath = p.vertices.slice(0);
                for (var i = 0; i < this.concavePath.length; i++) {
                    var v = [ 0, 0 ];
                    vec2.copy(v, this.concavePath[i]);
                    this.concavePath[i] = v;
                }
                var convexes;
                if (options.optimalDecomp) {
                    convexes = p.decomp();
                } else {
                    convexes = p.quickDecomp();
                }
                var cm = vec2.create();
                for (var i = 0; i !== convexes.length; i++) {
                    var c = new Convex(convexes[i].vertices);
                    for (var j = 0; j !== c.vertices.length; j++) {
                        var v = c.vertices[j];
                        vec2.sub(v, v, c.centerOfMass);
                    }
                    vec2.scale(cm, c.centerOfMass, 1);
                    c.updateTriangles();
                    c.updateCenterOfMass();
                    c.updateBoundingRadius();
                    this.addShape(c, cm);
                }
                this.adjustCenterOfMass();
                this.aabbNeedsUpdate = true;
                return true;
            };
            var adjustCenterOfMass_tmp1 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp2 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp3 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp4 = vec2.fromValues(0, 0);
            Body.prototype.adjustCenterOfMass = function() {
                var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
                vec2.set(sum, 0, 0);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i], offset = this.shapeOffsets[i];
                    vec2.scale(offset_times_area, offset, s.area);
                    vec2.add(sum, sum, offset_times_area);
                    totalArea += s.area;
                }
                vec2.scale(cm, sum, 1 / totalArea);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i], offset = this.shapeOffsets[i];
                    if (!offset) {
                        offset = this.shapeOffsets[i] = vec2.create();
                    }
                    vec2.sub(offset, offset, cm);
                }
                vec2.add(this.position, this.position, cm);
                for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
                    vec2.sub(this.concavePath[i], this.concavePath[i], cm);
                }
                this.updateMassProperties();
                this.updateBoundingRadius();
            };
            Body.prototype.setZeroForce = function() {
                vec2.set(this.force, 0, 0);
                this.angularForce = 0;
            };
            Body.prototype.resetConstraintVelocity = function() {
                var b = this, vlambda = b.vlambda;
                vec2.set(vlambda, 0, 0);
                b.wlambda = 0;
            };
            Body.prototype.addConstraintVelocity = function() {
                var b = this, v = b.velocity;
                vec2.add(v, v, b.vlambda);
                b.angularVelocity += b.wlambda;
            };
            Body.prototype.applyDamping = function(dt) {
                if (this.type === Body.DYNAMIC) {
                    var v = this.velocity;
                    vec2.scale(v, v, Math.pow(1 - this.damping, dt));
                    this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
                }
            };
            Body.prototype.wakeUp = function() {
                var s = this.sleepState;
                this.sleepState = Body.AWAKE;
                this.idleTime = 0;
                if (s !== Body.AWAKE) {
                    this.emit(Body.wakeUpEvent);
                }
            };
            Body.prototype.sleep = function() {
                this.sleepState = Body.SLEEPING;
                this.angularVelocity = 0;
                this.angularForce = 0;
                vec2.set(this.velocity, 0, 0);
                vec2.set(this.force, 0, 0);
                this.emit(Body.sleepEvent);
            };
            Body.prototype.sleepTick = function(time, dontSleep, dt) {
                if (!this.allowSleep || this.type === Body.SLEEPING) {
                    return;
                }
                this.wantsToSleep = false;
                var sleepState = this.sleepState, speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                if (speedSquared >= speedLimitSquared) {
                    this.idleTime = 0;
                    this.sleepState = Body.AWAKE;
                } else {
                    this.idleTime += dt;
                    this.sleepState = Body.SLEEPY;
                }
                if (this.idleTime > this.sleepTimeLimit) {
                    if (!dontSleep) {
                        this.sleep();
                    } else {
                        this.wantsToSleep = true;
                    }
                }
            };
            Body.prototype.getVelocityFromPosition = function(store, timeStep) {
                store = store || vec2.create();
                vec2.sub(store, this.position, this.previousPosition);
                vec2.scale(store, store, 1 / timeStep);
                return store;
            };
            Body.prototype.getAngularVelocityFromPosition = function(timeStep) {
                return (this.angle - this.previousAngle) / timeStep;
            };
            Body.prototype.overlaps = function(body) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
            };
            Body.sleepyEvent = {
                type: "sleepy"
            };
            Body.sleepEvent = {
                type: "sleep"
            };
            Body.wakeUpEvent = {
                type: "wakeup"
            };
            Body.DYNAMIC = 1;
            Body.STATIC = 2;
            Body.KINEMATIC = 4;
            Body.AWAKE = 0;
            Body.SLEEPY = 1;
            Body.SLEEPING = 2;
        }, {
            "../collision/AABB": 9,
            "../events/EventEmitter": 27,
            "../math/vec2": 31,
            "../shapes/Convex": 39,
            __browserify_Buffer: 1,
            __browserify_process: 2,
            "poly-decomp": 7
        } ],
        33: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\LinearSpring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Spring = require("./Spring");
            var Utils = require("../utils/Utils");
            module.exports = LinearSpring;
            function LinearSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.localAnchorA = vec2.fromValues(0, 0);
                this.localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(this.localAnchorA, options.localAnchorA);
                }
                if (options.localAnchorB) {
                    vec2.copy(this.localAnchorB, options.localAnchorB);
                }
                if (options.worldAnchorA) {
                    this.setWorldAnchorA(options.worldAnchorA);
                }
                if (options.worldAnchorB) {
                    this.setWorldAnchorB(options.worldAnchorB);
                }
                var worldAnchorA = vec2.create();
                var worldAnchorB = vec2.create();
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);
                this.restLength = typeof options.restLength === "number" ? options.restLength : worldDistance;
            }
            LinearSpring.prototype = new Spring();
            LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA) {
                this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
            };
            LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB) {
                this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
            };
            LinearSpring.prototype.getWorldAnchorA = function(result) {
                this.bodyA.toWorldFrame(result, this.localAnchorA);
            };
            LinearSpring.prototype.getWorldAnchorB = function(result) {
                this.bodyB.toWorldFrame(result, this.localAnchorB);
            };
            var applyForce_r = vec2.create(), applyForce_r_unit = vec2.create(), applyForce_u = vec2.create(), applyForce_f = vec2.create(), applyForce_worldAnchorA = vec2.create(), applyForce_worldAnchorB = vec2.create(), applyForce_ri = vec2.create(), applyForce_rj = vec2.create(), applyForce_tmp = vec2.create();
            LinearSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
                var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                vec2.sub(ri, worldAnchorA, bodyA.position);
                vec2.sub(rj, worldAnchorB, bodyB.position);
                vec2.sub(r, worldAnchorB, worldAnchorA);
                var rlen = vec2.len(r);
                vec2.normalize(r_unit, r);
                vec2.sub(u, bodyB.velocity, bodyA.velocity);
                vec2.crossZV(tmp, bodyB.angularVelocity, rj);
                vec2.add(u, u, tmp);
                vec2.crossZV(tmp, bodyA.angularVelocity, ri);
                vec2.sub(u, u, tmp);
                vec2.scale(f, r_unit, -k * (rlen - l) - d * vec2.dot(u, r_unit));
                vec2.sub(bodyA.force, bodyA.force, f);
                vec2.add(bodyB.force, bodyB.force, f);
                var ri_x_f = vec2.crossLength(ri, f);
                var rj_x_f = vec2.crossLength(rj, f);
                bodyA.angularForce -= ri_x_f;
                bodyB.angularForce += rj_x_f;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Spring": 35,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        34: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\RotationalSpring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Spring = require("./Spring");
            module.exports = RotationalSpring;
            function RotationalSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.restAngle = typeof options.restAngle === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
            }
            RotationalSpring.prototype = new Spring();
            RotationalSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
                var torque = -k * (x - l) - d * u * 0;
                bodyA.angularForce -= torque;
                bodyB.angularForce += torque;
            };
        }, {
            "../math/vec2": 31,
            "./Spring": 35,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        35: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\Spring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Utils = require("../utils/Utils");
            module.exports = Spring;
            function Spring(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    stiffness: 100,
                    damping: 1
                });
                this.stiffness = options.stiffness;
                this.damping = options.damping;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            Spring.prototype.applyForce = function() {};
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        36: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/p2.js", __dirname = "/";
            module.exports = {
                AABB: require("./collision/AABB"),
                AngleLockEquation: require("./equations/AngleLockEquation"),
                Body: require("./objects/Body"),
                Broadphase: require("./collision/Broadphase"),
                Capsule: require("./shapes/Capsule"),
                Circle: require("./shapes/Circle"),
                Constraint: require("./constraints/Constraint"),
                ContactEquation: require("./equations/ContactEquation"),
                ContactMaterial: require("./material/ContactMaterial"),
                Convex: require("./shapes/Convex"),
                DistanceConstraint: require("./constraints/DistanceConstraint"),
                Equation: require("./equations/Equation"),
                EventEmitter: require("./events/EventEmitter"),
                FrictionEquation: require("./equations/FrictionEquation"),
                GearConstraint: require("./constraints/GearConstraint"),
                GridBroadphase: require("./collision/GridBroadphase"),
                GSSolver: require("./solver/GSSolver"),
                Heightfield: require("./shapes/Heightfield"),
                Line: require("./shapes/Line"),
                LockConstraint: require("./constraints/LockConstraint"),
                Material: require("./material/Material"),
                Narrowphase: require("./collision/Narrowphase"),
                NaiveBroadphase: require("./collision/NaiveBroadphase"),
                Particle: require("./shapes/Particle"),
                Plane: require("./shapes/Plane"),
                RevoluteConstraint: require("./constraints/RevoluteConstraint"),
                PrismaticConstraint: require("./constraints/PrismaticConstraint"),
                Rectangle: require("./shapes/Rectangle"),
                RotationalVelocityEquation: require("./equations/RotationalVelocityEquation"),
                SAPBroadphase: require("./collision/SAPBroadphase"),
                Shape: require("./shapes/Shape"),
                Solver: require("./solver/Solver"),
                Spring: require("./objects/Spring"),
                LinearSpring: require("./objects/LinearSpring"),
                RotationalSpring: require("./objects/RotationalSpring"),
                Utils: require("./utils/Utils"),
                World: require("./world/World"),
                vec2: require("./math/vec2"),
                version: require("../package.json").version
            };
        }, {
            "../package.json": 8,
            "./collision/AABB": 9,
            "./collision/Broadphase": 10,
            "./collision/GridBroadphase": 11,
            "./collision/NaiveBroadphase": 12,
            "./collision/Narrowphase": 13,
            "./collision/SAPBroadphase": 14,
            "./constraints/Constraint": 15,
            "./constraints/DistanceConstraint": 16,
            "./constraints/GearConstraint": 17,
            "./constraints/LockConstraint": 18,
            "./constraints/PrismaticConstraint": 19,
            "./constraints/RevoluteConstraint": 20,
            "./equations/AngleLockEquation": 21,
            "./equations/ContactEquation": 22,
            "./equations/Equation": 23,
            "./equations/FrictionEquation": 24,
            "./equations/RotationalVelocityEquation": 26,
            "./events/EventEmitter": 27,
            "./material/ContactMaterial": 28,
            "./material/Material": 29,
            "./math/vec2": 31,
            "./objects/Body": 32,
            "./objects/LinearSpring": 33,
            "./objects/RotationalSpring": 34,
            "./objects/Spring": 35,
            "./shapes/Capsule": 37,
            "./shapes/Circle": 38,
            "./shapes/Convex": 39,
            "./shapes/Heightfield": 40,
            "./shapes/Line": 41,
            "./shapes/Particle": 42,
            "./shapes/Plane": 43,
            "./shapes/Rectangle": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/Utils": 50,
            "./world/World": 54,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        37: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Capsule.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Capsule;
            function Capsule(length, radius) {
                this.length = length || 1;
                this.radius = radius || 1;
                Shape.call(this, Shape.CAPSULE);
            }
            Capsule.prototype = new Shape();
            Capsule.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius, w = this.length + r, h = r * 2;
                return mass * (h * h + w * w) / 12;
            };
            Capsule.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2;
            };
            Capsule.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
            };
            var r = vec2.create();
            Capsule.prototype.computeAABB = function(out, position, angle) {
                var radius = this.radius;
                vec2.set(r, this.length / 2, 0);
                if (angle !== 0) {
                    vec2.rotate(r, r, angle);
                }
                vec2.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
                vec2.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
                vec2.add(out.lowerBound, out.lowerBound, position);
                vec2.add(out.upperBound, out.upperBound, position);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        38: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Circle.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Circle;
            function Circle(radius) {
                this.radius = radius || 1;
                Shape.call(this, Shape.CIRCLE);
            }
            Circle.prototype = new Shape();
            Circle.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius;
                return mass * r * r / 2;
            };
            Circle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius;
            };
            Circle.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius;
            };
            Circle.prototype.computeAABB = function(out, position, angle) {
                var r = this.radius;
                vec2.set(out.upperBound, r, r);
                vec2.set(out.lowerBound, -r, -r);
                if (position) {
                    vec2.add(out.lowerBound, out.lowerBound, position);
                    vec2.add(out.upperBound, out.upperBound, position);
                }
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        39: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Convex.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), polyk = require("../math/polyk"), decomp = require("poly-decomp");
            module.exports = Convex;
            function Convex(vertices, axes) {
                this.vertices = [];
                this.axes = [];
                for (var i = 0; i < vertices.length; i++) {
                    var v = vec2.create();
                    vec2.copy(v, vertices[i]);
                    this.vertices.push(v);
                }
                if (axes) {
                    for (var i = 0; i < axes.length; i++) {
                        var axis = vec2.create();
                        vec2.copy(axis, axes[i]);
                        this.axes.push(axis);
                    }
                } else {
                    for (var i = 0; i < vertices.length; i++) {
                        var worldPoint0 = vertices[i];
                        var worldPoint1 = vertices[(i + 1) % vertices.length];
                        var normal = vec2.create();
                        vec2.sub(normal, worldPoint1, worldPoint0);
                        vec2.rotate90cw(normal, normal);
                        vec2.normalize(normal, normal);
                        this.axes.push(normal);
                    }
                }
                this.centerOfMass = vec2.fromValues(0, 0);
                this.triangles = [];
                if (this.vertices.length) {
                    this.updateTriangles();
                    this.updateCenterOfMass();
                }
                this.boundingRadius = 0;
                Shape.call(this, Shape.CONVEX);
                this.updateBoundingRadius();
                this.updateArea();
                if (this.area < 0) {
                    throw new Error("Convex vertices must be given in conter-clockwise winding.");
                }
            }
            Convex.prototype = new Shape();
            var tmpVec1 = vec2.create();
            var tmpVec2 = vec2.create();
            Convex.prototype.projectOntoLocalAxis = function(localAxis, result) {
                var max = null, min = null, v, value, localAxis = tmpVec1;
                for (var i = 0; i < this.vertices.length; i++) {
                    v = this.vertices[i];
                    value = vec2.dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                vec2.set(result, min, max);
            };
            Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result) {
                var worldAxis = tmpVec2;
                this.projectOntoLocalAxis(localAxis, result);
                if (shapeAngle !== 0) {
                    vec2.rotate(worldAxis, localAxis, shapeAngle);
                } else {
                    worldAxis = localAxis;
                }
                var offset = vec2.dot(shapeOffset, worldAxis);
                vec2.set(result, result[0] + offset, result[1] + offset);
            };
            Convex.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                var polykVerts = [];
                for (var i = 0; i < this.vertices.length; i++) {
                    var v = this.vertices[i];
                    polykVerts.push(v[0], v[1]);
                }
                var triangles = polyk.Triangulate(polykVerts);
                for (var i = 0; i < triangles.length; i += 3) {
                    var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
                    this.triangles.push([ id1, id2, id3 ]);
                }
            };
            var updateCenterOfMass_centroid = vec2.create(), updateCenterOfMass_centroid_times_mass = vec2.create(), updateCenterOfMass_a = vec2.create(), updateCenterOfMass_b = vec2.create(), updateCenterOfMass_c = vec2.create(), updateCenterOfMass_ac = vec2.create(), updateCenterOfMass_ca = vec2.create(), updateCenterOfMass_cb = vec2.create(), updateCenterOfMass_n = vec2.create();
            Convex.prototype.updateCenterOfMass = function() {
                var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, n = updateCenterOfMass_n, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, ac = updateCenterOfMass_ac, ca = updateCenterOfMass_ca, cb = updateCenterOfMass_cb, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
                vec2.set(cm, 0, 0);
                var totalArea = 0;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    vec2.centroid(centroid, a, b, c);
                    var m = Convex.triangleArea(a, b, c);
                    totalArea += m;
                    vec2.scale(centroid_times_mass, centroid, m);
                    vec2.add(cm, cm, centroid_times_mass);
                }
                vec2.scale(cm, cm, 1 / totalArea);
            };
            Convex.prototype.computeMomentOfInertia = function(mass) {
                var denom = 0, numer = 0, N = this.vertices.length;
                for (var j = N - 1, i = 0; i < N; j = i, i++) {
                    var p0 = this.vertices[j];
                    var p1 = this.vertices[i];
                    var a = Math.abs(vec2.crossLength(p0, p1));
                    var b = vec2.dot(p1, p1) + vec2.dot(p1, p0) + vec2.dot(p0, p0);
                    denom += a * b;
                    numer += a;
                }
                return mass / 6 * (denom / numer);
            };
            Convex.prototype.updateBoundingRadius = function() {
                var verts = this.vertices, r2 = 0;
                for (var i = 0; i !== verts.length; i++) {
                    var l2 = vec2.squaredLength(verts[i]);
                    if (l2 > r2) {
                        r2 = l2;
                    }
                }
                this.boundingRadius = Math.sqrt(r2);
            };
            Convex.triangleArea = function(a, b, c) {
                return ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) * .5;
            };
            Convex.prototype.updateArea = function() {
                this.updateTriangles();
                this.area = 0;
                var triangles = this.triangles, verts = this.vertices;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    var m = Convex.triangleArea(a, b, c);
                    this.area += m;
                }
            };
            Convex.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
        }, {
            "../math/polyk": 30,
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2,
            "poly-decomp": 7
        } ],
        40: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Heightfield.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = Heightfield;
            function Heightfield(data, options) {
                options = Utils.defaults(options, {
                    maxValue: null,
                    minValue: null,
                    elementWidth: .1
                });
                if (options.minValue === null || options.maxValue === null) {
                    options.maxValue = data[0];
                    options.minValue = data[0];
                    for (var i = 0; i !== data.length; i++) {
                        var v = data[i];
                        if (v > options.maxValue) {
                            options.maxValue = v;
                        }
                        if (v < options.minValue) {
                            options.minValue = v;
                        }
                    }
                }
                this.data = data;
                this.maxValue = options.maxValue;
                this.minValue = options.minValue;
                this.elementWidth = options.elementWidth;
                Shape.call(this, Shape.HEIGHTFIELD);
            }
            Heightfield.prototype = new Shape();
            Heightfield.prototype.computeMomentOfInertia = function(mass) {
                return Number.MAX_VALUE;
            };
            Heightfield.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Heightfield.prototype.updateArea = function() {
                var data = this.data, area = 0;
                for (var i = 0; i < data.length - 1; i++) {
                    area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
                }
                this.area = area;
            };
            Heightfield.prototype.computeAABB = function(out, position, angle) {
                out.upperBound[0] = this.elementWidth * this.data.length + position[0];
                out.upperBound[1] = this.maxValue + position[1];
                out.lowerBound[0] = position[0];
                out.lowerBound[1] = -Number.MAX_VALUE;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        41: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Line.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Line;
            function Line(length) {
                this.length = length || 1;
                Shape.call(this, Shape.LINE);
            }
            Line.prototype = new Shape();
            Line.prototype.computeMomentOfInertia = function(mass) {
                return mass * Math.pow(this.length, 2) / 12;
            };
            Line.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2;
            };
            var points = [ vec2.create(), vec2.create() ];
            Line.prototype.computeAABB = function(out, position, angle) {
                var l2 = this.length / 2;
                vec2.set(points[0], -l2, 0);
                vec2.set(points[1], l2, 0);
                out.setFromPoints(points, position, angle, 0);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        42: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Particle.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Particle;
            function Particle() {
                Shape.call(this, Shape.PARTICLE);
            }
            Particle.prototype = new Shape();
            Particle.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Particle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0;
            };
            Particle.prototype.computeAABB = function(out, position, angle) {
                vec2.copy(out.lowerBound, position);
                vec2.copy(out.upperBound, position);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        43: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Plane.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = Plane;
            function Plane() {
                Shape.call(this, Shape.PLANE);
            }
            Plane.prototype = new Shape();
            Plane.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Plane.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Plane.prototype.computeAABB = function(out, position, angle) {
                var a = 0, set = vec2.set;
                if (typeof angle === "number") {
                    a = angle % (2 * Math.PI);
                }
                if (a === 0) {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, 0);
                } else if (a === Math.PI / 2) {
                    set(out.lowerBound, 0, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                } else if (a === Math.PI) {
                    set(out.lowerBound, -Number.MAX_VALUE, 0);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                } else if (a === 3 * Math.PI / 2) {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, 0, Number.MAX_VALUE);
                } else {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                }
                vec2.add(out.lowerBound, out.lowerBound, position);
                vec2.add(out.upperBound, out.upperBound, position);
            };
            Plane.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        44: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Rectangle.js", __dirname = "/shapes";
            var vec2 = require("../math/vec2"), Shape = require("./Shape"), Convex = require("./Convex");
            module.exports = Rectangle;
            function Rectangle(width, height) {
                this.width = width || 1;
                this.height = height || 1;
                var verts = [ vec2.fromValues(-width / 2, -height / 2), vec2.fromValues(width / 2, -height / 2), vec2.fromValues(width / 2, height / 2), vec2.fromValues(-width / 2, height / 2) ];
                var axes = [ vec2.fromValues(1, 0), vec2.fromValues(0, 1) ];
                Convex.call(this, verts, axes);
                this.type = Shape.RECTANGLE;
            }
            Rectangle.prototype = new Convex([]);
            Rectangle.prototype.computeMomentOfInertia = function(mass) {
                var w = this.width, h = this.height;
                return mass * (h * h + w * w) / 12;
            };
            Rectangle.prototype.updateBoundingRadius = function() {
                var w = this.width, h = this.height;
                this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
            };
            var corner1 = vec2.create(), corner2 = vec2.create(), corner3 = vec2.create(), corner4 = vec2.create();
            Rectangle.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
            Rectangle.prototype.updateArea = function() {
                this.area = this.width * this.height;
            };
        }, {
            "../math/vec2": 31,
            "./Convex": 39,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        45: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Shape.js", __dirname = "/shapes";
            module.exports = Shape;
            function Shape(type) {
                this.type = type;
                this.id = Shape.idCounter++;
                this.boundingRadius = 0;
                this.collisionGroup = 1;
                this.collisionMask = 1;
                if (type) {
                    this.updateBoundingRadius();
                }
                this.material = null;
                this.area = 0;
                this.sensor = false;
                this.updateArea();
            }
            Shape.idCounter = 0;
            Shape.CIRCLE = 1;
            Shape.PARTICLE = 2;
            Shape.PLANE = 4;
            Shape.CONVEX = 8;
            Shape.LINE = 16;
            Shape.RECTANGLE = 32;
            Shape.CAPSULE = 64;
            Shape.HEIGHTFIELD = 128;
            Shape.prototype.computeMomentOfInertia = function(mass) {
                throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
            };
            Shape.prototype.updateBoundingRadius = function() {
                throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
            };
            Shape.prototype.updateArea = function() {};
            Shape.prototype.computeAABB = function(out, position, angle) {};
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        46: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/solver\\GSSolver.js", __dirname = "/solver";
            var vec2 = require("../math/vec2"), Solver = require("./Solver"), Utils = require("../utils/Utils"), FrictionEquation = require("../equations/FrictionEquation");
            module.exports = GSSolver;
            function GSSolver(options) {
                Solver.call(this, options, Solver.GS);
                options = options || {};
                this.iterations = options.iterations || 10;
                this.tolerance = options.tolerance || 1e-10;
                this.arrayStep = 30;
                this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
                this.Bs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.invCs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.useZeroRHS = false;
                this.frictionIterations = 0;
                this.usedIterations = 0;
            }
            GSSolver.prototype = new Solver();
            function setArrayZero(array) {
                var l = array.length;
                while (l--) {
                    array[l] = +0;
                }
            }
            GSSolver.prototype.solve = function(h, world) {
                this.sortEquations();
                var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = world.bodies.length, add = vec2.add, set = vec2.set, useZeroRHS = this.useZeroRHS, lambda = this.lambda;
                this.usedIterations = 0;
                if (Neq) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.updateSolveMassProperties();
                    }
                }
                if (lambda.length < Neq) {
                    lambda = this.lambda = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.Bs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.invCs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                }
                setArrayZero(lambda);
                var invCs = this.invCs, Bs = this.Bs, lambda = this.lambda;
                for (var i = 0; i !== equations.length; i++) {
                    var c = equations[i];
                    if (c.timeStep !== h || c.needsUpdate) {
                        c.timeStep = h;
                        c.update();
                    }
                    Bs[i] = c.computeB(c.a, c.b, h);
                    invCs[i] = c.computeInvC(c.epsilon);
                }
                var q, B, c, deltalambdaTot, i, j;
                if (Neq !== 0) {
                    for (i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.resetConstraintVelocity();
                    }
                    if (maxFrictionIter) {
                        for (iter = 0; iter !== maxFrictionIter; iter++) {
                            deltalambdaTot = 0;
                            for (j = 0; j !== Neq; j++) {
                                c = equations[j];
                                var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                                deltalambdaTot += Math.abs(deltalambda);
                            }
                            this.usedIterations++;
                            if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                                break;
                            }
                        }
                        GSSolver.updateMultipliers(equations, lambda, 1 / h);
                        for (j = 0; j !== Neq; j++) {
                            var eq = equations[j];
                            if (eq instanceof FrictionEquation) {
                                var f = 0;
                                for (var k = 0; k !== eq.contactEquations.length; k++) {
                                    f += eq.contactEquations[k].multiplier;
                                }
                                f *= eq.frictionCoefficient / eq.contactEquations.length;
                                eq.maxForce = f;
                                eq.minForce = -f;
                            }
                        }
                    }
                    for (iter = 0; iter !== maxIter; iter++) {
                        deltalambdaTot = 0;
                        for (j = 0; j !== Neq; j++) {
                            c = equations[j];
                            var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                            deltalambdaTot += Math.abs(deltalambda);
                        }
                        this.usedIterations++;
                        if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                            break;
                        }
                    }
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].addConstraintVelocity();
                    }
                    GSSolver.updateMultipliers(equations, lambda, 1 / h);
                }
            };
            GSSolver.updateMultipliers = function(equations, lambda, invDt) {
                var l = equations.length;
                while (l--) {
                    equations[l].multiplier = lambda[l] * invDt;
                }
            };
            GSSolver.iterateEquation = function(j, eq, eps, Bs, invCs, lambda, useZeroRHS, dt, iter) {
                var B = Bs[j], invC = invCs[j], lambdaj = lambda[j], GWlambda = eq.computeGWlambda();
                var maxForce = eq.maxForce, minForce = eq.minForce;
                if (useZeroRHS) {
                    B = 0;
                }
                var deltalambda = invC * (B - GWlambda - eps * lambdaj);
                var lambdaj_plus_deltalambda = lambdaj + deltalambda;
                if (lambdaj_plus_deltalambda < minForce * dt) {
                    deltalambda = minForce * dt - lambdaj;
                } else if (lambdaj_plus_deltalambda > maxForce * dt) {
                    deltalambda = maxForce * dt - lambdaj;
                }
                lambda[j] += deltalambda;
                eq.addToWlambda(deltalambda);
                return deltalambda;
            };
        }, {
            "../equations/FrictionEquation": 24,
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Solver": 47,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        47: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/solver\\Solver.js", __dirname = "/solver";
            var Utils = require("../utils/Utils"), EventEmitter = require("../events/EventEmitter");
            module.exports = Solver;
            function Solver(options, type) {
                options = options || {};
                EventEmitter.call(this);
                this.type = type;
                this.equations = [];
                this.equationSortFunction = options.equationSortFunction || false;
            }
            Solver.prototype = new EventEmitter();
            Solver.prototype.solve = function(dt, world) {
                throw new Error("Solver.solve should be implemented by subclasses!");
            };
            var mockWorld = {
                bodies: []
            };
            Solver.prototype.solveIsland = function(dt, island) {
                this.removeAllEquations();
                if (island.equations.length) {
                    this.addEquations(island.equations);
                    mockWorld.bodies.length = 0;
                    island.getBodies(mockWorld.bodies);
                    if (mockWorld.bodies.length) {
                        this.solve(dt, mockWorld);
                    }
                }
            };
            Solver.prototype.sortEquations = function() {
                if (this.equationSortFunction) {
                    this.equations.sort(this.equationSortFunction);
                }
            };
            Solver.prototype.addEquation = function(eq) {
                if (eq.enabled) {
                    this.equations.push(eq);
                }
            };
            Solver.prototype.addEquations = function(eqs) {
                for (var i = 0, N = eqs.length; i !== N; i++) {
                    var eq = eqs[i];
                    if (eq.enabled) {
                        this.equations.push(eq);
                    }
                }
            };
            Solver.prototype.removeEquation = function(eq) {
                var i = this.equations.indexOf(eq);
                if (i !== -1) {
                    this.equations.splice(i, 1);
                }
            };
            Solver.prototype.removeAllEquations = function() {
                this.equations.length = 0;
            };
            Solver.GS = 1;
            Solver.ISLAND = 2;
        }, {
            "../events/EventEmitter": 27,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        48: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\OverlapKeeper.js", __dirname = "/utils";
            var TupleDictionary = require("./TupleDictionary");
            var Utils = require("./Utils");
            module.exports = OverlapKeeper;
            function OverlapKeeper() {
                this.overlappingShapesLastState = new TupleDictionary();
                this.overlappingShapesCurrentState = new TupleDictionary();
                this.recordPool = [];
                this.tmpDict = new TupleDictionary();
                this.tmpArray1 = [];
            }
            OverlapKeeper.prototype.tick = function() {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                var l = last.keys.length;
                while (l--) {
                    var key = last.keys[l];
                    var lastObject = last.getByKey(key);
                    var currentObject = current.getByKey(key);
                    if (lastObject && !currentObject) {
                        this.recordPool.push(lastObject);
                    }
                }
                last.reset();
                last.copy(current);
                current.reset();
            };
            OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                if (!current.get(shapeA.id, shapeB.id)) {
                    var data;
                    if (this.recordPool.length) {
                        data = this.recordPool.pop();
                        data.set(bodyA, shapeA, bodyB, shapeB);
                    } else {
                        data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
                    }
                    current.set(shapeA.id, shapeB.id, data);
                }
            };
            OverlapKeeper.prototype.getNewOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
            };
            OverlapKeeper.prototype.getEndOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
            };
            OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB) {
                var current = this.overlappingShapesCurrentState;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {
                        return true;
                    }
                }
                return false;
            };
            OverlapKeeper.prototype.getDiff = function(dictA, dictB, result) {
                var result = result || [];
                var last = dictA;
                var current = dictB;
                result.length = 0;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (!data) {
                        throw new Error("Key " + key + " had no data!");
                    }
                    var lastData = last.data[key];
                    if (!lastData) {
                        result.push(data);
                    }
                }
                return result;
            };
            OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB) {
                var idA = shapeA.id | 0, idB = shapeB.id | 0;
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                return !!!last.get(idA, idB) && !!current.get(idA, idB);
            };
            OverlapKeeper.prototype.getNewBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getEndBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getBodyDiff = function(overlaps, result) {
                result = result || [];
                var accumulator = this.tmpDict;
                var l = overlaps.length;
                while (l--) {
                    var data = overlaps[l];
                    accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
                }
                l = accumulator.keys.length;
                while (l--) {
                    var data = accumulator.getByKey(accumulator.keys[l]);
                    if (data) {
                        result.push(data.bodyA, data.bodyB);
                    }
                }
                accumulator.reset();
                return result;
            };
            function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
                this.shapeA = shapeA;
                this.shapeB = shapeB;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB) {
                OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
            };
        }, {
            "./TupleDictionary": 49,
            "./Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        49: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\TupleDictionary.js", __dirname = "/utils";
            var Utils = require("./Utils");
            module.exports = TupleDictionary;
            function TupleDictionary() {
                this.data = {};
                this.keys = [];
            }
            TupleDictionary.prototype.getKey = function(id1, id2) {
                id1 = id1 | 0;
                id2 = id2 | 0;
                if ((id1 | 0) === (id2 | 0)) {
                    return -1;
                }
                return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 65535 : id2 << 16 | id1 & 65535) | 0;
            };
            TupleDictionary.prototype.getByKey = function(key) {
                key = key | 0;
                return this.data[key];
            };
            TupleDictionary.prototype.get = function(i, j) {
                return this.data[this.getKey(i, j)];
            };
            TupleDictionary.prototype.set = function(i, j, value) {
                if (!value) {
                    throw new Error("No data!");
                }
                var key = this.getKey(i, j);
                if (!this.data[key]) {
                    this.keys.push(key);
                }
                this.data[key] = value;
                return key;
            };
            TupleDictionary.prototype.reset = function() {
                var data = this.data, keys = this.keys;
                var l = keys.length;
                while (l--) {
                    delete data[keys[l]];
                }
                keys.length = 0;
            };
            TupleDictionary.prototype.copy = function(dict) {
                this.reset();
                Utils.appendArray(this.keys, dict.keys);
                var l = dict.keys.length;
                while (l--) {
                    var key = dict.keys[l];
                    this.data[key] = dict.data[key];
                }
            };
        }, {
            "./Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        50: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\Utils.js", __dirname = "/utils";
            module.exports = Utils;
            function Utils() {}
            Utils.appendArray = function(a, b) {
                if (b.length < 15e4) {
                    a.push.apply(a, b);
                } else {
                    for (var i = 0, len = b.length; i !== len; ++i) {
                        a.push(b[i]);
                    }
                }
            };
            Utils.splice = function(array, index, howmany) {
                howmany = howmany || 1;
                for (var i = index, len = array.length - howmany; i < len; i++) {
                    array[i] = array[i + howmany];
                }
                array.length = len;
            };
            Utils.ARRAY_TYPE = window.Float32Array || Array;
            Utils.extend = function(a, b) {
                for (var key in b) {
                    a[key] = b[key];
                }
            };
            Utils.defaults = function(options, defaults) {
                options = options || {};
                for (var key in defaults) {
                    if (!(key in options)) {
                        options[key] = defaults[key];
                    }
                }
                return options;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        51: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\Island.js", __dirname = "/world";
            var Body = require("../objects/Body");
            module.exports = Island;
            function Island() {
                this.equations = [];
                this.bodies = [];
            }
            Island.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0;
            };
            var bodyIds = [];
            Island.prototype.getBodies = function(result) {
                var bodies = result || [], eqs = this.equations;
                bodyIds.length = 0;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    if (bodyIds.indexOf(eq.bodyA.id) === -1) {
                        bodies.push(eq.bodyA);
                        bodyIds.push(eq.bodyA.id);
                    }
                    if (bodyIds.indexOf(eq.bodyB.id) === -1) {
                        bodies.push(eq.bodyB);
                        bodyIds.push(eq.bodyB.id);
                    }
                }
                return bodies;
            };
            Island.prototype.wantsToSleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    if (b.type === Body.DYNAMIC && !b.wantsToSleep) {
                        return false;
                    }
                }
                return true;
            };
            Island.prototype.sleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    b.sleep();
                }
                return true;
            };
        }, {
            "../objects/Body": 32,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        52: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\IslandManager.js", __dirname = "/world";
            var vec2 = require("../math/vec2"), Island = require("./Island"), IslandNode = require("./IslandNode"), Body = require("../objects/Body");
            module.exports = IslandManager;
            function IslandManager(options) {
                this._nodePool = [];
                this._islandPool = [];
                this.equations = [];
                this.islands = [];
                this.nodes = [];
                this.queue = [];
            }
            IslandManager.getUnvisitedNode = function(nodes) {
                var Nnodes = nodes.length;
                for (var i = 0; i !== Nnodes; i++) {
                    var node = nodes[i];
                    if (!node.visited && node.body.type === Body.DYNAMIC) {
                        return node;
                    }
                }
                return false;
            };
            IslandManager.prototype.visit = function(node, bds, eqs) {
                bds.push(node.body);
                var Neqs = node.equations.length;
                for (var i = 0; i !== Neqs; i++) {
                    var eq = node.equations[i];
                    if (eqs.indexOf(eq) === -1) {
                        eqs.push(eq);
                    }
                }
            };
            IslandManager.prototype.bfs = function(root, bds, eqs) {
                var queue = this.queue;
                queue.length = 0;
                queue.push(root);
                root.visited = true;
                this.visit(root, bds, eqs);
                while (queue.length) {
                    var node = queue.pop();
                    var child;
                    while (child = IslandManager.getUnvisitedNode(node.neighbors)) {
                        child.visited = true;
                        this.visit(child, bds, eqs);
                        if (child.body.type === Body.DYNAMIC) {
                            queue.push(child);
                        }
                    }
                }
            };
            IslandManager.prototype.split = function(world) {
                var bodies = world.bodies, nodes = this.nodes, equations = this.equations;
                while (nodes.length) {
                    this._nodePool.push(nodes.pop());
                }
                for (var i = 0; i !== bodies.length; i++) {
                    if (this._nodePool.length) {
                        var node = this._nodePool.pop();
                        node.reset();
                        node.body = bodies[i];
                        nodes.push(node);
                    } else {
                        nodes.push(new IslandNode(bodies[i]));
                    }
                }
                for (var k = 0; k !== equations.length; k++) {
                    var eq = equations[k], i = bodies.indexOf(eq.bodyA), j = bodies.indexOf(eq.bodyB), ni = nodes[i], nj = nodes[j];
                    ni.neighbors.push(nj);
                    nj.neighbors.push(ni);
                    ni.equations.push(eq);
                    nj.equations.push(eq);
                }
                var islands = this.islands;
                while (islands.length) {
                    var island = islands.pop();
                    island.reset();
                    this._islandPool.push(island);
                }
                var child;
                while (child = IslandManager.getUnvisitedNode(nodes)) {
                    var island = this._islandPool.length ? this._islandPool.pop() : new Island();
                    this.bfs(child, island.bodies, island.equations);
                    islands.push(island);
                }
                return islands;
            };
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            "./Island": 51,
            "./IslandNode": 53,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        53: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\IslandNode.js", __dirname = "/world";
            module.exports = IslandNode;
            function IslandNode(body) {
                this.body = body;
                this.neighbors = [];
                this.equations = [];
                this.visited = false;
            }
            IslandNode.prototype.reset = function() {
                this.equations.length = 0;
                this.neighbors.length = 0;
                this.visited = false;
                this.body = null;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        54: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\World.js", __dirname = "/world";
            var GSSolver = require("../solver/GSSolver"), Solver = require("../solver/Solver"), NaiveBroadphase = require("../collision/NaiveBroadphase"), vec2 = require("../math/vec2"), Circle = require("../shapes/Circle"), Rectangle = require("../shapes/Rectangle"), Convex = require("../shapes/Convex"), Line = require("../shapes/Line"), Plane = require("../shapes/Plane"), Capsule = require("../shapes/Capsule"), Particle = require("../shapes/Particle"), EventEmitter = require("../events/EventEmitter"), Body = require("../objects/Body"), Shape = require("../shapes/Shape"), LinearSpring = require("../objects/LinearSpring"), Material = require("../material/Material"), ContactMaterial = require("../material/ContactMaterial"), DistanceConstraint = require("../constraints/DistanceConstraint"), Constraint = require("../constraints/Constraint"), LockConstraint = require("../constraints/LockConstraint"), RevoluteConstraint = require("../constraints/RevoluteConstraint"), PrismaticConstraint = require("../constraints/PrismaticConstraint"), GearConstraint = require("../constraints/GearConstraint"), pkg = require("../../package.json"), Broadphase = require("../collision/Broadphase"), SAPBroadphase = require("../collision/SAPBroadphase"), Narrowphase = require("../collision/Narrowphase"), Utils = require("../utils/Utils"), OverlapKeeper = require("../utils/OverlapKeeper"), IslandManager = require("./IslandManager"), RotationalSpring = require("../objects/RotationalSpring");
            module.exports = World;
            if (typeof performance === "undefined") {
                performance = {};
            }
            if (!performance.now) {
                var nowOffset = Date.now();
                if (performance.timing && performance.timing.navigationStart) {
                    nowOffset = performance.timing.navigationStart;
                }
                performance.now = function() {
                    return Date.now() - nowOffset;
                };
            }
            function World(options) {
                EventEmitter.apply(this);
                options = options || {};
                this.springs = [];
                this.bodies = [];
                this.disabledBodyCollisionPairs = [];
                this.solver = options.solver || new GSSolver();
                this.narrowphase = new Narrowphase(this);
                this.islandManager = new IslandManager();
                this.gravity = vec2.fromValues(0, -9.78);
                if (options.gravity) {
                    vec2.copy(this.gravity, options.gravity);
                }
                this.frictionGravity = vec2.length(this.gravity) || 10;
                this.useWorldGravityAsFrictionGravity = true;
                this.useFrictionGravityOnZeroGravity = true;
                this.doProfiling = options.doProfiling || false;
                this.lastStepTime = 0;
                this.broadphase = options.broadphase || new SAPBroadphase();
                this.broadphase.setWorld(this);
                this.constraints = [];
                this.defaultMaterial = new Material();
                this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);
                this.lastTimeStep = 1 / 60;
                this.applySpringForces = true;
                this.applyDamping = true;
                this.applyGravity = true;
                this.solveConstraints = true;
                this.contactMaterials = [];
                this.time = 0;
                this.stepping = false;
                this.bodiesToBeRemoved = [];
                this.fixedStepTime = 0;
                this.islandSplit = typeof options.islandSplit !== "undefined" ? !!options.islandSplit : false;
                this.emitImpactEvent = true;
                this._constraintIdCounter = 0;
                this._bodyIdCounter = 0;
                this.postStepEvent = {
                    type: "postStep"
                };
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                };
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                };
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                };
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                };
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                };
                this.sleepMode = World.NO_SLEEPING;
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                };
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                };
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                };
                this.overlappingShapesLastState = {
                    keys: []
                };
                this.overlappingShapesCurrentState = {
                    keys: []
                };
                this.overlapKeeper = new OverlapKeeper();
            }
            World.prototype = new Object(EventEmitter.prototype);
            World.NO_SLEEPING = 1;
            World.BODY_SLEEPING = 2;
            World.ISLAND_SLEEPING = 4;
            World.prototype.addConstraint = function(c) {
                this.constraints.push(c);
            };
            World.prototype.addContactMaterial = function(contactMaterial) {
                this.contactMaterials.push(contactMaterial);
            };
            World.prototype.removeContactMaterial = function(cm) {
                var idx = this.contactMaterials.indexOf(cm);
                if (idx !== -1) {
                    Utils.splice(this.contactMaterials, idx, 1);
                }
            };
            World.prototype.getContactMaterial = function(materialA, materialB) {
                var cmats = this.contactMaterials;
                for (var i = 0, N = cmats.length; i !== N; i++) {
                    var cm = cmats[i];
                    if (cm.materialA.id === materialA.id && cm.materialB.id === materialB.id || cm.materialA.id === materialB.id && cm.materialB.id === materialA.id) {
                        return cm;
                    }
                }
                return false;
            };
            World.prototype.removeConstraint = function(c) {
                var idx = this.constraints.indexOf(c);
                if (idx !== -1) {
                    Utils.splice(this.constraints, idx, 1);
                }
            };
            var step_r = vec2.create(), step_runit = vec2.create(), step_u = vec2.create(), step_f = vec2.create(), step_fhMinv = vec2.create(), step_velodt = vec2.create(), step_mg = vec2.create(), xiw = vec2.fromValues(0, 0), xjw = vec2.fromValues(0, 0), zero = vec2.fromValues(0, 0), interpvelo = vec2.fromValues(0, 0);
            World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
                maxSubSteps = maxSubSteps || 10;
                timeSinceLastCalled = timeSinceLastCalled || 0;
                if (timeSinceLastCalled === 0) {
                    this.internalStep(dt);
                    this.time += dt;
                } else {
                    var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                    internalSteps = Math.min(internalSteps, maxSubSteps);
                    var t0 = performance.now();
                    for (var i = 0; i !== internalSteps; i++) {
                        this.internalStep(dt);
                        if (performance.now() - t0 > dt * 1e3) {
                            break;
                        }
                    }
                    this.time += timeSinceLastCalled;
                    var h = this.time % dt;
                    var h_div_dt = h / dt;
                    for (var j = 0; j !== this.bodies.length; j++) {
                        var b = this.bodies[j];
                        if (b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING) {
                            vec2.sub(interpvelo, b.position, b.previousPosition);
                            vec2.scale(interpvelo, interpvelo, h_div_dt);
                            vec2.add(b.interpolatedPosition, b.position, interpvelo);
                            b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
                        } else {
                            vec2.copy(b.interpolatedPosition, b.position);
                            b.interpolatedAngle = b.angle;
                        }
                    }
                }
            };
            var endOverlaps = [];
            World.prototype.internalStep = function(dt) {
                this.stepping = true;
                var that = this, doProfiling = this.doProfiling, Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, t0, t1, fhMinv = step_fhMinv, velodt = step_velodt, mg = step_mg, scale = vec2.scale, add = vec2.add, rotate = vec2.rotate, islandManager = this.islandManager;
                this.overlapKeeper.tick();
                this.lastTimeStep = dt;
                if (doProfiling) {
                    t0 = performance.now();
                }
                if (this.useWorldGravityAsFrictionGravity) {
                    var gravityLen = vec2.length(this.gravity);
                    if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                        this.frictionGravity = gravityLen;
                    }
                }
                if (this.applyGravity) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i], fi = b.force;
                        if (b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING) {
                            continue;
                        }
                        vec2.scale(mg, g, b.mass * b.gravityScale);
                        add(fi, fi, mg);
                    }
                }
                if (this.applySpringForces) {
                    for (var i = 0; i !== Nsprings; i++) {
                        var s = springs[i];
                        s.applyForce();
                    }
                }
                if (this.applyDamping) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        if (b.type === Body.DYNAMIC) {
                            b.applyDamping(dt);
                        }
                    }
                }
                var result = broadphase.getCollisionPairs(this);
                var ignoredPairs = this.disabledBodyCollisionPairs;
                for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
                    for (var j = result.length - 2; j >= 0; j -= 2) {
                        if (ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1] || ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1]) {
                            result.splice(j, 2);
                        }
                    }
                }
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    var c = constraints[i];
                    if (!c.collideConnected) {
                        for (var j = result.length - 2; j >= 0; j -= 2) {
                            if (c.bodyA === result[j] && c.bodyB === result[j + 1] || c.bodyB === result[j] && c.bodyA === result[j + 1]) {
                                result.splice(j, 2);
                            }
                        }
                    }
                }
                this.postBroadphaseEvent.pairs = result;
                this.emit(this.postBroadphaseEvent);
                np.reset(this);
                for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
                    var bi = result[i], bj = result[i + 1];
                    for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                        var si = bi.shapes[k], xi = bi.shapeOffsets[k], ai = bi.shapeAngles[k];
                        for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                            var sj = bj.shapes[l], xj = bj.shapeOffsets[l], aj = bj.shapeAngles[l];
                            var cm = this.defaultContactMaterial;
                            if (si.material && sj.material) {
                                var tmp = this.getContactMaterial(si.material, sj.material);
                                if (tmp) {
                                    cm = tmp;
                                }
                            }
                            this.runNarrowphase(np, bi, si, xi, ai, bj, sj, xj, aj, cm, this.frictionGravity);
                        }
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    if (body._wakeUpAfterNarrowphase) {
                        body.wakeUp();
                        body._wakeUpAfterNarrowphase = false;
                    }
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(endOverlaps);
                    var e = this.endContactEvent;
                    var l = endOverlaps.length;
                    while (l--) {
                        var data = endOverlaps[l];
                        e.shapeA = data.shapeA;
                        e.shapeB = data.shapeB;
                        e.bodyA = data.bodyA;
                        e.bodyB = data.bodyB;
                        this.emit(e);
                    }
                }
                var preSolveEvent = this.preSolveEvent;
                preSolveEvent.contactEquations = np.contactEquations;
                preSolveEvent.frictionEquations = np.frictionEquations;
                this.emit(preSolveEvent);
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    constraints[i].update();
                }
                if (np.contactEquations.length || np.frictionEquations.length || constraints.length) {
                    if (this.islandSplit) {
                        islandManager.equations.length = 0;
                        Utils.appendArray(islandManager.equations, np.contactEquations);
                        Utils.appendArray(islandManager.equations, np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            Utils.appendArray(islandManager.equations, constraints[i].equations);
                        }
                        islandManager.split(this);
                        for (var i = 0; i !== islandManager.islands.length; i++) {
                            var island = islandManager.islands[i];
                            if (island.equations.length) {
                                solver.solveIsland(dt, island);
                            }
                        }
                    } else {
                        solver.addEquations(np.contactEquations);
                        solver.addEquations(np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            solver.addEquations(constraints[i].equations);
                        }
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {
                        World.integrateBody(body, dt);
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    bodies[i].setZeroForce();
                }
                if (doProfiling) {
                    t1 = performance.now();
                    that.lastStepTime = t1 - t0;
                }
                if (this.emitImpactEvent && this.has("impact")) {
                    var ev = this.impactEvent;
                    for (var i = 0; i !== np.contactEquations.length; i++) {
                        var eq = np.contactEquations[i];
                        if (eq.firstImpact) {
                            ev.bodyA = eq.bodyA;
                            ev.bodyB = eq.bodyB;
                            ev.shapeA = eq.shapeA;
                            ev.shapeB = eq.shapeB;
                            ev.contactEquation = eq;
                            this.emit(ev);
                        }
                    }
                }
                if (this.sleepMode === World.BODY_SLEEPING) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, false, dt);
                    }
                } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, true, dt);
                    }
                    for (var i = 0; i < this.islandManager.islands.length; i++) {
                        var island = this.islandManager.islands[i];
                        if (island.wantsToSleep()) {
                            island.sleep();
                        }
                    }
                }
                this.stepping = false;
                if (this.bodiesToBeRemoved.length) {
                    for (var i = 0; i !== this.bodiesToBeRemoved.length; i++) {
                        this.removeBody(this.bodiesToBeRemoved[i]);
                    }
                    this.bodiesToBeRemoved.length = 0;
                }
                this.emit(this.postStepEvent);
            };
            var ib_fhMinv = vec2.create();
            var ib_velodt = vec2.create();
            World.integrateBody = function(body, dt) {
                var minv = body.invMass, f = body.force, pos = body.position, velo = body.velocity;
                vec2.copy(body.previousPosition, body.position);
                body.previousAngle = body.angle;
                if (!body.fixedRotation) {
                    body.angularVelocity += body.angularForce * body.invInertia * dt;
                    body.angle += body.angularVelocity * dt;
                }
                vec2.scale(ib_fhMinv, f, dt * minv);
                vec2.add(velo, ib_fhMinv, velo);
                vec2.scale(ib_velodt, velo, dt);
                vec2.add(pos, pos, ib_velodt);
                body.aabbNeedsUpdate = true;
            };
            World.prototype.runNarrowphase = function(np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
                if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
                    return;
                }
                vec2.rotate(xiw, xi, bi.angle);
                vec2.rotate(xjw, xj, bj.angle);
                vec2.add(xiw, xiw, bi.position);
                vec2.add(xjw, xjw, bj.position);
                var aiw = ai + bi.angle;
                var ajw = aj + bj.angle;
                np.enableFriction = cm.friction > 0;
                np.frictionCoefficient = cm.friction;
                var reducedMass;
                if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {
                    reducedMass = bj.mass;
                } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {
                    reducedMass = bi.mass;
                } else {
                    reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);
                }
                np.slipForce = cm.friction * glen * reducedMass;
                np.restitution = cm.restitution;
                np.surfaceVelocity = cm.surfaceVelocity;
                np.frictionStiffness = cm.frictionStiffness;
                np.frictionRelaxation = cm.frictionRelaxation;
                np.stiffness = cm.stiffness;
                np.relaxation = cm.relaxation;
                np.contactSkinSize = cm.contactSkinSize;
                var resolver = np[si.type | sj.type], numContacts = 0;
                if (resolver) {
                    var sensor = si.sensor || sj.sensor;
                    var numFrictionBefore = np.frictionEquations.length;
                    if (si.type < sj.type) {
                        numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);
                    } else {
                        numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);
                    }
                    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
                    if (numContacts) {
                        if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                            var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
                            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                            if (speedSquaredB >= speedLimitSquaredB * 2) {
                                bi._wakeUpAfterNarrowphase = true;
                            }
                        }
                        if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                            var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
                            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                            if (speedSquaredA >= speedLimitSquaredA * 2) {
                                bj._wakeUpAfterNarrowphase = true;
                            }
                        }
                        this.overlapKeeper.setOverlapping(bi, si, bj, sj);
                        if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(si, sj)) {
                            var e = this.beginContactEvent;
                            e.shapeA = si;
                            e.shapeB = sj;
                            e.bodyA = bi;
                            e.bodyB = bj;
                            e.contactEquations.length = 0;
                            if (typeof numContacts === "number") {
                                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                                    e.contactEquations.push(np.contactEquations[i]);
                                }
                            }
                            this.emit(e);
                        }
                        if (typeof numContacts === "number" && numFrictionEquations > 1) {
                            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                                var f = np.frictionEquations[i];
                                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                            }
                        }
                    }
                }
            };
            World.prototype.addSpring = function(s) {
                this.springs.push(s);
                this.addSpringEvent.spring = s;
                this.emit(this.addSpringEvent);
            };
            World.prototype.removeSpring = function(s) {
                var idx = this.springs.indexOf(s);
                if (idx !== -1) {
                    Utils.splice(this.springs, idx, 1);
                }
            };
            World.prototype.addBody = function(body) {
                if (this.bodies.indexOf(body) === -1) {
                    this.bodies.push(body);
                    body.world = this;
                    this.addBodyEvent.body = body;
                    this.emit(this.addBodyEvent);
                }
            };
            World.prototype.removeBody = function(body) {
                if (this.stepping) {
                    this.bodiesToBeRemoved.push(body);
                } else {
                    body.world = null;
                    var idx = this.bodies.indexOf(body);
                    if (idx !== -1) {
                        Utils.splice(this.bodies, idx, 1);
                        this.removeBodyEvent.body = body;
                        body.resetConstraintVelocity();
                        this.emit(this.removeBodyEvent);
                    }
                }
            };
            World.prototype.getBodyById = function(id) {
                var bodies = this.bodies;
                for (var i = 0; i < bodies.length; i++) {
                    var b = bodies[i];
                    if (b.id === id) {
                        return b;
                    }
                }
                return false;
            };
            World.prototype.disableBodyCollision = function(bodyA, bodyB) {
                this.disabledBodyCollisionPairs.push(bodyA, bodyB);
            };
            World.prototype.enableBodyCollision = function(bodyA, bodyB) {
                var pairs = this.disabledBodyCollisionPairs;
                for (var i = 0; i < pairs.length; i += 2) {
                    if (pairs[i] === bodyA && pairs[i + 1] === bodyB || pairs[i + 1] === bodyA && pairs[i] === bodyB) {
                        pairs.splice(i, 2);
                        return;
                    }
                }
            };
            function v2a(v) {
                if (!v) {
                    return v;
                }
                return [ v[0], v[1] ];
            }
            function extend(a, b) {
                for (var key in b) {
                    a[key] = b[key];
                }
            }
            function contactMaterialToJSON(cm) {
                return {
                    id: cm.id,
                    materialA: cm.materialA.id,
                    materialB: cm.materialB.id,
                    friction: cm.friction,
                    restitution: cm.restitution,
                    stiffness: cm.stiffness,
                    relaxation: cm.relaxation,
                    frictionStiffness: cm.frictionStiffness,
                    frictionRelaxation: cm.frictionRelaxation
                };
            }
            World.prototype.clear = function() {
                this.time = 0;
                this.fixedStepTime = 0;
                if (this.solver && this.solver.equations.length) {
                    this.solver.removeAllEquations();
                }
                var cs = this.constraints;
                for (var i = cs.length - 1; i >= 0; i--) {
                    this.removeConstraint(cs[i]);
                }
                var bodies = this.bodies;
                for (var i = bodies.length - 1; i >= 0; i--) {
                    this.removeBody(bodies[i]);
                }
                var springs = this.springs;
                for (var i = springs.length - 1; i >= 0; i--) {
                    this.removeSpring(springs[i]);
                }
                var cms = this.contactMaterials;
                for (var i = cms.length - 1; i >= 0; i--) {
                    this.removeContactMaterial(cms[i]);
                }
                World.apply(this);
            };
            World.prototype.clone = function() {
                var world = new World();
                world.fromJSON(this.toJSON());
                return world;
            };
            var hitTest_tmp1 = vec2.create(), hitTest_zero = vec2.fromValues(0, 0), hitTest_tmp2 = vec2.fromValues(0, 0);
            World.prototype.hitTest = function(worldPoint, bodies, precision) {
                precision = precision || 0;
                var pb = new Body({
                    position: worldPoint
                }), ps = new Particle(), px = worldPoint, pa = 0, x = hitTest_tmp1, zero = hitTest_zero, tmp = hitTest_tmp2;
                pb.addShape(ps);
                var n = this.narrowphase, result = [];
                for (var i = 0, N = bodies.length; i !== N; i++) {
                    var b = bodies[i];
                    for (var j = 0, NS = b.shapes.length; j !== NS; j++) {
                        var s = b.shapes[j], offset = b.shapeOffsets[j] || zero, angle = b.shapeAngles[j] || 0;
                        vec2.rotate(x, offset, b.angle);
                        vec2.add(x, x, b.position);
                        var a = angle + b.angle;
                        if (s instanceof Circle && n.circleParticle(b, s, x, a, pb, ps, px, pa, true) || s instanceof Convex && n.particleConvex(pb, ps, px, pa, b, s, x, a, true) || s instanceof Plane && n.particlePlane(pb, ps, px, pa, b, s, x, a, true) || s instanceof Capsule && n.particleCapsule(pb, ps, px, pa, b, s, x, a, true) || s instanceof Particle && vec2.squaredLength(vec2.sub(tmp, x, worldPoint)) < precision * precision) {
                            result.push(b);
                        }
                    }
                }
                return result;
            };
            World.prototype.setGlobalEquationParameters = function(parameters) {
                parameters = parameters || {};
                for (var i = 0; i !== this.constraints.length; i++) {
                    var c = this.constraints[i];
                    for (var j = 0; j !== c.equations.length; j++) {
                        var eq = c.equations[j];
                        if (typeof parameters.stiffness !== "undefined") {
                            eq.stiffness = parameters.stiffness;
                        }
                        if (typeof parameters.relaxation !== "undefined") {
                            eq.relaxation = parameters.relaxation;
                        }
                        eq.needsUpdate = true;
                    }
                }
                for (var i = 0; i !== this.contactMaterials.length; i++) {
                    var c = this.contactMaterials[i];
                    if (typeof parameters.stiffness !== "undefined") {
                        c.stiffness = parameters.stiffness;
                        c.frictionStiffness = parameters.stiffness;
                    }
                    if (typeof parameters.relaxation !== "undefined") {
                        c.relaxation = parameters.relaxation;
                        c.frictionRelaxation = parameters.relaxation;
                    }
                }
                var c = this.defaultContactMaterial;
                if (typeof parameters.stiffness !== "undefined") {
                    c.stiffness = parameters.stiffness;
                    c.frictionStiffness = parameters.stiffness;
                }
                if (typeof parameters.relaxation !== "undefined") {
                    c.relaxation = parameters.relaxation;
                    c.frictionRelaxation = parameters.relaxation;
                }
            };
            World.prototype.setGlobalStiffness = function(stiffness) {
                this.setGlobalEquationParameters({
                    stiffness: stiffness
                });
            };
            World.prototype.setGlobalRelaxation = function(relaxation) {
                this.setGlobalEquationParameters({
                    relaxation: relaxation
                });
            };
        }, {
            "../../package.json": 8,
            "../collision/Broadphase": 10,
            "../collision/NaiveBroadphase": 12,
            "../collision/Narrowphase": 13,
            "../collision/SAPBroadphase": 14,
            "../constraints/Constraint": 15,
            "../constraints/DistanceConstraint": 16,
            "../constraints/GearConstraint": 17,
            "../constraints/LockConstraint": 18,
            "../constraints/PrismaticConstraint": 19,
            "../constraints/RevoluteConstraint": 20,
            "../events/EventEmitter": 27,
            "../material/ContactMaterial": 28,
            "../material/Material": 29,
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../objects/LinearSpring": 33,
            "../objects/RotationalSpring": 34,
            "../shapes/Capsule": 37,
            "../shapes/Circle": 38,
            "../shapes/Convex": 39,
            "../shapes/Line": 41,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../shapes/Rectangle": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 48,
            "../utils/Utils": 50,
            "./IslandManager": 52,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ]
    }, {}, [ 36 ])(36);
});

p2.Body.prototype.parent = null;

p2.Spring.prototype.parent = null;

Phaser.Physics.P2 = function(game, config) {
    this.game = game;
    if (typeof config === "undefined" || !config.hasOwnProperty("gravity") || !config.hasOwnProperty("broadphase")) {
        config = {
            gravity: [ 0, 0 ],
            broadphase: new p2.SAPBroadphase()
        };
    }
    this.config = config;
    this.world = new p2.World(this.config);
    this.frameRate = 1 / 60;
    this.useElapsedTime = false;
    this.paused = false;
    this.materials = [];
    this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);
    this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    };
    this.onBodyAdded = new Phaser.Signal();
    this.onBodyRemoved = new Phaser.Signal();
    this.onSpringAdded = new Phaser.Signal();
    this.onSpringRemoved = new Phaser.Signal();
    this.onConstraintAdded = new Phaser.Signal();
    this.onConstraintRemoved = new Phaser.Signal();
    this.onContactMaterialAdded = new Phaser.Signal();
    this.onContactMaterialRemoved = new Phaser.Signal();
    this.postBroadphaseCallback = null;
    this.callbackContext = null;
    this.onBeginContact = new Phaser.Signal();
    this.onEndContact = new Phaser.Signal();
    if (config.hasOwnProperty("mpx") && config.hasOwnProperty("pxm") && config.hasOwnProperty("mpxi") && config.hasOwnProperty("pxmi")) {
        this.mpx = config.mpx;
        this.mpxi = config.mpxi;
        this.pxm = config.pxm;
        this.pxmi = config.pxmi;
    }
    this.world.on("beginContact", this.beginContactHandler, this);
    this.world.on("endContact", this.endContactHandler, this);
    this.collisionGroups = [];
    this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
    this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
    this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
    this.boundsCollidesWith = [];
    this._toRemove = [];
    this._collisionGroupID = 2;
    this.setBoundsToWorld(true, true, true, true, false);
};

Phaser.Physics.P2.prototype = {
    removeBodyNextStep: function(body) {
        this._toRemove.push(body);
    },
    preUpdate: function() {
        var i = this._toRemove.length;
        while (i--) {
            this.removeBody(this._toRemove[i]);
        }
        this._toRemove.length = 0;
    },
    enable: function(object, debug, children) {
        if (typeof debug === "undefined") {
            debug = false;
        }
        if (typeof children === "undefined") {
            children = true;
        }
        var i = 1;
        if (Array.isArray(object)) {
            i = object.length;
            while (i--) {
                if (object[i] instanceof Phaser.Group) {
                    this.enable(object[i].children, debug, children);
                } else {
                    this.enableBody(object[i], debug);
                    if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                        this.enable(object[i], debug, true);
                    }
                }
            }
        } else {
            if (object instanceof Phaser.Group) {
                this.enable(object.children, debug, children);
            } else {
                this.enableBody(object, debug);
                if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                    this.enable(object.children, debug, true);
                }
            }
        }
    },
    enableBody: function(object, debug) {
        if (object.hasOwnProperty("body") && object.body === null) {
            object.body = new Phaser.Physics.P2.Body(this.game, object, object.x, object.y, 1);
            object.body.debug = debug;
            object.anchor.set(.5);
        }
    },
    setImpactEvents: function(state) {
        if (state) {
            this.world.on("impact", this.impactHandler, this);
        } else {
            this.world.off("impact", this.impactHandler, this);
        }
    },
    setPostBroadphaseCallback: function(callback, context) {
        this.postBroadphaseCallback = callback;
        this.callbackContext = context;
        if (callback !== null) {
            this.world.on("postBroadphase", this.postBroadphaseHandler, this);
        } else {
            this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        }
    },
    postBroadphaseHandler: function(event) {
        var i = event.pairs.length;
        if (this.postBroadphaseCallback && i > 0) {
            while (i -= 2) {
                if (event.pairs[i].parent && event.pairs[i + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, event.pairs[i].parent, event.pairs[i + 1].parent)) {
                    event.pairs.splice(i, 2);
                }
            }
        }
    },
    impactHandler: function(event) {
        if (event.bodyA.parent && event.bodyB.parent) {
            var a = event.bodyA.parent;
            var b = event.bodyB.parent;
            if (a._bodyCallbacks[event.bodyB.id]) {
                a._bodyCallbacks[event.bodyB.id].call(a._bodyCallbackContext[event.bodyB.id], a, b, event.shapeA, event.shapeB);
            }
            if (b._bodyCallbacks[event.bodyA.id]) {
                b._bodyCallbacks[event.bodyA.id].call(b._bodyCallbackContext[event.bodyA.id], b, a, event.shapeB, event.shapeA);
            }
            if (a._groupCallbacks[event.shapeB.collisionGroup]) {
                a._groupCallbacks[event.shapeB.collisionGroup].call(a._groupCallbackContext[event.shapeB.collisionGroup], a, b, event.shapeA, event.shapeB);
            }
            if (b._groupCallbacks[event.shapeA.collisionGroup]) {
                b._groupCallbacks[event.shapeA.collisionGroup].call(b._groupCallbackContext[event.shapeA.collisionGroup], b, a, event.shapeB, event.shapeA);
            }
        }
    },
    beginContactHandler: function(event) {
        this.onBeginContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB, event.contactEquations);
        if (event.bodyA.parent) {
            event.bodyA.parent.onBeginContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB, event.contactEquations);
        }
        if (event.bodyB.parent) {
            event.bodyB.parent.onBeginContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA, event.contactEquations);
        }
    },
    endContactHandler: function(event) {
        this.onEndContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB);
        if (event.bodyA.parent) {
            event.bodyA.parent.onEndContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB);
        }
        if (event.bodyB.parent) {
            event.bodyB.parent.onEndContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA);
        }
    },
    setBoundsToWorld: function(left, right, top, bottom, setCollisionGroup) {
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, setCollisionGroup);
    },
    setWorldMaterial: function(material, left, right, top, bottom) {
        if (typeof left === "undefined") {
            left = true;
        }
        if (typeof right === "undefined") {
            right = true;
        }
        if (typeof top === "undefined") {
            top = true;
        }
        if (typeof bottom === "undefined") {
            bottom = true;
        }
        if (left && this.walls.left) {
            this.walls.left.shapes[0].material = material;
        }
        if (right && this.walls.right) {
            this.walls.right.shapes[0].material = material;
        }
        if (top && this.walls.top) {
            this.walls.top.shapes[0].material = material;
        }
        if (bottom && this.walls.bottom) {
            this.walls.bottom.shapes[0].material = material;
        }
    },
    updateBoundsCollisionGroup: function(setCollisionGroup) {
        var mask = this.everythingCollisionGroup.mask;
        if (typeof setCollisionGroup === "undefined") {
            mask = this.boundsCollisionGroup.mask;
        }
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionGroup = mask;
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionGroup = mask;
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionGroup = mask;
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionGroup = mask;
        }
    },
    setBounds: function(x, y, width, height, left, right, top, bottom, setCollisionGroup) {
        if (typeof left === "undefined") {
            left = true;
        }
        if (typeof right === "undefined") {
            right = true;
        }
        if (typeof top === "undefined") {
            top = true;
        }
        if (typeof bottom === "undefined") {
            bottom = true;
        }
        if (typeof setCollisionGroup === "undefined") {
            setCollisionGroup = true;
        }
        if (this.walls.left) {
            this.world.removeBody(this.walls.left);
        }
        if (this.walls.right) {
            this.world.removeBody(this.walls.right);
        }
        if (this.walls.top) {
            this.world.removeBody(this.walls.top);
        }
        if (this.walls.bottom) {
            this.world.removeBody(this.walls.bottom);
        }
        if (left) {
            this.walls.left = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y) ],
                angle: 1.5707963267948966
            });
            this.walls.left.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.left);
        }
        if (right) {
            this.walls.right = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x + width), this.pxmi(y) ],
                angle: -1.5707963267948966
            });
            this.walls.right.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.right);
        }
        if (top) {
            this.walls.top = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y) ],
                angle: -3.141592653589793
            });
            this.walls.top.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.top);
        }
        if (bottom) {
            this.walls.bottom = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y + height) ]
            });
            this.walls.bottom.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.bottom);
        }
    },
    pause: function() {
        this.paused = true;
    },
    resume: function() {
        this.paused = false;
    },
    update: function() {
        if (this.paused) {
            return;
        }
        if (this.useElapsedTime) {
            this.world.step(this.game.time.physicsElapsed);
        } else {
            this.world.step(this.frameRate);
        }
    },
    clear: function() {
        this.world.clear();
        this.world.off("beginContact", this.beginContactHandler, this);
        this.world.off("endContact", this.endContactHandler, this);
        this.postBroadphaseCallback = null;
        this.callbackContext = null;
        this.impactCallback = null;
        this.collisionGroups = [];
        this._toRemove = [];
        this._collisionGroupID = 2;
        this.boundsCollidesWith = [];
    },
    destroy: function() {
        this.clear();
        this.game = null;
    },
    addBody: function(body) {
        if (body.data.world) {
            return false;
        } else {
            this.world.addBody(body.data);
            this.onBodyAdded.dispatch(body);
            return true;
        }
    },
    removeBody: function(body) {
        if (body.data.world == this.world) {
            this.world.removeBody(body.data);
            this.onBodyRemoved.dispatch(body);
        }
        return body;
    },
    addSpring: function(spring) {
        if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
            this.world.addSpring(spring.data);
        } else {
            this.world.addSpring(spring);
        }
        this.onSpringAdded.dispatch(spring);
        return spring;
    },
    removeSpring: function(spring) {
        if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
            this.world.removeSpring(spring.data);
        } else {
            this.world.removeSpring(spring);
        }
        this.onSpringRemoved.dispatch(spring);
        return spring;
    },
    createDistanceConstraint: function(bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce));
        }
    },
    createGearConstraint: function(bodyA, bodyB, angle, ratio) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, bodyA, bodyB, angle, ratio));
        }
    },
    createRevoluteConstraint: function(bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot));
        }
    },
    createLockConstraint: function(bodyA, bodyB, offset, angle, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, bodyA, bodyB, offset, angle, maxForce));
        }
    },
    createPrismaticConstraint: function(bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce));
        }
    },
    addConstraint: function(constraint) {
        this.world.addConstraint(constraint);
        this.onConstraintAdded.dispatch(constraint);
        return constraint;
    },
    removeConstraint: function(constraint) {
        this.world.removeConstraint(constraint);
        this.onConstraintRemoved.dispatch(constraint);
        return constraint;
    },
    addContactMaterial: function(material) {
        this.world.addContactMaterial(material);
        this.onContactMaterialAdded.dispatch(material);
        return material;
    },
    removeContactMaterial: function(material) {
        this.world.removeContactMaterial(material);
        this.onContactMaterialRemoved.dispatch(material);
        return material;
    },
    getContactMaterial: function(materialA, materialB) {
        return this.world.getContactMaterial(materialA, materialB);
    },
    setMaterial: function(material, bodies) {
        var i = bodies.length;
        while (i--) {
            bodies[i].setMaterial(material);
        }
    },
    createMaterial: function(name, body) {
        name = name || "";
        var material = new Phaser.Physics.P2.Material(name);
        this.materials.push(material);
        if (typeof body !== "undefined") {
            body.setMaterial(material);
        }
        return material;
    },
    createContactMaterial: function(materialA, materialB, options) {
        if (typeof materialA === "undefined") {
            materialA = this.createMaterial();
        }
        if (typeof materialB === "undefined") {
            materialB = this.createMaterial();
        }
        var contact = new Phaser.Physics.P2.ContactMaterial(materialA, materialB, options);
        return this.addContactMaterial(contact);
    },
    getBodies: function() {
        var output = [];
        var i = this.world.bodies.length;
        while (i--) {
            output.push(this.world.bodies[i].parent);
        }
        return output;
    },
    getBody: function(object) {
        if (object instanceof p2.Body) {
            return object;
        } else if (object instanceof Phaser.Physics.P2.Body) {
            return object.data;
        } else if (object["body"] && object["body"].type === Phaser.Physics.P2JS) {
            return object.body.data;
        }
        return null;
    },
    getSprings: function() {
        var output = [];
        var i = this.world.springs.length;
        while (i--) {
            output.push(this.world.springs[i].parent);
        }
        return output;
    },
    getConstraints: function() {
        var output = [];
        var i = this.world.constraints.length;
        while (i--) {
            output.push(this.world.constraints[i].parent);
        }
        return output;
    },
    hitTest: function(worldPoint, bodies, precision, filterStatic) {
        if (typeof bodies === "undefined") {
            bodies = this.world.bodies;
        }
        if (typeof precision === "undefined") {
            precision = 5;
        }
        if (typeof filterStatic === "undefined") {
            filterStatic = false;
        }
        var physicsPosition = [ this.pxmi(worldPoint.x), this.pxmi(worldPoint.y) ];
        var query = [];
        var i = bodies.length;
        while (i--) {
            if (bodies[i] instanceof Phaser.Physics.P2.Body && !(filterStatic && bodies[i].data.type === p2.Body.STATIC)) {
                query.push(bodies[i].data);
            } else if (bodies[i] instanceof p2.Body && bodies[i].parent && !(filterStatic && bodies[i].type === p2.Body.STATIC)) {
                query.push(bodies[i]);
            } else if (bodies[i] instanceof Phaser.Sprite && bodies[i].hasOwnProperty("body") && !(filterStatic && bodies[i].body.data.type === p2.Body.STATIC)) {
                query.push(bodies[i].body.data);
            }
        }
        return this.world.hitTest(physicsPosition, query, precision);
    },
    toJSON: function() {
        return this.world.toJSON();
    },
    createCollisionGroup: function(object) {
        var bitmask = Math.pow(2, this._collisionGroupID);
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | bitmask;
        }
        this._collisionGroupID++;
        var group = new Phaser.Physics.P2.CollisionGroup(bitmask);
        this.collisionGroups.push(group);
        if (object) {
            this.setCollisionGroup(object, group);
        }
        return group;
    },
    setCollisionGroup: function(object, group) {
        if (object instanceof Phaser.Group) {
            for (var i = 0; i < object.total; i++) {
                if (object.children[i]["body"] && object.children[i]["body"].type === Phaser.Physics.P2JS) {
                    object.children[i].body.setCollisionGroup(group);
                }
            }
        } else {
            object.body.setCollisionGroup(group);
        }
    },
    createSpring: function(bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Spring, invalid body objects given");
        } else {
            return this.addSpring(new Phaser.Physics.P2.Spring(this, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB));
        }
    },
    createRotationalSpring: function(bodyA, bodyB, restAngle, stiffness, damping) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Rotational Spring, invalid body objects given");
        } else {
            return this.addSpring(new Phaser.Physics.P2.RotationalSpring(this, bodyA, bodyB, restAngle, stiffness, damping));
        }
    },
    createBody: function(x, y, mass, addToWorld, options, data) {
        if (typeof addToWorld === "undefined") {
            addToWorld = false;
        }
        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
        if (data) {
            var result = body.addPolygon(options, data);
            if (!result) {
                return false;
            }
        }
        if (addToWorld) {
            this.world.addBody(body.data);
        }
        return body;
    },
    createParticle: function(x, y, mass, addToWorld, options, data) {
        if (typeof addToWorld === "undefined") {
            addToWorld = false;
        }
        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
        if (data) {
            var result = body.addPolygon(options, data);
            if (!result) {
                return false;
            }
        }
        if (addToWorld) {
            this.world.addBody(body.data);
        }
        return body;
    },
    convertCollisionObjects: function(map, layer, addToWorld) {
        if (typeof addToWorld === "undefined") {
            addToWorld = true;
        }
        var output = [];
        for (var i = 0, len = map.collision[layer].length; i < len; i++) {
            var object = map.collision[layer][i];
            var body = this.createBody(object.x, object.y, 0, addToWorld, {}, object.polyline);
            if (body) {
                output.push(body);
            }
        }
        return output;
    },
    clearTilemapLayerBodies: function(map, layer) {
        layer = map.getLayer(layer);
        var i = map.layers[layer].bodies.length;
        while (i--) {
            map.layers[layer].bodies[i].destroy();
        }
        map.layers[layer].bodies.length = 0;
    },
    convertTilemap: function(map, layer, addToWorld, optimize) {
        layer = map.getLayer(layer);
        if (typeof addToWorld === "undefined") {
            addToWorld = true;
        }
        if (typeof optimize === "undefined") {
            optimize = true;
        }
        this.clearTilemapLayerBodies(map, layer);
        var width = 0;
        var sx = 0;
        var sy = 0;
        for (var y = 0, h = map.layers[layer].height; y < h; y++) {
            width = 0;
            for (var x = 0, w = map.layers[layer].width; x < w; x++) {
                var tile = map.layers[layer].data[y][x];
                if (tile && tile.index > -1 && tile.collides) {
                    if (optimize) {
                        var right = map.getTileRight(layer, x, y);
                        if (width === 0) {
                            sx = tile.x * tile.width;
                            sy = tile.y * tile.height;
                            width = tile.width;
                        }
                        if (right && right.collides) {
                            width += tile.width;
                        } else {
                            var body = this.createBody(sx, sy, 0, false);
                            body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);
                            if (addToWorld) {
                                this.addBody(body);
                            }
                            map.layers[layer].bodies.push(body);
                            width = 0;
                        }
                    } else {
                        var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);
                        body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);
                        if (addToWorld) {
                            this.addBody(body);
                        }
                        map.layers[layer].bodies.push(body);
                    }
                }
            }
        }
        return map.layers[layer].bodies;
    },
    mpx: function(v) {
        return v *= 20;
    },
    pxm: function(v) {
        return v * .05;
    },
    mpxi: function(v) {
        return v *= -20;
    },
    pxmi: function(v) {
        return v * -.05;
    }
};

Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
    get: function() {
        return this.world.defaultContactMaterial.friction;
    },
    set: function(value) {
        this.world.defaultContactMaterial.friction = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution;
    },
    set: function(value) {
        this.world.defaultContactMaterial.restitution = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
    get: function() {
        return this.world.defaultContactMaterial;
    },
    set: function(value) {
        this.world.defaultContactMaterial = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
    get: function() {
        return this.world.applySpringForces;
    },
    set: function(value) {
        this.world.applySpringForces = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
    get: function() {
        return this.world.applyDamping;
    },
    set: function(value) {
        this.world.applyDamping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
    get: function() {
        return this.world.applyGravity;
    },
    set: function(value) {
        this.world.applyGravity = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
    get: function() {
        return this.world.solveConstraints;
    },
    set: function(value) {
        this.world.solveConstraints = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
    get: function() {
        return this.world.time;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
    get: function() {
        return this.world.emitImpactEvent;
    },
    set: function(value) {
        this.world.emitImpactEvent = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "sleepMode", {
    get: function() {
        return this.world.sleepMode;
    },
    set: function(value) {
        this.world.sleepMode = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
    get: function() {
        return this.world.bodies.length;
    }
});

Phaser.Physics.P2.FixtureList = function(list) {
    if (!Array.isArray(list)) {
        list = [ list ];
    }
    this.rawList = list;
    this.init();
    this.parse(this.rawList);
};

Phaser.Physics.P2.FixtureList.prototype = {
    init: function() {
        this.namedFixtures = {};
        this.groupedFixtures = [];
        this.allFixtures = [];
    },
    setCategory: function(bit, fixtureKey) {
        var setter = function(fixture) {
            fixture.collisionGroup = bit;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setMask: function(bit, fixtureKey) {
        var setter = function(fixture) {
            fixture.collisionMask = bit;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setSensor: function(value, fixtureKey) {
        var setter = function(fixture) {
            fixture.sensor = value;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setMaterial: function(material, fixtureKey) {
        var setter = function(fixture) {
            fixture.material = material;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    getFixtures: function(keys) {
        var fixtures = [];
        if (keys) {
            if (!(keys instanceof Array)) {
                keys = [ keys ];
            }
            var self = this;
            keys.forEach(function(key) {
                if (self.namedFixtures[key]) {
                    fixtures.push(self.namedFixtures[key]);
                }
            });
            return this.flatten(fixtures);
        } else {
            return this.allFixtures;
        }
    },
    getFixtureByKey: function(key) {
        return this.namedFixtures[key];
    },
    getGroup: function(groupID) {
        return this.groupedFixtures[groupID];
    },
    parse: function() {
        var key, value, _ref, _results;
        _ref = this.rawList;
        _results = [];
        for (key in _ref) {
            value = _ref[key];
            if (!isNaN(key - 0)) {
                this.groupedFixtures[key] = this.groupedFixtures[key] || [];
                this.groupedFixtures[key] = this.groupedFixtures[key].concat(value);
            } else {
                this.namedFixtures[key] = this.flatten(value);
            }
            _results.push(this.allFixtures = this.flatten(this.groupedFixtures));
        }
    },
    flatten: function(array) {
        var result, self;
        result = [];
        self = arguments.callee;
        array.forEach(function(item) {
            return Array.prototype.push.apply(result, Array.isArray(item) ? self(item) : [ item ]);
        });
        return result;
    }
};

Phaser.Physics.P2.PointProxy = function(world, destination) {
    this.world = world;
    this.destination = destination;
};

Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
    get: function() {
        return this.world.mpx(this.destination[0]);
    },
    set: function(value) {
        this.destination[0] = this.world.pxm(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
    get: function() {
        return this.world.mpx(this.destination[1]);
    },
    set: function(value) {
        this.destination[1] = this.world.pxm(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "mx", {
    get: function() {
        return this.destination[0];
    },
    set: function(value) {
        this.destination[0] = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "my", {
    get: function() {
        return this.destination[1];
    },
    set: function(value) {
        this.destination[1] = value;
    }
});

Phaser.Physics.P2.InversePointProxy = function(world, destination) {
    this.world = world;
    this.destination = destination;
};

Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.destination[0]);
    },
    set: function(value) {
        this.destination[0] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.destination[1]);
    },
    set: function(value) {
        this.destination[1] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "mx", {
    get: function() {
        return this.destination[0];
    },
    set: function(value) {
        this.destination[0] = -value;
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "my", {
    get: function() {
        return this.destination[1];
    },
    set: function(value) {
        this.destination[1] = -value;
    }
});

Phaser.Physics.P2.Body = function(game, sprite, x, y, mass) {
    sprite = sprite || null;
    x = x || 0;
    y = y || 0;
    if (typeof mass === "undefined") {
        mass = 1;
    }
    this.game = game;
    this.world = game.physics.p2;
    this.sprite = sprite;
    this.type = Phaser.Physics.P2JS;
    this.offset = new Phaser.Point();
    this.data = new p2.Body({
        position: [ this.world.pxmi(x), this.world.pxmi(y) ],
        mass: mass
    });
    this.data.parent = this;
    this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);
    this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);
    this.gravity = new Phaser.Point();
    this.onBeginContact = new Phaser.Signal();
    this.onEndContact = new Phaser.Signal();
    this.collidesWith = [];
    this.removeNextStep = false;
    this.debugBody = null;
    this._collideWorldBounds = true;
    this._bodyCallbacks = {};
    this._bodyCallbackContext = {};
    this._groupCallbacks = {};
    this._groupCallbackContext = {};
    if (sprite) {
        this.setRectangleFromSprite(sprite);
        if (sprite.exists) {
            this.game.physics.p2.addBody(this);
        }
    }
};

Phaser.Physics.P2.Body.prototype = {
    createBodyCallback: function(object, callback, callbackContext) {
        var id = -1;
        if (object["id"]) {
            id = object.id;
        } else if (object["body"]) {
            id = object.body.id;
        }
        if (id > -1) {
            if (callback === null) {
                delete this._bodyCallbacks[id];
                delete this._bodyCallbackContext[id];
            } else {
                this._bodyCallbacks[id] = callback;
                this._bodyCallbackContext[id] = callbackContext;
            }
        }
    },
    createGroupCallback: function(group, callback, callbackContext) {
        if (callback === null) {
            delete this._groupCallbacks[group.mask];
            delete this._groupCallbacksContext[group.mask];
        } else {
            this._groupCallbacks[group.mask] = callback;
            this._groupCallbackContext[group.mask] = callbackContext;
        }
    },
    getCollisionMask: function() {
        var mask = 0;
        if (this._collideWorldBounds) {
            mask = this.game.physics.p2.boundsCollisionGroup.mask;
        }
        for (var i = 0; i < this.collidesWith.length; i++) {
            mask = mask | this.collidesWith[i].mask;
        }
        return mask;
    },
    updateCollisionMask: function(shape) {
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionMask = mask;
        }
    },
    setCollisionGroup: function(group, shape) {
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionGroup = group.mask;
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionGroup = group.mask;
            shape.collisionMask = mask;
        }
    },
    clearCollision: function(clearGroup, clearMask, shape) {
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                if (clearGroup) {
                    this.data.shapes[i].collisionGroup = null;
                }
                if (clearMask) {
                    this.data.shapes[i].collisionMask = null;
                }
            }
        } else {
            if (clearGroup) {
                shape.collisionGroup = null;
            }
            if (clearMask) {
                shape.collisionMask = null;
            }
        }
        if (clearGroup) {
            this.collidesWith.length = 0;
        }
    },
    collides: function(group, callback, callbackContext, shape) {
        if (Array.isArray(group)) {
            for (var i = 0; i < group.length; i++) {
                if (this.collidesWith.indexOf(group[i]) === -1) {
                    this.collidesWith.push(group[i]);
                    if (callback) {
                        this.createGroupCallback(group[i], callback, callbackContext);
                    }
                }
            }
        } else {
            if (this.collidesWith.indexOf(group) === -1) {
                this.collidesWith.push(group);
                if (callback) {
                    this.createGroupCallback(group, callback, callbackContext);
                }
            }
        }
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionMask = mask;
        }
    },
    adjustCenterOfMass: function() {
        this.data.adjustCenterOfMass();
    },
    applyDamping: function(dt) {
        this.data.applyDamping(dt);
    },
    applyForce: function(force, worldX, worldY) {
        this.data.applyForce(force, [ this.world.pxmi(worldX), this.world.pxmi(worldY) ]);
    },
    setZeroForce: function() {
        this.data.setZeroForce();
    },
    setZeroRotation: function() {
        this.data.angularVelocity = 0;
    },
    setZeroVelocity: function() {
        this.data.velocity[0] = 0;
        this.data.velocity[1] = 0;
    },
    setZeroDamping: function() {
        this.data.damping = 0;
        this.data.angularDamping = 0;
    },
    toLocalFrame: function(out, worldPoint) {
        return this.data.toLocalFrame(out, worldPoint);
    },
    toWorldFrame: function(out, localPoint) {
        return this.data.toWorldFrame(out, localPoint);
    },
    rotateLeft: function(speed) {
        this.data.angularVelocity = this.world.pxm(-speed);
    },
    rotateRight: function(speed) {
        this.data.angularVelocity = this.world.pxm(speed);
    },
    moveForward: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = magnitude * Math.cos(angle);
        this.data.velocity[1] = magnitude * Math.sin(angle);
    },
    moveBackward: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = -(magnitude * Math.cos(angle));
        this.data.velocity[1] = -(magnitude * Math.sin(angle));
    },
    thrust: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.force[0] += magnitude * Math.cos(angle);
        this.data.force[1] += magnitude * Math.sin(angle);
    },
    reverse: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.force[0] -= magnitude * Math.cos(angle);
        this.data.force[1] -= magnitude * Math.sin(angle);
    },
    moveLeft: function(speed) {
        this.data.velocity[0] = this.world.pxmi(-speed);
    },
    moveRight: function(speed) {
        this.data.velocity[0] = this.world.pxmi(speed);
    },
    moveUp: function(speed) {
        this.data.velocity[1] = this.world.pxmi(-speed);
    },
    moveDown: function(speed) {
        this.data.velocity[1] = this.world.pxmi(speed);
    },
    preUpdate: function() {
        if (this.removeNextStep) {
            this.removeFromWorld();
            this.removeNextStep = false;
        }
    },
    postUpdate: function() {
        this.sprite.x = this.world.mpxi(this.data.position[0]);
        this.sprite.y = this.world.mpxi(this.data.position[1]);
        if (!this.fixedRotation) {
            this.sprite.rotation = this.data.angle;
        }
    },
    reset: function(x, y, resetDamping, resetMass) {
        if (typeof resetDamping === "undefined") {
            resetDamping = false;
        }
        if (typeof resetMass === "undefined") {
            resetMass = false;
        }
        this.setZeroForce();
        this.setZeroVelocity();
        this.setZeroRotation();
        if (resetDamping) {
            this.setZeroDamping();
        }
        if (resetMass) {
            this.mass = 1;
        }
        this.x = x;
        this.y = y;
    },
    addToWorld: function() {
        if (this.game.physics.p2._toRemove) {
            for (var i = 0; i < this.game.physics.p2._toRemove.length; i++) {
                if (this.game.physics.p2._toRemove[i] === this) {
                    this.game.physics.p2._toRemove.splice(i, 1);
                }
            }
        }
        if (this.data.world !== this.game.physics.p2.world) {
            this.game.physics.p2.addBody(this);
        }
    },
    removeFromWorld: function() {
        if (this.data.world === this.game.physics.p2.world) {
            this.game.physics.p2.removeBodyNextStep(this);
        }
    },
    destroy: function() {
        this.removeFromWorld();
        this.clearShapes();
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        if (this.debugBody) {
            this.debugBody.destroy();
        }
        this.debugBody = null;
        this.sprite.body = null;
        this.sprite = null;
    },
    clearShapes: function() {
        var i = this.data.shapes.length;
        while (i--) {
            this.data.removeShape(this.data.shapes[i]);
        }
        this.shapeChanged();
    },
    addShape: function(shape, offsetX, offsetY, rotation) {
        if (typeof offsetX === "undefined") {
            offsetX = 0;
        }
        if (typeof offsetY === "undefined") {
            offsetY = 0;
        }
        if (typeof rotation === "undefined") {
            rotation = 0;
        }
        this.data.addShape(shape, [ this.world.pxmi(offsetX), this.world.pxmi(offsetY) ], rotation);
        this.shapeChanged();
        return shape;
    },
    addCircle: function(radius, offsetX, offsetY, rotation) {
        var shape = new p2.Circle(this.world.pxm(radius));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addRectangle: function(width, height, offsetX, offsetY, rotation) {
        var shape = new p2.Rectangle(this.world.pxm(width), this.world.pxm(height));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addPlane: function(offsetX, offsetY, rotation) {
        var shape = new p2.Plane();
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addParticle: function(offsetX, offsetY, rotation) {
        var shape = new p2.Particle();
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addLine: function(length, offsetX, offsetY, rotation) {
        var shape = new p2.Line(this.world.pxm(length));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addCapsule: function(length, radius, offsetX, offsetY, rotation) {
        var shape = new p2.Capsule(this.world.pxm(length), this.world.pxm(radius));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addPolygon: function(options, points) {
        options = options || {};
        if (!Array.isArray(points)) {
            points = Array.prototype.slice.call(arguments, 1);
        }
        var path = [];
        if (points.length === 1 && Array.isArray(points[0])) {
            path = points[0].slice(0);
        } else if (Array.isArray(points[0])) {
            path = points.slice();
        } else if (typeof points[0] === "number") {
            for (var i = 0, len = points.length; i < len; i += 2) {
                path.push([ points[i], points[i + 1] ]);
            }
        }
        var idx = path.length - 1;
        if (path[idx][0] === path[0][0] && path[idx][1] === path[0][1]) {
            path.pop();
        }
        for (var p = 0; p < path.length; p++) {
            path[p][0] = this.world.pxmi(path[p][0]);
            path[p][1] = this.world.pxmi(path[p][1]);
        }
        var result = this.data.fromPolygon(path, options);
        this.shapeChanged();
        return result;
    },
    removeShape: function(shape) {
        var result = this.data.removeShape(shape);
        this.shapeChanged();
        return result;
    },
    setCircle: function(radius, offsetX, offsetY, rotation) {
        this.clearShapes();
        return this.addCircle(radius, offsetX, offsetY, rotation);
    },
    setRectangle: function(width, height, offsetX, offsetY, rotation) {
        if (typeof width === "undefined") {
            width = 16;
        }
        if (typeof height === "undefined") {
            height = 16;
        }
        this.clearShapes();
        return this.addRectangle(width, height, offsetX, offsetY, rotation);
    },
    setRectangleFromSprite: function(sprite) {
        if (typeof sprite === "undefined") {
            sprite = this.sprite;
        }
        this.clearShapes();
        return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);
    },
    setMaterial: function(material, shape) {
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].material = material;
            }
        } else {
            shape.material = material;
        }
    },
    shapeChanged: function() {
        if (this.debugBody) {
            this.debugBody.draw();
        }
    },
    addPhaserPolygon: function(key, object) {
        var data = this.game.cache.getPhysicsData(key, object);
        var createdFixtures = [];
        for (var i = 0; i < data.length; i++) {
            var fixtureData = data[i];
            var shapesOfFixture = this.addFixture(fixtureData);
            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group] || [];
            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group].concat(shapesOfFixture);
            if (fixtureData.fixtureKey) {
                createdFixtures[fixtureData.fixtureKey] = shapesOfFixture;
            }
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return createdFixtures;
    },
    addFixture: function(fixtureData) {
        var generatedShapes = [];
        if (fixtureData.circle) {
            var shape = new p2.Circle(this.world.pxm(fixtureData.circle.radius));
            shape.collisionGroup = fixtureData.filter.categoryBits;
            shape.collisionMask = fixtureData.filter.maskBits;
            shape.sensor = fixtureData.isSensor;
            var offset = p2.vec2.create();
            offset[0] = this.world.pxmi(fixtureData.circle.position[0] - this.sprite.width / 2);
            offset[1] = this.world.pxmi(fixtureData.circle.position[1] - this.sprite.height / 2);
            this.data.addShape(shape, offset);
            generatedShapes.push(shape);
        } else {
            var polygons = fixtureData.polygons;
            var cm = p2.vec2.create();
            for (var i = 0; i < polygons.length; i++) {
                var shapes = polygons[i];
                var vertices = [];
                for (var s = 0; s < shapes.length; s += 2) {
                    vertices.push([ this.world.pxmi(shapes[s]), this.world.pxmi(shapes[s + 1]) ]);
                }
                var shape = new p2.Convex(vertices);
                for (var j = 0; j !== shape.vertices.length; j++) {
                    var v = shape.vertices[j];
                    p2.vec2.sub(v, v, shape.centerOfMass);
                }
                p2.vec2.scale(cm, shape.centerOfMass, 1);
                cm[0] -= this.world.pxmi(this.sprite.width / 2);
                cm[1] -= this.world.pxmi(this.sprite.height / 2);
                shape.updateTriangles();
                shape.updateCenterOfMass();
                shape.updateBoundingRadius();
                shape.collisionGroup = fixtureData.filter.categoryBits;
                shape.collisionMask = fixtureData.filter.maskBits;
                shape.sensor = fixtureData.isSensor;
                this.data.addShape(shape, cm);
                generatedShapes.push(shape);
            }
        }
        return generatedShapes;
    },
    loadPolygon: function(key, object) {
        var data = this.game.cache.getPhysicsData(key, object);
        var cm = p2.vec2.create();
        for (var i = 0; i < data.length; i++) {
            var vertices = [];
            for (var s = 0; s < data[i].shape.length; s += 2) {
                vertices.push([ this.world.pxmi(data[i].shape[s]), this.world.pxmi(data[i].shape[s + 1]) ]);
            }
            var c = new p2.Convex(vertices);
            for (var j = 0; j !== c.vertices.length; j++) {
                var v = c.vertices[j];
                p2.vec2.sub(v, v, c.centerOfMass);
            }
            p2.vec2.scale(cm, c.centerOfMass, 1);
            cm[0] -= this.world.pxmi(this.sprite.width / 2);
            cm[1] -= this.world.pxmi(this.sprite.height / 2);
            c.updateTriangles();
            c.updateCenterOfMass();
            c.updateBoundingRadius();
            this.data.addShape(c, cm);
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return true;
    }
};

Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;

Phaser.Physics.P2.Body.DYNAMIC = 1;

Phaser.Physics.P2.Body.STATIC = 2;

Phaser.Physics.P2.Body.KINEMATIC = 4;

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.STATIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.STATIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.STATIC) {
            this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1;
            }
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.DYNAMIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1;
            }
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.KINEMATIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.type = Phaser.Physics.P2.Body.KINEMATIC;
            this.mass = 4;
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
    get: function() {
        return this.data.allowSleep;
    },
    set: function(value) {
        if (value !== this.data.allowSleep) {
            this.data.allowSleep = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle));
    },
    set: function(value) {
        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.angularDamping;
    },
    set: function(value) {
        this.data.angularDamping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
    get: function() {
        return this.data.angularForce;
    },
    set: function(value) {
        this.data.angularForce = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.angularVelocity;
    },
    set: function(value) {
        this.data.angularVelocity = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
    get: function() {
        return this.data.damping;
    },
    set: function(value) {
        this.data.damping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.fixedRotation;
    },
    set: function(value) {
        if (value !== this.data.fixedRotation) {
            this.data.fixedRotation = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
    get: function() {
        return this.data.inertia;
    },
    set: function(value) {
        this.data.inertia = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
    get: function() {
        return this.data.mass;
    },
    set: function(value) {
        if (value !== this.data.mass) {
            this.data.mass = value;
            this.data.updateMassProperties();
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
    get: function() {
        return this.data.type;
    },
    set: function(value) {
        if (value !== this.data.type) {
            this.data.type = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
    get: function() {
        return this.data.angle;
    },
    set: function(value) {
        this.data.angle = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
    get: function() {
        return this.data.sleepSpeedLimit;
    },
    set: function(value) {
        this.data.sleepSpeedLimit = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.data.position[0]);
    },
    set: function(value) {
        this.data.position[0] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.data.position[1]);
    },
    set: function(value) {
        this.data.position[1] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
    get: function() {
        return this.data.id;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
    get: function() {
        return this.debugBody !== null;
    },
    set: function(value) {
        if (value && !this.debugBody) {
            this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data);
        } else if (!value && this.debugBody) {
            this.debugBody.destroy();
            this.debugBody = null;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
    get: function() {
        return this._collideWorldBounds;
    },
    set: function(value) {
        if (value && !this._collideWorldBounds) {
            this._collideWorldBounds = true;
            this.updateCollisionMask();
        } else if (!value && this._collideWorldBounds) {
            this._collideWorldBounds = false;
            this.updateCollisionMask();
        }
    }
});

Phaser.Physics.P2.BodyDebug = function(game, body, settings) {
    Phaser.Group.call(this, game);
    var defaultSettings = {
        pixelsPerLengthUnit: 20,
        debugPolygons: false,
        lineWidth: 1,
        alpha: .5
    };
    this.settings = Phaser.Utils.extend(defaultSettings, settings);
    this.ppu = this.settings.pixelsPerLengthUnit;
    this.ppu = -1 * this.ppu;
    this.body = body;
    this.canvas = new Phaser.Graphics(game);
    this.canvas.alpha = this.settings.alpha;
    this.add(this.canvas);
    this.draw();
};

Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);

Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;

Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
    update: function() {
        this.updateSpriteTransform();
    },
    updateSpriteTransform: function() {
        this.position.x = this.body.position[0] * this.ppu;
        this.position.y = this.body.position[1] * this.ppu;
        return this.rotation = this.body.angle;
    },
    draw: function() {
        var angle, child, color, i, j, lineColor, lw, obj, offset, sprite, v, verts, vrot, _j, _ref1;
        obj = this.body;
        sprite = this.canvas;
        sprite.clear();
        color = parseInt(this.randomPastelHex(), 16);
        lineColor = 16711680;
        lw = this.lineWidth;
        if (obj instanceof p2.Body && obj.shapes.length) {
            var l = obj.shapes.length;
            i = 0;
            while (i !== l) {
                child = obj.shapes[i];
                offset = obj.shapeOffsets[i];
                angle = obj.shapeAngles[i];
                offset = offset || 0;
                angle = angle || 0;
                if (child instanceof p2.Circle) {
                    this.drawCircle(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.radius * this.ppu, color, lw);
                } else if (child instanceof p2.Convex) {
                    verts = [];
                    vrot = p2.vec2.create();
                    for (j = _j = 0, _ref1 = child.vertices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                        v = child.vertices[j];
                        p2.vec2.rotate(vrot, v, angle);
                        verts.push([ (vrot[0] + offset[0]) * this.ppu, -(vrot[1] + offset[1]) * this.ppu ]);
                    }
                    this.drawConvex(sprite, verts, child.triangles, lineColor, color, lw, this.settings.debugPolygons, [ offset[0] * this.ppu, -offset[1] * this.ppu ]);
                } else if (child instanceof p2.Plane) {
                    this.drawPlane(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, color, lineColor, lw * 5, lw * 10, lw * 10, this.ppu * 100, angle);
                } else if (child instanceof p2.Line) {
                    this.drawLine(sprite, child.length * this.ppu, lineColor, lw);
                } else if (child instanceof p2.Rectangle) {
                    this.drawRectangle(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, angle, child.width * this.ppu, child.height * this.ppu, lineColor, color, lw);
                }
                i++;
            }
        }
    },
    drawRectangle: function(g, x, y, angle, w, h, color, fillColor, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth, color, 1);
        g.beginFill(fillColor);
        g.drawRect(x - w / 2, y - h / 2, w, h);
    },
    drawCircle: function(g, x, y, angle, radius, color, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 16777215;
        }
        g.lineStyle(lineWidth, 0, 1);
        g.beginFill(color, 1);
        g.drawCircle(x, y, -radius);
        g.endFill();
        g.moveTo(x, y);
        g.lineTo(x + radius * Math.cos(-angle), y + radius * Math.sin(-angle));
    },
    drawLine: function(g, len, color, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth * 5, color, 1);
        g.moveTo(-len / 2, 0);
        g.lineTo(len / 2, 0);
    },
    drawConvex: function(g, verts, triangles, color, fillColor, lineWidth, debug, offset) {
        var colors, i, v, v0, v1, x, x0, x1, y, y0, y1;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        if (!debug) {
            g.lineStyle(lineWidth, color, 1);
            g.beginFill(fillColor);
            i = 0;
            while (i !== verts.length) {
                v = verts[i];
                x = v[0];
                y = v[1];
                if (i === 0) {
                    g.moveTo(x, -y);
                } else {
                    g.lineTo(x, -y);
                }
                i++;
            }
            g.endFill();
            if (verts.length > 2) {
                g.moveTo(verts[verts.length - 1][0], -verts[verts.length - 1][1]);
                return g.lineTo(verts[0][0], -verts[0][1]);
            }
        } else {
            colors = [ 16711680, 65280, 255 ];
            i = 0;
            while (i !== verts.length + 1) {
                v0 = verts[i % verts.length];
                v1 = verts[(i + 1) % verts.length];
                x0 = v0[0];
                y0 = v0[1];
                x1 = v1[0];
                y1 = v1[1];
                g.lineStyle(lineWidth, colors[i % colors.length], 1);
                g.moveTo(x0, -y0);
                g.lineTo(x1, -y1);
                g.drawCircle(x0, -y0, lineWidth * 2);
                i++;
            }
            g.lineStyle(lineWidth, 0, 1);
            return g.drawCircle(offset[0], offset[1], lineWidth * 2);
        }
    },
    drawPath: function(g, path, color, fillColor, lineWidth) {
        var area, i, lastx, lasty, p1x, p1y, p2x, p2y, p3x, p3y, v, x, y;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth, color, 1);
        if (typeof fillColor === "number") {
            g.beginFill(fillColor);
        }
        lastx = null;
        lasty = null;
        i = 0;
        while (i < path.length) {
            v = path[i];
            x = v[0];
            y = v[1];
            if (x !== lastx || y !== lasty) {
                if (i === 0) {
                    g.moveTo(x, y);
                } else {
                    p1x = lastx;
                    p1y = lasty;
                    p2x = x;
                    p2y = y;
                    p3x = path[(i + 1) % path.length][0];
                    p3y = path[(i + 1) % path.length][1];
                    area = (p2x - p1x) * (p3y - p1y) - (p3x - p1x) * (p2y - p1y);
                    if (area !== 0) {
                        g.lineTo(x, y);
                    }
                }
                lastx = x;
                lasty = y;
            }
            i++;
        }
        if (typeof fillColor === "number") {
            g.endFill();
        }
        if (path.length > 2 && typeof fillColor === "number") {
            g.moveTo(path[path.length - 1][0], path[path.length - 1][1]);
            g.lineTo(path[0][0], path[0][1]);
        }
    },
    drawPlane: function(g, x0, x1, color, lineColor, lineWidth, diagMargin, diagSize, maxLength, angle) {
        var max, xd, yd;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 16777215;
        }
        g.lineStyle(lineWidth, lineColor, 11);
        g.beginFill(color);
        max = maxLength;
        g.moveTo(x0, -x1);
        xd = x0 + Math.cos(angle) * this.game.width;
        yd = x1 + Math.sin(angle) * this.game.height;
        g.lineTo(xd, -yd);
        g.moveTo(x0, -x1);
        xd = x0 + Math.cos(angle) * -this.game.width;
        yd = x1 + Math.sin(angle) * -this.game.height;
        g.lineTo(xd, -yd);
    },
    randomPastelHex: function() {
        var blue, green, mix, red;
        mix = [ 255, 255, 255 ];
        red = Math.floor(Math.random() * 256);
        green = Math.floor(Math.random() * 256);
        blue = Math.floor(Math.random() * 256);
        red = Math.floor((red + 3 * mix[0]) / 4);
        green = Math.floor((green + 3 * mix[1]) / 4);
        blue = Math.floor((blue + 3 * mix[2]) / 4);
        return this.rgbToHex(red, green, blue);
    },
    rgbToHex: function(r, g, b) {
        return this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
    },
    componentToHex: function(c) {
        var hex;
        hex = c.toString(16);
        if (hex.len === 2) {
            return hex;
        } else {
            return hex + "0";
        }
    }
});

Phaser.Physics.P2.Spring = function(world, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
    this.game = world.game;
    this.world = world;
    if (typeof restLength === "undefined") {
        restLength = 1;
    }
    if (typeof stiffness === "undefined") {
        stiffness = 100;
    }
    if (typeof damping === "undefined") {
        damping = 1;
    }
    restLength = world.pxm(restLength);
    var options = {
        restLength: restLength,
        stiffness: stiffness,
        damping: damping
    };
    if (typeof worldA !== "undefined" && worldA !== null) {
        options.worldAnchorA = [ world.pxm(worldA[0]), world.pxm(worldA[1]) ];
    }
    if (typeof worldB !== "undefined" && worldB !== null) {
        options.worldAnchorB = [ world.pxm(worldB[0]), world.pxm(worldB[1]) ];
    }
    if (typeof localA !== "undefined" && localA !== null) {
        options.localAnchorA = [ world.pxm(localA[0]), world.pxm(localA[1]) ];
    }
    if (typeof localB !== "undefined" && localB !== null) {
        options.localAnchorB = [ world.pxm(localB[0]), world.pxm(localB[1]) ];
    }
    this.data = new p2.LinearSpring(bodyA, bodyB, options);
    this.data.parent = this;
};

Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;

Phaser.Physics.P2.RotationalSpring = function(world, bodyA, bodyB, restAngle, stiffness, damping) {
    this.game = world.game;
    this.world = world;
    if (typeof restAngle === "undefined") {
        restAngle = null;
    }
    if (typeof stiffness === "undefined") {
        stiffness = 100;
    }
    if (typeof damping === "undefined") {
        damping = 1;
    }
    if (restAngle) {
        restAngle = world.pxm(restAngle);
    }
    var options = {
        restAngle: restAngle,
        stiffness: stiffness,
        damping: damping
    };
    this.data = new p2.RotationalSpring(bodyA, bodyB, options);
    this.data.parent = this;
};

Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;

Phaser.Physics.P2.Material = function(name) {
    this.name = name;
    p2.Material.call(this);
};

Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);

Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;

Phaser.Physics.P2.ContactMaterial = function(materialA, materialB, options) {
    p2.ContactMaterial.call(this, materialA, materialB, options);
};

Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);

Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;

Phaser.Physics.P2.CollisionGroup = function(bitmask) {
    this.mask = bitmask;
};

Phaser.Physics.P2.DistanceConstraint = function(world, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
    if (typeof distance === "undefined") {
        distance = 100;
    }
    if (typeof localAnchorA === "undefined") {
        localAnchorA = [ 0, 0 ];
    }
    if (typeof localAnchorB === "undefined") {
        localAnchorB = [ 0, 0 ];
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    distance = world.pxm(distance);
    localAnchorA = [ world.pxmi(localAnchorA[0]), world.pxmi(localAnchorA[1]) ];
    localAnchorB = [ world.pxmi(localAnchorB[0]), world.pxmi(localAnchorB[1]) ];
    var options = {
        distance: distance,
        localAnchorA: localAnchorA,
        localAnchorB: localAnchorB,
        maxForce: maxForce
    };
    p2.DistanceConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);

Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;

Phaser.Physics.P2.GearConstraint = function(world, bodyA, bodyB, angle, ratio) {
    if (typeof angle === "undefined") {
        angle = 0;
    }
    if (typeof ratio === "undefined") {
        ratio = 1;
    }
    this.game = world.game;
    this.world = world;
    var options = {
        angle: angle,
        ratio: ratio
    };
    p2.GearConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);

Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;

Phaser.Physics.P2.LockConstraint = function(world, bodyA, bodyB, offset, angle, maxForce) {
    if (typeof offset === "undefined") {
        offset = [ 0, 0 ];
    }
    if (typeof angle === "undefined") {
        angle = 0;
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    offset = [ world.pxm(offset[0]), world.pxm(offset[1]) ];
    var options = {
        localOffsetB: offset,
        localAngleB: angle,
        maxForce: maxForce
    };
    p2.LockConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);

Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;

Phaser.Physics.P2.PrismaticConstraint = function(world, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
    if (typeof lockRotation === "undefined") {
        lockRotation = true;
    }
    if (typeof anchorA === "undefined") {
        anchorA = [ 0, 0 ];
    }
    if (typeof anchorB === "undefined") {
        anchorB = [ 0, 0 ];
    }
    if (typeof axis === "undefined") {
        axis = [ 0, 0 ];
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    anchorA = [ world.pxmi(anchorA[0]), world.pxmi(anchorA[1]) ];
    anchorB = [ world.pxmi(anchorB[0]), world.pxmi(anchorB[1]) ];
    var options = {
        localAnchorA: anchorA,
        localAnchorB: anchorB,
        localAxisA: axis,
        maxForce: maxForce,
        disableRotationalLock: !lockRotation
    };
    p2.PrismaticConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);

Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;

Phaser.Physics.P2.RevoluteConstraint = function(world, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    if (typeof worldPivot === "undefined") {
        worldPivot = null;
    }
    this.game = world.game;
    this.world = world;
    pivotA = [ world.pxmi(pivotA[0]), world.pxmi(pivotA[1]) ];
    pivotB = [ world.pxmi(pivotB[0]), world.pxmi(pivotB[1]) ];
    if (worldPivot) {
        worldPivot = [ world.pxmi(worldPivot[0]), world.pxmi(worldPivot[1]) ];
    }
    var options = {
        worldPivot: worldPivot,
        localPivotA: pivotA,
        localPivotB: pivotB,
        maxForce: maxForce
    };
    p2.RevoluteConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);

Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint;

(function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
            var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, message, i;
            message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), arg;
                if (index + 2 < templateArgs.length) {
                    return toDebugString(templateArgs[index + 2]);
                }
                return match;
            });
            message = message + "\nhttp://errors.angularjs.org/1.3.8/" + (module ? module + "/" : "") + code;
            for (i = 2; i < arguments.length; i++) {
                message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
            return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        for (var i = 1, ii = arguments.length; i < ii; i++) {
            var obj = arguments[i];
            if (obj) {
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    dst[key] = obj[key];
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = Array.isArray;
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) array.splice(index, 1);
        return value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isObject(source)) {
                    var emptyObject = Object.create(Object.getPrototypeOf(source));
                    destination = copy(source, emptyObject, stackSource, stackDest);
                }
            }
        } else {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [];
            stackDest = stackDest || [];
            if (isObject(source)) {
                var index = stackSource.indexOf(source);
                if (index !== -1) return stackDest[index];
                stackSource.push(source);
                stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest);
                    if (isObject(source[i])) {
                        stackSource.push(source[i]);
                        stackDest.push(result);
                    }
                    destination.push(result);
                }
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function(value, key) {
                        delete destination[key];
                    });
                }
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result = copy(source[key], null, stackSource, stackDest);
                        if (isObject(source[key])) {
                            stackSource.push(source[key]);
                            stackDest.push(result);
                        }
                        destination[key] = result;
                    }
                }
                setHashKey(destination, h);
            }
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return equals(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1) && isRegExp(o2)) {
                    return o1.toString() == o2.toString();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
                    keySet = {};
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
        if (!active) {
            try {
                new Function("");
            } catch (e) {
                active = true;
            }
        }
        return csp.isActive_ = active;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (typeof obj === "undefined") return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=");
                key = tryDecodeURIComponent(key_value[0]);
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        element = jqLite(element);
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.attr(attr))) {
                return attr;
            }
        }
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            doBootstrap();
        };
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    var skipDestroyOnNextJQueryCleanData;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        jQuery = window.jQuery;
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            originalCleanData = jQuery.cleanData;
            jQuery.cleanData = function(elems) {
                var events;
                if (!skipDestroyOnNextJQueryCleanData) {
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, "events");
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler("$destroy");
                        }
                    }
                } else {
                    skipDestroyOnNextJQueryCleanData = false;
                }
                originalCleanData(elems);
            };
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [ node ];
        do {
            node = node.nextSibling;
            if (!node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (typeof obj === "undefined") {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj);
        }
        return obj;
    }
    var version = {
        full: "1.3.8",
        major: 1,
        minor: 3,
        dot: 8,
        codeName: "prophetic-narwhal"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider,
                $$jqLite: $$jqLiteProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, false);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants) jqLiteRemoveData(element);
        if (element.querySelectorAll) {
            var descendants = element.querySelectorAll("*");
            for (var i = 0, l = descendants.length; i < l; i++) {
                jqLiteRemoveData(descendants[i]);
            }
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    removeEventListenerFn(element, type, handle);
                }
                delete events[type];
            }
        } else {
            forEach(type.split(" "), function(type) {
                if (isDefined(fn)) {
                    var listenerFns = events[type];
                    arrayRemove(listenerFns || [], fn);
                    if (listenerFns && listenerFns.length > 0) {
                        return;
                    }
                }
                removeEventListenerFn(element, type, handle);
                delete events[type];
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
                return;
            }
            if (expandoStore.handle) {
                if (expandoStore.events.$destroy) {
                    expandoStore.handle({}, "$destroy");
                }
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[key] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[key];
                    } else {
                        extend(data, key);
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (document.readyState === "complete") {
                setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === "INPUT" || nodeName === "TEXTAREA") && ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    eventFns[i].call(element, event);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            while (i--) {
                type = types[i];
                var eventFns = events[type];
                if (!eventFns) {
                    events[type] = [];
                    if (type === "mouseenter" || type === "mouseleave") {
                        jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            if (!related || related !== target && !target.contains(related)) {
                                handle(event, type);
                            }
                        });
                    } else {
                        if (type !== "$destroy") {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns = events[type];
                }
                eventFns.push(fn);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) children.push(element);
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType == "function" || objType == "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    fnText = fn.toString().replace(STRIP_COMMENTS, "");
                    argDecl = fnText.match(FN_ARGS);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName, caller);
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = [], $inject = annotate(fn, strictDi, serviceName), length, i, key;
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                if (isArray(fn)) {
                    fn = fn[length];
                }
                return fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype);
                var returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll() {
                var hash = $location.hash(), elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {};
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            var currentDefer;
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function ngAnimatePostDigest() {
                    cancelFn = fn(function ngAnimateNotifyComplete() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function resolveElementClasses(element, classes) {
                var toAdd = [], toRemove = [];
                var hasClasses = createMap();
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    if (status === false && hasClass) {
                        toRemove.push(className);
                    } else if (status === true && !hasClass) {
                        toAdd.push(className);
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.length ? toAdd : null, toRemove.length ? toRemove : null ];
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    var className = classes[i];
                    cache[className] = op;
                }
            }
            function asyncPromise() {
                if (!currentDefer) {
                    currentDefer = $$q.defer();
                    $$asyncCallback(function() {
                        currentDefer.resolve();
                        currentDefer = null;
                    });
                }
                return currentDefer.promise;
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles);
                }
            }
            return {
                animate: function(element, from, to) {
                    applyStyles(element, {
                        from: from,
                        to: to
                    });
                    return asyncPromise();
                },
                enter: function(element, parent, after, options) {
                    applyStyles(element, options);
                    after ? after.after(element) : parent.prepend(element);
                    return asyncPromise();
                },
                leave: function(element, options) {
                    element.remove();
                    return asyncPromise();
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options);
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                $$addClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                $$removeClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                setClass: function(element, add, remove, options) {
                    var self = this;
                    var STORAGE_KEY = "$$animateClasses";
                    var createdCache = false;
                    element = jqLite(element);
                    var cache = element.data(STORAGE_KEY);
                    if (!cache) {
                        cache = {
                            classes: {},
                            options: options
                        };
                        createdCache = true;
                    } else if (options && cache.options) {
                        cache.options = angular.extend(cache.options || {}, options);
                    }
                    var classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    remove = isArray(remove) ? remove : remove.split(" ");
                    cachedClassManipulation(classes, add, true);
                    cachedClassManipulation(classes, remove, false);
                    if (createdCache) {
                        cache.promise = runAnimationPostDigest(function(done) {
                            var cache = element.data(STORAGE_KEY);
                            element.removeData(STORAGE_KEY);
                            if (cache) {
                                var classes = resolveElementClasses(element, cache.classes);
                                if (classes) {
                                    self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
                                }
                            }
                            done();
                        });
                        element.data(STORAGE_KEY, cache);
                    }
                    return cache.promise;
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    add && this.$$addClassImmediately(element, add);
                    remove && this.$$removeClassImmediately(element, remove);
                    applyStyles(element, options);
                    return asyncPromise();
                },
                enabled: noop,
                cancel: noop
            };
        } ];
    } ];
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, false);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index + 1);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            });
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var pollFns = [], pollTimeout;
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                });
                pollTimeout = setTimeout(check, interval);
            })();
        }
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                    lastHistoryState = cachedState;
                } else {
                    if (!sameBase) {
                        reloadLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                }
                return self;
            } else {
                return reloadLocation || location.href.replace(/%27/g, "'");
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            cacheState();
            fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = window.history.state;
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
        }
        function fireUrlChange() {
            if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {};
        var lastCookieString = "";
        var cookiePath = self.baseHref();
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
            var bindings = {};
            forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
            });
            return bindings;
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = directive.require || directive.controller && directive.name;
                                directive.restrict = directive.restrict || "EA";
                                if (isObject(directive.scope)) {
                                    directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name);
                                }
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "a" && key === "href" || nodeName === "img" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    } else if (nodeName === "img" && key === "srcset") {
                        var result = "";
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += " " + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            this.$$element.attr(attrName, value);
                        }
                    }
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                forEach($compileNodes, function(node, index) {
                    if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0];
                    }
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope");
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && node.toString().match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = trim(attr.value);
                        ngAttrName = directiveNormalize(name);
                        if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                            name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        if (directiveIsMultiElement(directiveNName)) {
                            if (ngAttrName === directiveNName + "Start") {
                                attrStartName = name;
                                attrEndName = name.substr(0, name.length - 5) + "end";
                                name = name.substr(0, name.length - 6);
                            }
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    className = node.className;
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            nName = directiveNormalize(match[1]);
                            if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[2]);
                            }
                        }
                    } catch (e) {}
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType == NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, controllers, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    if (directiveValue = directive.scope) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller;
                        controllerDirectives = controllerDirectives || {};
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            $compileNode.empty();
                            childTranscludeFn = compile($template, transcludeFn);
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = false;
                    var $searchElement = $element;
                    var match;
                    if (isString(require)) {
                        match = require.match(REQUIRE_PREFIX_REGEXP);
                        require = require.substring(match[0].length);
                        if (match[3]) {
                            if (match[1]) match[3] = null; else match[1] = match[3];
                        }
                        if (match[1] === "^") {
                            retrievalMethod = "inheritedData";
                        } else if (match[1] === "^^") {
                            retrievalMethod = "inheritedData";
                            $searchElement = $element.parent();
                        }
                        if (match[2] === "?") {
                            optional = true;
                        }
                        value = null;
                        if (elementControllers && retrievalMethod === "data") {
                            if (value = elementControllers[require]) {
                                value = value.instance;
                            }
                        }
                        value = value || $searchElement[retrievalMethod]("$" + require + "Controller");
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        }
                        return value || null;
                    } else if (isArray(require)) {
                        value = [];
                        forEach(require, function(require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers));
                        });
                    }
                    return value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                    }
                    if (controllerDirectives) {
                        controllers = {};
                        elementControllers = {};
                        forEach(controllerDirectives, function(directive) {
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controllerInstance;
                            controller = directive.controller;
                            if (controller == "@") {
                                controller = attrs[directive.name];
                            }
                            controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            if (!hasElementTranscludeDirective) {
                                $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                            }
                            controllers[directive.name] = controllerInstance;
                        });
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name];
                        var isolateBindingContext = isolateScope;
                        if (isolateScopeController && isolateScopeController.identifier && newIsolateScopeDirective.bindToController === true) {
                            isolateBindingContext = isolateScopeController.instance;
                        }
                        forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                            switch (mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateBindingContext[scopeName] = value;
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                if (attrs[attrName]) {
                                    isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope);
                                }
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) {
                                    return;
                                }
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function(a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function() {
                                    lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                    throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                };
                                lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, isolateBindingContext[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            isolateBindingContext[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = isolateBindingContext[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = true;
                                var unwatch;
                                if (definition.collection) {
                                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                isolateScope.$on("$destroy", unwatch);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]);
                                isolateBindingContext[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                    }
                    if (controllers) {
                        forEach(controllers, function(controller) {
                            controller();
                        });
                        controllers = null;
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                }
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: true
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i];
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    });
                                }
                                tDirectives.push(directive);
                                match = directive;
                            }
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (key == "class") {
                        safeAddClass($element, value);
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value);
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value;
                        dstAttr[key] = srcAttr[key];
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName == "xlinkHref" || tag == "form" && attrNormalizedName == "action" || tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {});
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove);
                jqLite(newNode).data(jqLite(firstElementToRemove).data());
                if (!jQuery) {
                    delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                } else {
                    skipDestroyOnNextJQueryCleanData = true;
                    jQuery.cleanData([ firstElementToRemove ]);
                }
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove();
                    fragment.appendChild(element);
                    delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
        } ];
    }
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT) {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    function $ControllerProvider() {
        var controllers = {}, globals = false, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.allowGlobals = function() {
            globals = true;
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG), constructor = match[1], identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function() {
                        $injector.invoke(expression, instance, locals, constructor);
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                    data = fromJson(tempData);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), key, val, i;
        if (!headers) return parsed;
        forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":");
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        });
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === void 0) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) return fns(data, headers, status);
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!angular.isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                };
                var chain = [ serverRequest, undefined ];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError);
                    }
                });
                while (chain.length) {
                    var thenFn = chain.shift();
                    var rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                promise.success = function(fn) {
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                promise.error = function(fn) {
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                return promise;
                function transformResponse(response) {
                    var resp = extend({}, response);
                    if (!response.data) {
                        resp.data = response.data;
                    } else {
                        resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    }
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn();
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders);
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0);
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (!isArray(value)) value = [ value ];
                    forEach(value, function(v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString();
                            } else {
                                v = toJson(v);
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
                }
                return url;
            }
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                    callbacks[callbackId].called = true;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text);
                    callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                xhr.onerror = requestError;
                xhr.onabort = requestError;
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(post || null);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                if (timeoutId !== undefined) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    };
                    var getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    var stringify = function(value) {
                        if (value == null) {
                            return "";
                        }
                        switch (typeof value) {
                          case "string":
                            break;

                          case "number":
                            value = "" + value;
                            break;

                          default:
                            value = toJson(value);
                        }
                        return value;
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            }, objectEquality);
                        }
                    });
                }
                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.then(null, null, fn);
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    if (num === 1) {
                        return "one";
                    }
                    return "other";
                }
            };
        };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = relativeUrl.charAt(0) !== "/";
        if (prefixed) {
            relativeUrl = "/" + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index == -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl;
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            var withoutHashUrl;
            if (withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                withoutHashUrl = this.$$html5 ? withoutBaseUrl : "";
            }
            parseAppUrl(withoutHashUrl, this);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) == stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase == stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) == "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) return this[property];
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            $location = new LocationMode(appBase, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.which == 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() != $browser.url()) {
                            $rootScope.$apply();
                            $window.angular["ff-684208-preventDefault"] = true;
                        }
                    }
                }
            });
            if ($location.absUrl() != initialUrl) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl) return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.window === obj) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var CONSTANTS = createMap();
    forEach({
        "null": function() {
            return null;
        },
        "true": function() {
            return true;
        },
        "false": function() {
            return false;
        },
        undefined: function() {}
    }, function(constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;
        CONSTANTS[name] = constantGetter;
    });
    CONSTANTS["this"] = function(self) {
        return self;
    };
    CONSTANTS["this"].sharedGetter = true;
    var OPERATORS = extend(createMap(), {
        "+": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b;
                }
                return a;
            }
            return isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            a = a(self, locals);
            b = b(self, locals);
            return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        },
        "=": true,
        "|": true
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    };
    var Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdent(ch)) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "" || ch === " ";
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch == "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (!(this.isIdent(ch) || this.isNumber(ch))) {
                    break;
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    function isConstant(exp) {
        return exp.constant;
    }
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        sharedGetter: true,
        constant: true
    });
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.statements();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            value.literal = !!value.literal;
            value.constant = !!value.constant;
            return value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.peek().identifier && this.peek().text in CONSTANTS) {
                primary = CONSTANTS[this.consume().text];
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next, context;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = this.functionCall(primary, context);
                    context = null;
                } else if (next.text === "[") {
                    context = primary;
                    primary = this.objectIndex(primary);
                } else if (next.text === ".") {
                    context = primary;
                    primary = this.fieldAccess(primary);
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (this.tokens.length === 0) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        unaryFn: function(op, right) {
            var fn = OPERATORS[op];
            return extend(function $parseUnaryFn(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant,
                inputs: [ right ]
            });
        },
        binaryFn: function(left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function $parseBinaryFn(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant,
                inputs: !isBranching && [ left, right ]
            });
        },
        identifier: function() {
            var id = this.consume().text;
            while (this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "(")) {
                id += this.consume().text + this.consume().text;
            }
            return getterFn(id, this.options, this.text);
        },
        constant: function() {
            var value = this.consume().value;
            return extend(function $parseConstant() {
                return value;
            }, {
                constant: true,
                literal: true
            });
        },
        statements: function() {
            var statements = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain());
                if (!this.expect(";")) {
                    return statements.length === 1 ? statements[0] : function $parseStatements(self, locals) {
                        var value;
                        for (var i = 0, ii = statements.length; i < ii; i++) {
                            value = statements[i](self, locals);
                        }
                        return value;
                    };
                }
            }
        },
        filterChain: function() {
            var left = this.expression();
            var token;
            while (token = this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        filter: function(inputFn) {
            var fn = this.$filter(this.consume().text);
            var argsFn;
            var args;
            if (this.peek(":")) {
                argsFn = [];
                args = [];
                while (this.expect(":")) {
                    argsFn.push(this.expression());
                }
            }
            var inputs = [ inputFn ].concat(argsFn || []);
            return extend(function $parseFilter(self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    var i = argsFn.length;
                    while (i--) {
                        args[i + 1] = argsFn[i](self, locals);
                    }
                    return fn.apply(undefined, args);
                }
                return fn(input);
            }, {
                constant: !fn.$stateful && inputs.every(isConstant),
                inputs: !fn.$stateful && inputs
            });
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var left = this.ternary();
            var right;
            var token;
            if (token = this.expect("=")) {
                if (!left.assign) {
                    this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = this.ternary();
                return extend(function $parseAssignment(scope, locals) {
                    return left.assign(scope, right(scope, locals), locals);
                }, {
                    inputs: [ left, right ]
                });
            }
            return left;
        },
        ternary: function() {
            var left = this.logicalOR();
            var middle;
            var token;
            if (token = this.expect("?")) {
                middle = this.assignment();
                if (this.consume(":")) {
                    var right = this.assignment();
                    return extend(function $parseTernary(self, locals) {
                        return left(self, locals) ? middle(self, locals) : right(self, locals);
                    }, {
                        constant: left.constant && middle.constant && right.constant
                    });
                }
            }
            return left;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            var token;
            while (token = this.expect("||")) {
                left = this.binaryFn(left, token.text, this.logicalAND(), true);
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            var token;
            while (token = this.expect("&&")) {
                left = this.binaryFn(left, token.text, this.equality(), true);
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = this.binaryFn(left, token.text, this.relational());
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = this.binaryFn(left, token.text, this.additive());
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = this.binaryFn(left, token.text, this.multiplicative());
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = this.binaryFn(left, token.text, this.unary());
            }
            return left;
        },
        unary: function() {
            var token;
            if (this.expect("+")) {
                return this.primary();
            } else if (token = this.expect("-")) {
                return this.binaryFn(Parser.ZERO, token.text, this.unary());
            } else if (token = this.expect("!")) {
                return this.unaryFn(token.text, this.unary());
            } else {
                return this.primary();
            }
        },
        fieldAccess: function(object) {
            var getter = this.identifier();
            return extend(function $parseFieldAccess(scope, locals, self) {
                var o = self || object(scope, locals);
                return o == null ? undefined : getter(o);
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    if (!o) object.assign(scope, o = {});
                    return getter.assign(o, value);
                }
            });
        },
        objectIndex: function(obj) {
            var expression = this.text;
            var indexFn = this.expression();
            this.consume("]");
            return extend(function $parseObjectIndex(self, locals) {
                var o = obj(self, locals), i = indexFn(self, locals), v;
                ensureSafeMemberName(i, expression);
                if (!o) return undefined;
                v = ensureSafeObject(o[i], expression);
                return v;
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), expression);
                    var o = ensureSafeObject(obj(self, locals), expression);
                    if (!o) obj.assign(self, o = {});
                    return o[key] = value;
                }
            });
        },
        functionCall: function(fnGetter, contextGetter) {
            var argsFn = [];
            if (this.peekToken().text !== ")") {
                do {
                    argsFn.push(this.expression());
                } while (this.expect(","));
            }
            this.consume(")");
            var expressionText = this.text;
            var args = argsFn.length ? [] : null;
            return function $parseFunctionCall(scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : isDefined(contextGetter) ? undefined : scope;
                var fn = fnGetter(scope, locals, context) || noop;
                if (args) {
                    var i = argsFn.length;
                    while (i--) {
                        args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                    }
                }
                ensureSafeObject(context, expressionText);
                ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, expressionText);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elementFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return extend(function $parseArrayLiteral(self, locals) {
                var array = [];
                for (var i = 0, ii = elementFns.length; i < ii; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            }, {
                literal: true,
                constant: elementFns.every(isConstant),
                inputs: elementFns
            });
        },
        object: function() {
            var keys = [], valueFns = [];
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    var token = this.consume();
                    if (token.constant) {
                        keys.push(token.value);
                    } else if (token.identifier) {
                        keys.push(token.text);
                    } else {
                        this.throwError("invalid key", token);
                    }
                    this.consume(":");
                    valueFns.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("}");
            return extend(function $parseObjectLiteral(self, locals) {
                var object = {};
                for (var i = 0, ii = valueFns.length; i < ii; i++) {
                    object[keys[i]] = valueFns[i](self, locals);
                }
                return object;
            }, {
                literal: true,
                constant: valueFns.every(isConstant),
                inputs: valueFns
            });
        }
    };
    function setter(obj, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        var element = path.split("."), key;
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = ensureSafeObject(obj[key], fullExp);
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = propertyObj;
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
    }
    var getterFnCacheDefault = createMap();
    var getterFnCacheExpensive = createMap();
    function isPossiblyDangerousMemberName(name) {
        return name == "constructor";
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp);
        ensureSafeMemberName(key1, fullExp);
        ensureSafeMemberName(key2, fullExp);
        ensureSafeMemberName(key3, fullExp);
        ensureSafeMemberName(key4, fullExp);
        var eso = function(o) {
            return ensureSafeObject(o, fullExp);
        };
        var eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity;
        var eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity;
        var eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity;
        var eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity;
        var eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function cspSafeGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            if (pathVal == null) return pathVal;
            pathVal = eso0(pathVal[key0]);
            if (!key1) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso1(pathVal[key1]);
            if (!key2) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso2(pathVal[key2]);
            if (!key3) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso3(pathVal[key3]);
            if (!key4) return pathVal;
            if (pathVal == null) return undefined;
            pathVal = eso4(pathVal[key4]);
            return pathVal;
        };
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function(s, l) {
            return fn(s, l, ensureSafeObject, fullExpression);
        };
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks;
        var getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault;
        var fn = getterFnCache[path];
        if (fn) return fn;
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) {
            if (pathKeysLength < 6) {
                fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
            } else {
                fn = function cspSafeGetter(scope, locals) {
                    var i = 0, val;
                    do {
                        val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals);
                        locals = undefined;
                        scope = val;
                    } while (i < pathKeysLength);
                    return val;
                };
            }
        } else {
            var code = "";
            if (expensiveChecks) {
                code += "s = eso(s, fe);\nl = eso(l, fe);\n";
            }
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
                    lookupJs = "eso(" + lookupJs + ", fe)";
                    needsEnsureSafeObject = true;
                }
                code += "if(s == null) return undefined;\n" + "s=" + lookupJs + ";\n";
            });
            code += "return s;";
            var evaledFnGetter = new Function("s", "l", "eso", "fe", code);
            evaledFnGetter.toString = valueFn(code);
            if (needsEnsureSafeObject) {
                evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
            }
            fn = evaledFnGetter;
        }
        fn.sharedGetter = true;
        fn.assign = function(self, value) {
            return setter(self, path, value, path);
        };
        getterFnCache[path] = fn;
        return fn;
    }
    var objectValueOf = Object.prototype.valueOf;
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: false
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: true
            };
            function wrapSharedExpression(exp) {
                var wrapped = exp;
                if (exp.sharedGetter) {
                    wrapped = function $parseWrapper(self, locals) {
                        return exp(self, locals);
                    };
                    wrapped.literal = exp.literal;
                    wrapped.constant = exp.constant;
                    wrapped.assign = exp.assign;
                }
                return wrapped;
            }
            return function $parse(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    cacheKey = exp = exp.trim();
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                        var lexer = new Lexer(parseOptions);
                        var parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression = wrapSharedExpression(parsedExpression);
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            };
            function collectExpressionInputs(inputs, list) {
                for (var i = 0, ii = inputs.length; i < ii; i++) {
                    var input = inputs[i];
                    if (!input.constant) {
                        if (input.inputs) {
                            collectExpressionInputs(input.inputs, list);
                        } else if (list.indexOf(input) === -1) {
                            list.push(input);
                        }
                    }
                }
                return list;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object") {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValue = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {
                            lastResult = parsedExpression(scope);
                            oldInputValue = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality);
                }
                var oldInputValueOfValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope);
                    }
                    return lastResult;
                }, listener, objectEquality);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.call(this, value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isAllDefined(lastValue)) unwatch();
                        });
                    }
                }, objectEquality);
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function(val) {
                        if (!isDefined(val)) allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function constantWatch(scope) {
                    return parsedExpression(scope);
                }, function constantListener(value, old, scope) {
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    fn.inputs = [ parsedExpression ];
                }
                return fn;
            }
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr("$q", TypeError);
        function callOnce(self, resolveFn, rejectFn) {
            var called = false;
            function wrap(fn) {
                return function(value) {
                    if (called) return;
                    called = true;
                    fn.call(self, value);
                };
            }
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        var defer = function() {
            return new Deferred();
        };
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, true, callback);
                }, function(error) {
                    return handleCallback(error, false, callback);
                }, progressBack);
            }
        };
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                promise = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        promise.resolve(fn(state.value));
                    } else if (state.status === 1) {
                        promise.resolve(state.value);
                    } else {
                        promise.reject(state.value);
                    }
                } catch (e) {
                    promise.reject(e);
                    exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            nextTick(function() {
                processQueue(state);
            });
        }
        function Deferred() {
            this.promise = new Promise();
            this.resolve = simpleBind(this, this.resolve);
            this.reject = simpleBind(this, this.reject);
            this.notify = simpleBind(this, this.notify);
        }
        Deferred.prototype = {
            resolve: function(val) {
                if (this.promise.$$state.status) return;
                if (val === this.promise) {
                    this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    this.$$resolve(val);
                }
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    if (isObject(val) || isFunction(val)) then = val && val.then;
                    if (isFunction(then)) {
                        this.promise.$$state.status = -1;
                        then.call(val, fns[0], fns[1], this.notify);
                    } else {
                        this.promise.$$state.value = val;
                        this.promise.$$state.status = 1;
                        scheduleProcessQueue(this.promise.$$state);
                    }
                } catch (e) {
                    fns[1](e);
                    exceptionHandler(e);
                }
            },
            reject: function(reason) {
                if (this.promise.$$state.status) return;
                this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason;
                this.promise.$$state.status = 2;
                scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function() {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            result.reject(reason);
            return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
            var result = new Deferred();
            if (resolved) {
                result.resolve(value);
            } else {
                result.reject(value);
            }
            return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return makePromise(e, false);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return makePromise(value, isResolved);
                }, function(error) {
                    return makePromise(error, false);
                });
            } else {
                return makePromise(value, isResolved);
            }
        };
        var when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            result.resolve(value);
            return result.promise.then(callback, errback, progressBack);
        };
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        var $Q = function Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            if (!(this instanceof Q)) {
                return new Q(resolver);
            }
            var deferred = new Deferred();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.all = all;
        return $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = function ChildScope() {
                                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                                this.$$listeners = {};
                                this.$$listenerCount = {};
                                this.$id = nextUid();
                                this.$$ChildScope = null;
                            };
                            this.$$ChildScope.prototype = this;
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent != this) child.$on("$destroy", destroyChild);
                    return child;
                    function destroyChild() {
                        child.$$destroyed = true;
                    }
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                    }
                    array.unshift(watcher);
                    return function deregisterWatch() {
                        arrayRemove(array, watcher);
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!newValue.hasOwnProperty(key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift();
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length;
                                while (length--) {
                                    try {
                                        watch = watchers[length];
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                watch.fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) return;
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        return this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                normalizedVal = urlResolve(uri).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(document.body.style.webkitTransition);
                    animations = isString(document.body.style.webkitAnimation);
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie <= 11) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", function($templateCache, $http, $q) {
            function handleRequestFn(tpl, ignoreRequestError) {
                var self = handleRequestFn;
                self.totalPendingRequests++;
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions).then(function(response) {
                    self.totalPendingRequests--;
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    self.totalPendingRequests--;
                    if (!ignoreRequestError) {
                        throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) != -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                var skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var predicateFn;
            var matchAgainstAnyProp;
            switch (typeof expression) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return array.filter(predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && "$" in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isObject(actual) || isObject(expected)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression.$, comparator, false);
            }
            return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = typeof actual;
        var expectedType = typeof expected;
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (actualType === "array") {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === "$";
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }
            break;

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    var DECIMAL_SEP = ".";
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number)) return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [];
        var hasExponent = false;
        if (numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                number = 0;
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }
        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup;
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }
            while (fraction.length < fractionSize) {
                fraction += "0";
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
            if (fractionSize > 0 && number < 1) {
                formatedText = number.toFixed(fractionSize);
                number = parseFloat(formatedText);
            }
        }
        if (number === 0) {
            isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        if (num < 0) {
            neg = "-";
            num = -num;
        }
        num = "" + num;
        while (num.length < digits) num = "0" + num;
        if (trim) num = num.substr(num.length - digits);
        return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) value += offset;
            if (value === 0 && offset == -12) value = 12;
            return padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            var get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset();
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1)
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour;
                var m = int(match[5] || 0) - tzMin;
                var s = int(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date)) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            if (timezone && timezone === "UTC") {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit) {
            if (isNumber(input)) input = input.toString();
            if (!isArray(input) && !isString(input)) return input;
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = int(limit);
            }
            if (isString(input)) {
                if (limit) {
                    return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
                } else {
                    return "";
                }
            }
            var i, n;
            if (limit > input.length) limit = input.length; else if (limit < -input.length) limit = -input.length;
            if (limit > 0) {
                i = 0;
                n = limit;
            } else {
                if (!limit) return [];
                i = input.length + limit;
                n = input.length;
            }
            return input.slice(i, n);
        };
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array)) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            sortPredicate = sortPredicate.map(function(predicate) {
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-";
                        predicate = predicate.substring(1);
                    }
                    if (predicate === "") {
                        return reverseComparator(compare, descending);
                    }
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function isPrimitive(value) {
                switch (typeof value) {
                  case "number":
                  case "boolean":
                  case "string":
                    return true;

                  default:
                    return false;
                }
            }
            function objectToString(value) {
                if (value === null) return "null";
                if (typeof value.valueOf === "function") {
                    value = value.valueOf();
                    if (isPrimitive(value)) return value;
                }
                if (typeof value.toString === "function") {
                    value = value.toString();
                    if (isPrimitive(value)) return value;
                }
                return "";
            }
            function compare(v1, v2) {
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 === t2 && t1 === "object") {
                    v1 = objectToString(v1);
                    v2 = objectToString(v2);
                }
                if (t1 === t2) {
                    if (t1 === "string") {
                        v1 = v1.toLowerCase();
                        v2 = v2.toLowerCase();
                    }
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        };
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref && !attr.name) {
                return function(scope, element) {
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple") return;
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: function(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        var parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        };
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        };
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
        };
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            if (form[oldName] === control) {
                delete form[oldName];
            }
            form[newName] = control;
            control.$name = newName;
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            });
            arrayRemove(controls, control);
        };
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, control) {
                var list = object[property];
                if (!list) {
                    object[property] = [ control ];
                } else {
                    var index = list.indexOf(control);
                    if (index === -1) {
                        list.push(control);
                    }
                }
            },
            unset: function(object, property, control) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, control);
                if (list.length === 0) {
                    delete object[property];
                }
            },
            parentForm: parentForm,
            $animate: $animate
        });
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            form.$submitted = false;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        };
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS);
            form.$submitted = true;
            parentForm.$setSubmitted();
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function ngFormCompile(formElement) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm, alias = controller.$name;
                            if (alias) {
                                setter(scope, alias, controller, alias);
                                attr.$observe(attr.name ? "name" : "ngForm", function(newValue) {
                                    if (alias === newValue) return;
                                    setter(scope, alias, undefined, alias);
                                    alias = newValue;
                                    setter(scope, alias, controller, alias);
                                    parentFormCtrl.$$renameControl(controller, alias);
                                });
                            }
                            formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller);
                                if (alias) {
                                    setter(scope, alias, undefined, alias);
                                }
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
    var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var $ngModelMinErr = new minErr("ngModel");
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function(data) {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var timeout;
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (date) {
                        map = {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            var previousDate;
            ctrl.$$parserName = type;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    if (timezone === "UTC") {
                        parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
                    }
                    return parsedDate;
                }
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    if (previousDate && timezone === "UTC") {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset);
                    }
                    return $filter("date")(value, format, timezone);
                } else {
                    previousDate = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                };
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                };
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput && !validity.typeMismatch ? undefined : value;
            });
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = "number";
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
        if (attr.min || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            };
            attr.$observe("min", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
        if (attr.max || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
            };
            attr.$observe("max", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "url";
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "email";
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            if (element[0].checked) {
                ctrl.$setViewValue(attr.value, ev && ev.type);
            }
        };
        element.on("click", listener);
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending";
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
        this.$$setOptions = function(options) {
            ctrl.$options = options;
            if (options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                ngModelSet = function($scope, newValue) {
                    if (isFunction(parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: ctrl.$modelValue
                        });
                    } else {
                        parsedNgModelAssign($scope, ctrl.$modelValue);
                    }
                };
            } else if (!parsedNgModel.assign) {
                throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
            }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = true;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        });
        this.$setPristine = function() {
            ctrl.$dirty = false;
            ctrl.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
            ctrl.$dirty = true;
            ctrl.$pristine = false;
            $animate.removeClass($element, PRISTINE_CLASS);
            $animate.addClass($element, DIRTY_CLASS);
            parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            ctrl.$touched = false;
            ctrl.$untouched = true;
            $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
            ctrl.$touched = true;
            ctrl.$untouched = false;
            $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
            ctrl.$render();
        };
        this.$validate = function() {
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                return;
            }
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = ctrl.$$rawModelValue;
            var parserName = ctrl.$$parserName || "parse";
            var parserValid = ctrl.$error[parserName] ? false : undefined;
            var prevValid = ctrl.$valid;
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$runValidators(parserValid, modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    if (ctrl.$modelValue !== prevModelValue) {
                        ctrl.$$writeModelToScope();
                    }
                }
            });
        };
        this.$$runValidators = function(parseValid, modelValue, viewValue, doneCallback) {
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            if (!processParseErrors(parseValid)) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors(parseValid) {
                var errorKey = ctrl.$$parserName || "parse";
                if (parseValid === undefined) {
                    setValidity(errorKey, null);
                } else {
                    setValidity(errorKey, parseValid);
                    if (!parseValid) {
                        forEach(ctrl.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(ctrl.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                        return false;
                    }
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(ctrl.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function(error) {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    $q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === currentValidationRunId) {
                    ctrl.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        };
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce);
            if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !ctrl.$$hasNativeValidators)) {
                return;
            }
            ctrl.$$lastCommittedViewValue = viewValue;
            if (ctrl.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = viewValue;
            var parserValid = isUndefined(modelValue) ? undefined : true;
            if (parserValid) {
                for (var i = 0; i < ctrl.$parsers.length; i++) {
                    modelValue = ctrl.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        parserValid = false;
                        break;
                    }
                }
            }
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                ctrl.$modelValue = ngModelGet($scope);
            }
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue;
            if (allowInvalid) {
                ctrl.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            ctrl.$$runValidators(parserValid, modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (ctrl.$modelValue !== prevModelValue) {
                    ctrl.$$writeModelToScope();
                }
            }
        };
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue);
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        };
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value;
            if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                ctrl.$$debounceViewValueCommit(trigger);
            }
        };
        this.$$debounceViewValueCommit = function(trigger) {
            var debounceDelay = 0, options = ctrl.$options, debounce;
            if (options && isDefined(options.debounce)) {
                debounce = options.debounce;
                if (isNumber(debounce)) {
                    debounceDelay = debounce;
                } else if (isNumber(debounce[trigger])) {
                    debounceDelay = debounce[trigger];
                } else if (isNumber(debounce["default"])) {
                    debounceDelay = debounce["default"];
                }
            }
            $timeout.cancel(pendingDebounce);
            if (debounceDelay) {
                pendingDebounce = $timeout(function() {
                    ctrl.$commitViewValue();
                }, debounceDelay);
            } else if ($rootScope.$$phase) {
                ctrl.$commitViewValue();
            } else {
                $scope.$apply(function() {
                    ctrl.$commitViewValue();
                });
            }
        };
        $scope.$watch(function ngModelWatch() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                var formatters = ctrl.$formatters, idx = formatters.length;
                var viewValue = modelValue;
                while (idx--) {
                    viewValue = formatters[idx](viewValue);
                }
                if (ctrl.$viewValue !== viewValue) {
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                    ctrl.$render();
                    ctrl.$$runValidators(undefined, modelValue, viewValue, noop);
                }
            }
            return modelValue;
        });
    } ];
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                formCtrl.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                            element.on(modelCtrl.$options.updateOn, function(ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        element.on("blur", function(ev) {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(modelCtrl.$setTouched);
                            } else {
                                scope.$apply(modelCtrl.$setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    var requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function() {
                    ctrl.$validate();
                });
            }
        };
    };
    var patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var regexp, patternExp = attr.ngPattern || attr.pattern;
                attr.$observe("pattern", function(regex) {
                    if (isString(regex) && regex.length > 0) {
                        regex = new RegExp("^" + regex + "$");
                    }
                    if (regex && !regex.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    }
                    regexp = regex || undefined;
                    ctrl.$validate();
                });
                ctrl.$validators.pattern = function(value) {
                    return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
                };
            }
        };
    };
    var maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = -1;
                attr.$observe("maxlength", function(value) {
                    var intVal = int(value);
                    maxlength = isNaN(intVal) ? -1 : intVal;
                    ctrl.$validate();
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlength < 0 || ctrl.$isEmpty(modelValue) || viewValue.length <= maxlength;
                };
            }
        };
    };
    var minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = 0;
                attr.$observe("minlength", function(value) {
                    minlength = int(value) || 0;
                    ctrl.$validate();
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                };
            }
        };
    };
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = $scope.$eval($attrs.ngModelOptions);
                if (this.$options.updateOn !== undefined) {
                    this.$options.updateOnDefault = false;
                    this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                        that.$options.updateOnDefault = true;
                        return " ";
                    }));
                } else {
                    this.$options.updateOnDefault = true;
                }
            } ]
        };
    };
    function addSetValidityMethod(context) {
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, options) {
            if (state === undefined) {
                createAndSet("$pending", validationErrorKey, options);
            } else {
                unsetAndCleanup("$pending", validationErrorKey, options);
            }
            if (!isBoolean(state)) {
                unset(ctrl.$error, validationErrorKey, options);
                unset(ctrl.$$success, validationErrorKey, options);
            } else {
                if (state) {
                    unset(ctrl.$error, validationErrorKey, options);
                    set(ctrl.$$success, validationErrorKey, options);
                } else {
                    set(ctrl.$error, validationErrorKey, options);
                    unset(ctrl.$$success, validationErrorKey, options);
                }
            }
            if (ctrl.$pending) {
                cachedToggleClass(PENDING_CLASS, true);
                ctrl.$valid = ctrl.$invalid = undefined;
                toggleValidationCss("", null);
            } else {
                cachedToggleClass(PENDING_CLASS, false);
                ctrl.$valid = isObjectEmpty(ctrl.$error);
                ctrl.$invalid = !ctrl.$valid;
                toggleValidationCss("", ctrl.$valid);
            }
            var combinedState;
            if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (ctrl.$error[validationErrorKey]) {
                combinedState = false;
            } else if (ctrl.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(validationErrorKey, combinedState);
            parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, options) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, options);
        }
        function unsetAndCleanup(name, value, options) {
            if (ctrl[name]) {
                unset(ctrl[name], value, options);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(className, switchValue) {
            if (switchValue && !classCache[className]) {
                $animate.addClass($element, className);
                classCache[className] = true;
            } else if (!switchValue && classCache[className]) {
                $animate.removeClass($element, className);
                classCache[className] = false;
            }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                return false;
            }
        }
        return true;
    }
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                    return (value || "").toString();
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ];
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes);
                            }
                        });
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {};
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1);
                        toRemove = digestClassCounts(toRemove, -1);
                        if (toAdd && toAdd.length) {
                            $animate.addClass(element, toAdd);
                        }
                        if (toRemove && toRemove.length) {
                            $animate.removeClass(element, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        oldVal = shallowCopy(newVal);
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal;
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    var classes = [];
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, true);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).then(function() {
                                previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", "$sce", function($templateRequest, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).then(function() {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                        var afterAnimation = function() {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (/SVG/.test($element[0].toString())) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNaN(lastCount))) {
                        watchRemover();
                        watchRemover = scope.$watch(whensExpFns[count], updateElementText);
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " ");
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function(key, value, index) {
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                            collectionKeys.sort();
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) != nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, jqLite(previousNode));
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });
    var ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function ngSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                        $animate.cancel(previousLeaveAnimations[i]);
                    }
                    previousLeaveAnimations.length = 0;
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
            }
            $transclude(function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    });
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var ngOptionsMinErr = minErr("ngOptions");
    var ngOptionsDirective = valueFn({
        restrict: "A",
        terminal: true
    });
    var selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
                self.databound = $attrs.ngModel;
                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_;
                    nullOption = nullOption_;
                    unknownOption = unknownOption_;
                };
                self.addOption = function(value, element) {
                    assertNotHasOwnProperty(value, '"option value"');
                    optionsMap[value] = true;
                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value);
                        if (unknownOption.parent()) unknownOption.remove();
                    }
                    if (element && element[0].hasAttribute("selected")) {
                        element[0].selected = true;
                    }
                };
                self.removeOption = function(value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value];
                        if (ngModelCtrl.$viewValue === value) {
                            this.renderUnknownOption(value);
                        }
                    }
                };
                self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal);
                    $element.prepend(unknownOption);
                    $element.val(unknownVal);
                    unknownOption.prop("selected", true);
                };
                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                };
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[1]) return;
                var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, renderScheduled = false, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone();
                for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value === "") {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                }
                selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
                if (multiple) {
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
                if (optionsExp) setupAsOptions(scope, element, ngModelCtrl); else if (multiple) setupAsMultiple(scope, element, ngModelCtrl); else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove();
                            selectElement.val(viewValue);
                            if (viewValue === "") emptyOption.prop("selected", true);
                        } else {
                            if (isUndefined(viewValue) && emptyOption) {
                                selectElement.val("");
                            } else {
                                selectCtrl.renderUnknownOption(viewValue);
                            }
                        }
                    };
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            if (unknownOption.parent()) unknownOption.remove();
                            ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = shallowCopy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });
                    selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], selectAs = / as /.test(match[0]) && match[1], selectAsFn = selectAs ? $parse(selectAs) : null, keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, trackKeysCache = {}, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ], locals = {};
                    if (nullOption) {
                        $compile(nullOption)(scope);
                        nullOption.removeClass("ng-scope");
                        nullOption.remove();
                    }
                    selectElement.empty();
                    selectElement.on("change", selectionChanged);
                    ctrl.$render = render;
                    scope.$watchCollection(valuesFn, scheduleRendering);
                    scope.$watchCollection(getLabels, scheduleRendering);
                    if (multiple) {
                        scope.$watchCollection(function() {
                            return ctrl.$modelValue;
                        }, scheduleRendering);
                    }
                    function callExpression(exprFn, key, value) {
                        locals[valueName] = value;
                        if (keyName) locals[keyName] = key;
                        return exprFn(scope, locals);
                    }
                    function selectionChanged() {
                        scope.$apply(function() {
                            var collection = valuesFn(scope) || [];
                            var viewValue;
                            if (multiple) {
                                viewValue = [];
                                forEach(selectElement.val(), function(selectedKey) {
                                    selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey;
                                    viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
                                });
                            } else {
                                var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                viewValue = getViewValue(selectedKey, collection[selectedKey]);
                            }
                            ctrl.$setViewValue(viewValue);
                            render();
                        });
                    }
                    function getViewValue(key, value) {
                        if (key === "?") {
                            return undefined;
                        } else if (key === "") {
                            return null;
                        } else {
                            var viewValueFn = selectAsFn ? selectAsFn : valueFn;
                            return callExpression(viewValueFn, key, value);
                        }
                    }
                    function getLabels() {
                        var values = valuesFn(scope);
                        var toDisplay;
                        if (values && isArray(values)) {
                            toDisplay = new Array(values.length);
                            for (var i = 0, ii = values.length; i < ii; i++) {
                                toDisplay[i] = callExpression(displayFn, i, values[i]);
                            }
                            return toDisplay;
                        } else if (values) {
                            toDisplay = {};
                            for (var prop in values) {
                                if (values.hasOwnProperty(prop)) {
                                    toDisplay[prop] = callExpression(displayFn, prop, values[prop]);
                                }
                            }
                        }
                        return toDisplay;
                    }
                    function createIsSelectedFn(viewValue) {
                        var selectedSet;
                        if (multiple) {
                            if (trackFn && isArray(viewValue)) {
                                selectedSet = new HashMap([]);
                                for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) {
                                    selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), true);
                                }
                            } else {
                                selectedSet = new HashMap(viewValue);
                            }
                        } else if (trackFn) {
                            viewValue = callExpression(trackFn, null, viewValue);
                        }
                        return function isSelected(key, value) {
                            var compareValueFn;
                            if (trackFn) {
                                compareValueFn = trackFn;
                            } else if (selectAsFn) {
                                compareValueFn = selectAsFn;
                            } else {
                                compareValueFn = valueFn;
                            }
                            if (multiple) {
                                return isDefined(selectedSet.remove(callExpression(compareValueFn, key, value)));
                            } else {
                                return viewValue === callExpression(compareValueFn, key, value);
                            }
                        };
                    }
                    function scheduleRendering() {
                        if (!renderScheduled) {
                            scope.$$postDigest(render);
                            renderScheduled = true;
                        }
                    }
                    function updateLabelMap(labelMap, label, added) {
                        labelMap[label] = labelMap[label] || 0;
                        labelMap[label] += added ? 1 : -1;
                    }
                    function render() {
                        renderScheduled = false;
                        var optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key, value, groupLength, length, groupIndex, index, labelMap = {}, selected, isSelected = createIsSelectedFn(viewValue), anySelected = false, lastElement, element, label, optionId;
                        trackKeysCache = {};
                        for (index = 0; length = keys.length, index < length; index++) {
                            key = index;
                            if (keyName) {
                                key = keys[index];
                                if (key.charAt(0) === "$") continue;
                            }
                            value = values[key];
                            optionGroupName = callExpression(groupByFn, key, value) || "";
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            selected = isSelected(key, value);
                            anySelected = anySelected || selected;
                            label = callExpression(displayFn, key, value);
                            label = isDefined(label) ? label : "";
                            optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index;
                            if (trackFn) {
                                trackKeysCache[optionId] = key;
                            }
                            optionGroup.push({
                                id: optionId,
                                label: label,
                                selected: selected
                            });
                        }
                        if (!multiple) {
                            if (nullOption || viewValue === null) {
                                optionGroups[""].unshift({
                                    id: "",
                                    label: "",
                                    selected: !anySelected
                                });
                            } else if (!anySelected) {
                                optionGroups[""].unshift({
                                    id: "?",
                                    label: "",
                                    selected: true
                                });
                            }
                        }
                        for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                            optionGroupName = optionGroupNames[groupIndex];
                            optionGroup = optionGroups[optionGroupName];
                            if (optionGroupsCache.length <= groupIndex) {
                                existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [ existingParent ];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr("label", existingParent.label = optionGroupName);
                                }
                            }
                            lastElement = null;
                            for (index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if (existingOption = existingOptions[index + 1]) {
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        updateLabelMap(labelMap, existingOption.label, false);
                                        updateLabelMap(labelMap, option.label, true);
                                        lastElement.text(existingOption.label = option.label);
                                        lastElement.prop("label", existingOption.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop("selected", existingOption.selected = option.selected);
                                        if (msie) {
                                            lastElement.prop("selected", existingOption.selected);
                                        }
                                    }
                                } else {
                                    if (option.id === "" && nullOption) {
                                        element = nullOption;
                                    } else {
                                        (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label);
                                    }
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    updateLabelMap(labelMap, option.label, true);
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            index++;
                            while (existingOptions.length > index) {
                                option = existingOptions.pop();
                                updateLabelMap(labelMap, option.label, false);
                                option.element.remove();
                            }
                        }
                        while (optionGroupsCache.length > groupIndex) {
                            optionGroup = optionGroupsCache.pop();
                            for (index = 1; index < optionGroup.length; ++index) {
                                updateLabelMap(labelMap, optionGroup[index].label, false);
                            }
                            optionGroup[0].element.remove();
                        }
                        forEach(labelMap, function(count, label) {
                            if (count > 0) {
                                selectCtrl.addOption(label);
                            } else if (count < 0) {
                                selectCtrl.removeOption(label);
                            }
                        });
                    }
                }
            }
        };
    } ];
    var optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (!selectCtrl || !selectCtrl.databound) {
                        selectCtrl = nullSelectCtrl;
                    }
                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set("value", newVal);
                            if (oldVal !== newVal) {
                                selectCtrl.removeOption(oldVal);
                            }
                            selectCtrl.addOption(newVal, element);
                        });
                    } else {
                        selectCtrl.addOption(attr.value, element);
                    }
                    element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ];
    var styleDirective = valueFn({
        restrict: "E",
        terminal: false
    });
    if (window.angular.bootstrap) {
        console.log("WARNING: Tried to load angular more than once.");
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });
})(window, document);

!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>');

if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "ui.router";
}

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value;
                });
            }
        });
        return dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        angular.forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (;from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i].params) continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return false;
        }
        return true;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
            filtered[name] = values[name];
        });
        return filtered;
    }
    function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
            result[item[propName]] = item;
        });
        return result;
    }
    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    }
    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key];
        }
        return copy;
    }
    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }
    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }
    angular.module("ui.router.util", [ "ng" ]);
    angular.module("ui.router.router", [ "ui.router.util" ]);
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]);
    angular.module("ui.router", [ "ui.router.state" ]);
    angular.module("ui.router.compat", [ "ui.router" ]);
    $Resolve.$inject = [ "$q", "$injector" ];
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});
            var plan = [], cycle = [], visited = {};
            function visit(value, key) {
                if (visited[key] === VISIT_DONE) return;
                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;
                if (isString(value)) {
                    plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function(param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }
                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null;
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return function(locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals) locals = NO_LOCALS; else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent) parent = NO_PARENT; else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true;
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }
                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done(); else invoke(plan[i], plan[i + 1], plan[i + 2]);
                }
                function invoke(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    forEach(params, function(dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function(result) {
                                values[dep] = result;
                                if (!--waitParams) proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams) proceed();
                    function proceed() {
                        if (isDefined(result.$$failure)) return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function(result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    promises[key] = invocation.promise;
                }
                return result;
            };
        };
        this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    angular.module("ui.router.util").service("$resolve", $Resolve);
    $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ];
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        };
        this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
            if (isFunction(url)) url = url(params);
            if (url == null) return null; else return $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }
        function quoteRegExp(string, pattern, squash) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case false:
                surroundPattern = [ "(", ")" ];
                break;

              case true:
                surroundPattern = [ "?(", ")?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
                break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3];
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp)
            });
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        var p, param, segment;
        while (m = placeholder.exec(pattern)) {
            p = matchDetails(m, false);
            if (p.segment.indexOf("?") >= 0) break;
            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);
            if (search.length > 0) {
                last = 0;
                while (m = searchPlaceholder.exec(search)) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = "";
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
        return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName];
            var paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (;i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param)) return this.$$paramNames;
        return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i], param = paramset[name], value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
            } else {
                if (encoded == null || isDefaultValue && squash !== false) continue;
                if (!isArray(encoded)) encoded = [ encoded ];
                encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
                result += (search ? "&" : "?") + (name + "=" + encoded);
                search = true;
            }
        }
        return result;
    };
    function Type(config) {
        extend(this, config);
    }
    Type.prototype.is = function(val, key) {
        return true;
    };
    Type.prototype.encode = function(val, key) {
        return val;
    };
    Type.prototype.decode = function(val, key) {
        return val;
    };
    Type.prototype.equals = function(a, b) {
        return a == b;
    };
    Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    };
    Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return mode === "auto" ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true) return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode"));
            this.decode = arrayHandler(bindTo(type, "decode"));
            this.is = arrayHandler(bindTo(type, "is"), true);
            this.equals = arrayEqualsHandler(bindTo(type, "equals"));
            this.pattern = type.pattern;
            this.$arrayMode = mode;
        }
    };
    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        function regexpMatches(val) {
            return this.pattern.test(val);
        }
        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: regexpMatches,
                pattern: /[^/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                    return val === true || val === false;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    if (!this.is(val)) return undefined;
                    return [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-");
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
            if (isDefined(value)) isCaseInsensitive = value;
            return isCaseInsensitive;
        };
        this.strictMode = function(value) {
            if (isDefined(value)) isStrictMode = value;
            return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };
        this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
            if (!isObject(o)) return false;
            var result = true;
            forEach(UrlMatcher.prototype, function(val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };
        this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            $types[name] = new Type(extend({
                name: name
            }, definition));
            if (definitionFn) {
                typeQueue.push({
                    name: name,
                    def: definitionFn
                });
                if (!enqueue) flushTypeQueue();
            }
            return this;
        };
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        });
        $types = inherit($types, {});
        this.$get = [ "$injector", function($injector) {
            injector = $injector;
            enqueue = false;
            flushTypeQueue();
            forEach(defaultTypes, function(type, name) {
                if (!$types[name]) $types[name] = new Type(type);
            });
            return this;
        } ];
        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand) config = {
                    value: config
                };
                config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                };
                return config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType) return urlType;
                if (!config.type) return location === "config" ? $types.any : $types.string;
                return config.type instanceof Type ? config.type : new Type(config.type);
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: location === "search" ? "auto" : false
                };
                var arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: true
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false) return false;
                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                if (squash === true || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash)) replace.push({
                    from: squash,
                    to: undefined
                });
                configuredKeys = map(replace, function(item) {
                    return item.from;
                });
                return filter(defaultPolicy, function(item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                return injector.invoke(config.$$fn);
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };
        function ParamSet(params) {
            extend(this, params || {});
        }
        ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = true, self = this;
                forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right)) equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var result = true, isOptional, val, param, self = this;
                forEach(this.$$keys(), function(key) {
                    param = self[key];
                    val = paramValues[key];
                    isOptional = !val && param.isOptional;
                    result = result && (isOptional || !!param.type.is(val));
                });
                return result;
            },
            $$parent: undefined
        };
        this.ParamSet = ParamSet;
    }
    angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]);
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener;
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match[what === "$" ? 0 : Number(what)];
            });
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };
        this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };
        function handleIfMatch($injector, handler, match) {
            if (!match) return false;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what)) what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = [ "$match", function($match) {
                            return redirect.format($match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    if (handlerIsString) {
                        redirect = handler;
                        handler = [ "$match", function($match) {
                            return interpolate(redirect, $match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };
            var check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) {
                if (check[n]) return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
            if (defer === undefined) defer = true;
            interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = [ "$location", "$rootScope", "$injector", "$browser" ];
        function $get($location, $rootScope, $injector, $browser) {
            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === "/") return url;
                if (isHtml5) return baseHref.slice(0, -1) + url;
                if (absolute) return baseHref.slice(1) + url;
                return url;
            }
            function update(evt) {
                if (evt && evt.defaultPrevented) return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;
                if (ignoreUpdate) return true;
                function check(rule) {
                    var handled = rule($injector, $location);
                    if (!handled) return false;
                    if (isString(handled)) $location.replace().url(handled);
                    return true;
                }
                var n = rules.length, i;
                for (i = 0; i < n; i++) {
                    if (check(rules[i])) return;
                }
                if (otherwise) check(otherwise);
            }
            function listen() {
                listener = listener || $rootScope.$on("$locationChangeSuccess", update);
                return listener;
            }
            if (!interceptDeferred) listen();
            return {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location) return;
                    $location.url(location);
                    $location.replace();
                },
                push: function(urlMatcher, params, options) {
                    $location.url(urlMatcher.format(params || {}));
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace) $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }
                    var url = urlMatcher.format(params);
                    options = options || {};
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }
                    url = appendBasePath(url, isHtml5, options.absolute);
                    if (!options.absolute || !url) {
                        return url;
                    }
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    port = port === 80 || port === 443 ? "" : ":" + port;
                    return [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
    }
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
    $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {}, $state, queue = {}, abstractKey = "abstract";
        var stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data);
                }
                return state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) {
                    if (url.charAt(0) == "^") return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function(config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    if (name.indexOf("@") < 0) name += "@" + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };
        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                var rel = name.split("."), i = 0, pathLength = rel.length, current = base;
                for (;i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                return state;
            }
            return undefined;
        }
        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {
                            inherit: true,
                            location: false
                        });
                    }
                } ]);
            }
            flushQueuedChildren(name);
            return state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            if (globSegments[0] === "**") {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift("**");
            }
            if (globSegments[globSegments.length - 1] === "**") {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push("**");
            }
            if (globSegments.length != segments.length) {
                return false;
            }
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === "*") {
                    segments[i] = "*";
                }
            }
            return segments.join("") === globSegments.join("");
        }
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }
        this.state = state;
        function state(name, definition) {
            if (isObject(name)) definition = name; else definition.name = name;
            registerState(definition);
            return this;
        }
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error("transition superseded"));
            var TransitionPrevented = $q.reject(new Error("transition prevented"));
            var TransitionAborted = $q.reject(new Error("transition aborted"));
            var TransitionFailed = $q.reject(new Error("transition failed"));
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }
                if (!evt.retry) {
                    return null;
                }
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);
                retryTransition.then(function() {
                    if (retryTransition !== $state.transition) return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function() {
                    return TransitionAborted;
                });
                $urlRouter.update();
                return retryTransition;
            }
            root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            };
            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };
            $state.reload = function reload() {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: true,
                    inherit: false,
                    notify: true
                });
            };
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: true,
                    relative: $state.$current
                }, options));
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {});
                var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                var evt, toState = findState(to, options.relative);
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) {
                        return redirectResult;
                    }
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);
                    if (!isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                to = toState;
                var toPath = to.path;
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }
                if (shouldTriggerReload(to, from, locals, options)) {
                    if (to.self.reloadOnSearch !== false) $urlRouter.update();
                    $state.transition = null;
                    return $q.when($state.current);
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {});
                if (options.notify) {
                    if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $urlRouter.update();
                        return TransitionPrevented;
                    }
                }
                var resolved = $q.when(locals);
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        });
                    }
                    if (options.notify) {
                        $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);
                    return $state.current;
                }, function(error) {
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.transition = null;
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }
                    return $q.reject(error);
                });
                return transition;
            };
            $state.is = function is(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = state && options.lossy ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {
                    absolute: options.absolute
                });
            };
            $state.get = function(stateOrName, context) {
                if (arguments.length === 0) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            };
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                if (inherited) promises.push(inherited);
                forEach(state.views, function(view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                    injectables.$template = [ function() {
                        return $view.load(name, {
                            view: view,
                            locals: locals,
                            params: $stateParams,
                            notify: options.notify
                        }) || "";
                    } ];
                    promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals);
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                        } else {
                            result.$$controller = view.controller;
                        }
                        result.$$state = state;
                        result.$$controllerAs = view.controllerAs;
                        dst[name] = result;
                    }));
                });
                return $q.all(promises).then(function(values) {
                    return dst;
                });
            }
            return $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
            if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {
                return true;
            }
        }
    }
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$templateFactory" ];
        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    };
                    options = extend(defaults, options);
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    if (result && options.notify) {
                        $rootScope.$broadcast("$viewContentLoading", options);
                    }
                    return result;
                }
            };
        }
    }
    angular.module("ui.router.state").provider("$view", $ViewProvider);
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
            useAnchorScroll = true;
        };
        this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function($element) {
                $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        } ];
    }
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate");
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function(element, cb) {
                        element.remove();
                        cb();
                    }
                };
            };
            if ($animate) {
                return {
                    enter: function(element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb);
                        if (promise && promise.then) promise.then(cb);
                    },
                    leave: function(element, cb) {
                        var promise = $animate.leave(element, cb);
                        if (promise && promise.then) promise.then(cb);
                    }
                };
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }
            return statics();
        }
        var directive = {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(false);
                    });
                    scope.$on("$viewContentLoading", function() {
                        updateView(false);
                    });
                    updateView(true);
                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove();
                            previousEl = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function() {
                                previousEl = null;
                            });
                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (!firstTime && previousLocals === latestLocals) return;
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];
                        var clone = $transclude(newScope, function(clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit("$viewContentAnimationEnded");
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = clone;
                        currentScope = newScope;
                        currentScope.$emit("$viewContentLoaded");
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (!locals) {
                        return;
                    }
                    $element.data("$uiView", {
                        name: name,
                        state: locals.$$state
                    });
                    $element.html(locals.$template ? locals.$template : initial);
                    var link = $compile($element.contents());
                    if (locals.$$controller) {
                        locals.$scope = scope;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data("$ngControllerController", controller);
                        $element.children().data("$ngControllerController", controller);
                    }
                    link(scope);
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
        var inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    angular.module("ui.router.state").directive("uiView", $ViewDirective);
    angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
        if (preparsed) ref = current + "(" + preparsed[1] + ")";
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }
    $StateRefDirective.$inject = [ "$state", "$timeout" ];
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload" ];
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var params = null, url = null, base = stateContext(element) || $state.$current;
                var newHref = null, isAnchor = element.prop("tagName") === "A";
                var isForm = element[0].nodeName === "FORM";
                var attr = isForm ? "action" : "href", nav = true;
                var options = {
                    relative: base,
                    inherit: true
                };
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option];
                    }
                });
                var update = function(newVal) {
                    if (newVal) params = angular.copy(newVal);
                    if (!nav) return;
                    newHref = $state.href(ref.state, params, options);
                    var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                    if (activeDirective) {
                        activeDirective.$$setStateInfo(ref.state, params);
                    }
                    if (newHref === null) {
                        nav = false;
                        return false;
                    }
                    attrs.$set(attr, newHref);
                };
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                        if (newVal !== params) update(newVal);
                    }, true);
                    params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();
                if (isForm) return;
                element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                var state, params, activeClass;
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", false)($scope);
                this.$$setStateInfo = function(newState, newParams) {
                    state = $state.get(newState, stateContext($element));
                    params = newParams;
                    update();
                };
                $scope.$on("$stateChangeSuccess", update);
                function update() {
                    if (isMatch()) {
                        $element.addClass(activeClass);
                    } else {
                        $element.removeClass(activeClass);
                    }
                }
                function isMatch() {
                    if (typeof $attrs.uiSrefActiveEq !== "undefined") {
                        return state && $state.is(state.name, params);
                    } else {
                        return state && $state.includes(state.name, params);
                    }
                }
            } ]
        };
    }
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective);
    $IsStateFilter.$inject = [ "$state" ];
    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = [ "$state" ];
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
})(window, window.angular);

angular.module("ngMaterial", [ "ng", "ngAnimate", "ngAria", "material.core", "material.core.theming.palette", "material.core.theming", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.content", "material.components.dialog", "material.components.divider", "material.components.icon", "material.components.input", "material.components.list", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.textField", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.whiteframe" ]);

(function() {
    "use strict";
    angular.module("material.core", [ "material.core.theming" ]).run(MdCoreInitialize).config(MdCoreConfigure);
    function MdCoreInitialize() {
        if (typeof Hammer === "undefined") {
            throw new Error("ngMaterial requires HammerJS to be preloaded.");
        }
        Hammer.defaults.cssProps.userSelect = "";
    }
    function MdCoreConfigure($provide, $mdThemingProvider) {
        $provide.decorator("$$rAF", [ "$delegate", "$rootScope", rAFDecorator ]);
        $mdThemingProvider.theme("default").primaryColor("blue").accentColor("green").warnColor("red").backgroundColor("grey");
        function rAFDecorator($$rAF, $rootScope) {
            $$rAF.debounce = function(cb) {
                var queueArgs, alreadyQueued, queueCb, context;
                return function debounced() {
                    queueArgs = arguments;
                    context = this;
                    queueCb = cb;
                    if (!alreadyQueued) {
                        alreadyQueued = true;
                        $$rAF(function() {
                            queueCb.apply(context, queueArgs);
                            alreadyQueued = false;
                        });
                    }
                };
            };
            return $$rAF;
        }
    }
    MdCoreConfigure.$inject = [ "$provide", "$mdThemingProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdConstant", MdConstantFactory);
    function MdConstantFactory($$rAF, $sniffer) {
        var webkit = /webkit/i.test($sniffer.vendorPrefix);
        function vendorProperty(name) {
            return webkit ? "webkit" + name.charAt(0).toUpperCase() + name.substring(1) : name;
        }
        return {
            KEY_CODE: {
                ENTER: 13,
                ESCAPE: 27,
                SPACE: 32,
                LEFT_ARROW: 37,
                UP_ARROW: 38,
                RIGHT_ARROW: 39,
                DOWN_ARROW: 40
            },
            CSS: {
                TRANSITIONEND: "transitionend" + (webkit ? " webkitTransitionEnd" : ""),
                ANIMATIONEND: "animationend" + (webkit ? " webkitAnimationEnd" : ""),
                TRANSFORM: vendorProperty("transform"),
                TRANSITION: vendorProperty("transition"),
                TRANSITION_DURATION: vendorProperty("transitionDuration"),
                ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
                ANIMATION_DURATION: vendorProperty("animationDuration"),
                ANIMATION_NAME: vendorProperty("animationName"),
                ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
                ANIMATION_DIRECTION: vendorProperty("animationDirection")
            },
            MEDIA: {
                sm: "(max-width: 600px)",
                "gt-sm": "(min-width: 600px)",
                md: "(min-width: 600px) and (max-width: 960px)",
                "gt-md": "(min-width: 960px)",
                lg: "(min-width: 960px) and (max-width: 1200px)",
                "gt-lg": "(min-width: 1200px)"
            }
        };
    }
    MdConstantFactory.$inject = [ "$$rAF", "$sniffer" ];
})();

(function() {
    angular.module("material.core").config([ "$provide", function($provide) {
        $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
            $delegate.iterator = Iterator;
            return $delegate;
        } ]);
    } ]);
    function Iterator(items, reloop) {
        var trueFn = function() {
            return true;
        };
        reloop = !!reloop;
        var _items = items || [];
        return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
        };
        function getItems() {
            return [].concat(_items);
        }
        function count() {
            return _items.length;
        }
        function inRange(index) {
            return _items.length && index > -1 && index < _items.length;
        }
        function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
        }
        function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
        }
        function itemAt(index) {
            return inRange(index) ? _items[index] : null;
        }
        function findBy(key, val) {
            return _items.filter(function(item) {
                return item[key] === val;
            });
        }
        function add(item, index) {
            if (!item) return -1;
            if (!angular.isNumber(index)) {
                index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
        }
        function remove(item) {
            if (contains(item)) {
                _items.splice(indexOf(item), 1);
            }
        }
        function indexOf(item) {
            return _items.indexOf(item);
        }
        function contains(item) {
            return item && indexOf(item) > -1;
        }
        function first() {
            return _items.length ? _items[0] : null;
        }
        function last() {
            return _items.length ? _items[_items.length - 1] : null;
        }
        function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            if (!inRange(curIndex)) {
                return null;
            }
            var nextIndex = curIndex + (backwards ? -1 : 1);
            var foundItem = null;
            if (inRange(nextIndex)) {
                foundItem = _items[nextIndex];
            } else if (reloop) {
                foundItem = backwards ? last() : first();
                nextIndex = indexOf(foundItem);
            }
            if (foundItem === null || nextIndex === limit) {
                return null;
            }
            if (angular.isUndefined(limit)) {
                limit = nextIndex;
            }
            return validate(foundItem) ? foundItem : findSubsequentItem(backwards, foundItem, validate, limit);
        }
    }
})();

angular.module("material.core").factory("$mdMedia", mdMediaFactory);

function mdMediaFactory($mdConstant, $mdUtil, $rootScope, $window) {
    var queriesCache = $mdUtil.cacheFactory("$mdMedia:queries", {
        capacity: 15
    });
    var resultsCache = $mdUtil.cacheFactory("$mdMedia:results", {
        capacity: 15
    });
    angular.element($window).on("resize", updateAll);
    return $mdMedia;
    function $mdMedia(query) {
        var validated = queriesCache.get(query);
        if (angular.isUndefined(validated)) {
            validated = queriesCache.put(query, validate(query));
        }
        var result = resultsCache.get(validated);
        if (angular.isUndefined(result)) {
            result = add(validated);
        }
        return result;
    }
    function validate(query) {
        return $mdConstant.MEDIA[query] || (query.charAt(0) !== "(" ? "(" + query + ")" : query);
    }
    function add(query) {
        return resultsCache.put(query, !!$window.matchMedia(query).matches);
    }
    function updateAll() {
        var keys = resultsCache.keys();
        var len = keys.length;
        if (len) {
            for (var i = 0; i < len; i++) {
                add(keys[i]);
            }
            $rootScope.$evalAsync();
        }
    }
}

mdMediaFactory.$inject = [ "$mdConstant", "$mdUtil", "$rootScope", "$window" ];

(function() {
    "use strict";
    var nextUniqueId = [ "0", "0", "0" ];
    angular.module("material.core").factory("$mdUtil", [ "$cacheFactory", "$document", "$timeout", function($cacheFactory, $document, $timeout) {
        var Util;
        return Util = {
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now,
            attachDragBehavior: attachDragBehavior,
            elementRect: function(element, offsetParent) {
                var node = element[0];
                offsetParent = offsetParent || node.offsetParent || document.body;
                offsetParent = offsetParent[0] || offsetParent;
                var nodeRect = node.getBoundingClientRect();
                var parentRect = offsetParent.getBoundingClientRect();
                return {
                    left: nodeRect.left - parentRect.left + offsetParent.scrollLeft,
                    top: nodeRect.top - parentRect.top + offsetParent.scrollTop,
                    width: nodeRect.width,
                    height: nodeRect.height
                };
            },
            fakeNgModel: function() {
                return {
                    $setViewValue: function(value) {
                        this.$viewValue = value;
                        this.$render(value);
                        this.$viewChangeListeners.forEach(function(cb) {
                            cb();
                        });
                    },
                    $parsers: [],
                    $formatters: [],
                    $viewChangeListeners: [],
                    $render: angular.noop
                };
            },
            cacheFactory: cacheFactory,
            debounce: function(func, wait, scope, invokeApply) {
                var timer;
                return function debounced() {
                    var context = scope, args = Array.prototype.slice.call(arguments);
                    $timeout.cancel(timer);
                    timer = $timeout(function() {
                        timer = undefined;
                        func.apply(context, args);
                    }, wait || 10, invokeApply);
                };
            },
            throttle: function throttle(func, delay) {
                var recent;
                return function throttled() {
                    var context = this;
                    var args = arguments;
                    var now = Util.now();
                    if (!recent || now - recent > delay) {
                        func.apply(context, args);
                        recent = now;
                    }
                };
            },
            nextUid: function() {
                var index = nextUniqueId.length;
                var digit;
                while (index) {
                    index--;
                    digit = nextUniqueId[index].charCodeAt(0);
                    if (digit == 57) {
                        nextUniqueId[index] = "A";
                        return nextUniqueId.join("");
                    }
                    if (digit == 90) {
                        nextUniqueId[index] = "0";
                    } else {
                        nextUniqueId[index] = String.fromCharCode(digit + 1);
                        return nextUniqueId.join("");
                    }
                }
                nextUniqueId.unshift("0");
                return nextUniqueId.join("");
            },
            disconnectScope: function disconnectScope(scope) {
                if (!scope) return;
                if (scope.$root === scope) return;
                if (scope.$$destroyed) return;
                var parent = scope.$parent;
                scope.$$disconnected = true;
                if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;
                if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;
                if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
                if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
                scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
                if (!scope) return;
                if (scope.$root === scope) return;
                if (!scope.$$disconnected) return;
                var child = scope;
                var parent = child.$parent;
                child.$$disconnected = false;
                child.$$prevSibling = parent.$$childTail;
                if (parent.$$childHead) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childHead = parent.$$childTail = child;
                }
            },
            getClosest: function getClosest(el, tagName) {
                tagName = tagName.toUpperCase();
                do {
                    if (el.nodeName === tagName) {
                        return el;
                    }
                } while (el = el.parentNode);
                return null;
            }
        };
        function attachDragBehavior(scope, element, options) {
            var drag;
            var previousDrag;
            var pointerIsDown;
            var START_EVENTS = "mousedown touchstart pointerdown";
            var MOVE_EVENTS = "mousemove touchmove pointermove";
            var END_EVENTS = "mouseup mouseleave touchend touchcancel pointerup pointercancel";
            element.on(START_EVENTS, startDrag);
            $document.on(MOVE_EVENTS, doDrag).on(END_EVENTS, endDrag);
            scope.$on("$destroy", cleanup);
            return cleanup;
            function cleanup() {
                if (cleanup.called) return;
                cleanup.called = true;
                element.off(START_EVENTS, startDrag);
                $document.off(MOVE_EVENTS, doDrag).off(END_EVENTS, endDrag);
                drag = pointerIsDown = false;
            }
            function startDrag(ev) {
                var eventType = ev.type.charAt(0);
                var now = Util.now();
                if (previousDrag && previousDrag.pointerType !== eventType && now - previousDrag.endTime < 400) {
                    return;
                }
                if (pointerIsDown) return;
                pointerIsDown = true;
                drag = {
                    pointerType: eventType,
                    startX: getPosition(ev),
                    startTime: now
                };
                element.one("$md.dragstart", function(ev) {
                    if (ev.defaultPrevented) drag = null;
                });
                element.triggerHandler("$md.dragstart", drag);
            }
            function doDrag(ev) {
                if (!drag || !isProperEventType(ev, drag)) return;
                if (drag.pointerType === "t" || drag.pointerType === "p") {
                    ev.preventDefault();
                }
                updateDragState(ev);
                element.triggerHandler("$md.drag", drag);
            }
            function endDrag(ev) {
                pointerIsDown = false;
                if (!drag || !isProperEventType(ev, drag)) return;
                drag.endTime = Util.now();
                updateDragState(ev);
                element.triggerHandler("$md.dragend", drag);
                previousDrag = drag;
                drag = null;
            }
            function updateDragState(ev) {
                var x = getPosition(ev);
                drag.distance = drag.startX - x;
                drag.direction = drag.distance > 0 ? "left" : drag.distance < 0 ? "right" : "";
                drag.duration = drag.startTime - Util.now();
                drag.velocity = Math.abs(drag.duration) / drag.time;
            }
            function getPosition(ev) {
                ev = ev.originalEvent || ev;
                var point = ev.touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev;
                return point.pageX;
            }
            function isProperEventType(ev, drag) {
                return drag && ev && (ev.type || "").charAt(0) === drag.pointerType;
            }
        }
        function cacheFactory(id, options) {
            var cache = $cacheFactory(id, options);
            var keys = {};
            cache._put = cache.put;
            cache.put = function(k, v) {
                keys[k] = true;
                return cache._put(k, v);
            };
            cache._remove = cache.remove;
            cache.remove = function(k) {
                delete keys[k];
                return cache._remove(k);
            };
            cache._removeAll = cache.removeAll;
            cache.removeAll = function() {
                keys = {};
                return cache._removeAll();
            };
            cache._destroy = cache.destroy;
            cache.destroy = function() {
                keys = {};
                return cache._destroy();
            };
            cache.keys = function() {
                return Object.keys(keys);
            };
            return cache;
        }
    } ]);
    angular.element.prototype.focus = angular.element.prototype.focus || function() {
        if (this.length) {
            this[0].focus();
        }
        return this;
    };
    angular.element.prototype.blur = angular.element.prototype.blur || function() {
        if (this.length) {
            this[0].blur();
        }
        return this;
    };
})();

(function() {
    "use strict";
    angular.module("material.core").service("$mdAria", AriaService);
    function AriaService($$rAF, $log, $window) {
        return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
        };
        function expect(element, attrName, defaultValue) {
            var node = element[0];
            if (!node.hasAttribute(attrName) && !childHasAttribute(node, attrName)) {
                defaultValue = angular.isString(defaultValue) && defaultValue.trim() || "";
                if (defaultValue.length) {
                    element.attr(attrName, defaultValue);
                } else {
                    $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
                }
            }
        }
        function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
                expect(element, attrName, defaultValueGetter());
            });
        }
        function expectWithText(element, attrName) {
            expectAsync(element, attrName, function() {
                return element.text().trim();
            });
        }
        function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(), hasAttr = false;
            function isHidden(el) {
                var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
                return style.display === "none";
            }
            if (hasChildren) {
                var children = node.childNodes;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                        if (!isHidden(child)) {
                            hasAttr = true;
                        }
                    }
                }
            }
            return hasAttr;
        }
    }
    AriaService.$inject = [ "$$rAF", "$log", "$window" ];
})();

(function() {
    "use strict";
    angular.module("material.core").service("$mdCompiler", mdCompilerService);
    function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
        this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || "";
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = options.resolve || {};
            var locals = options.locals || {};
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
                if (angular.isString(value)) {
                    resolve[key] = $injector.get(value);
                } else {
                    resolve[key] = $injector.invoke(value);
                }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
                resolve.$template = $http.get(templateUrl, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                });
            } else {
                resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
                var template = transformTemplate(locals.$template);
                var element = angular.element("<div>").html(template.trim()).contents();
                var linkFn = $compile(element);
                return {
                    locals: locals,
                    element: element,
                    link: function link(scope) {
                        locals.$scope = scope;
                        if (controller) {
                            var ctrl = $controller(controller, locals);
                            if (bindToController) {
                                angular.extend(ctrl, locals);
                            }
                            element.data("$ngControllerController", ctrl);
                            element.children().data("$ngControllerController", ctrl);
                            if (controllerAs) {
                                scope[controllerAs] = ctrl;
                            }
                        }
                        return linkFn(scope);
                    }
                };
            });
        };
    }
    mdCompilerService.$inject = [ "$q", "$http", "$injector", "$compile", "$controller", "$templateCache" ];
})();

(function() {
    "use strict";
    angular.module("material.core").provider("$$interimElement", InterimElementProvider);
    function InterimElementProvider() {
        createInterimElementProvider.$get = InterimElementFactory;
        InterimElementFactory.$inject = [ "$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$interpolate", "$mdCompiler", "$mdTheming" ];
        return createInterimElementProvider;
        function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = [ "onHide", "onShow", "onRemove" ];
            var providerConfig = {
                presets: {}
            };
            var provider = {
                setDefaults: setDefaults,
                addPreset: addPreset,
                $get: factory
            };
            provider.addPreset("build", {
                methods: [ "controller", "controllerAs", "resolve", "template", "templateUrl", "themable", "transformTemplate", "parent" ]
            });
            factory.$inject = [ "$$interimElement", "$animate", "$injector" ];
            return provider;
            function setDefaults(definition) {
                providerConfig.optionsFactory = definition.options;
                providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
                return provider;
            }
            function addPreset(name, definition) {
                definition = definition || {};
                definition.methods = definition.methods || [];
                definition.options = definition.options || function() {
                    return {};
                };
                if (/^cancel|hide|show$/.test(name)) {
                    throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
                }
                if (definition.methods.indexOf("_options") > -1) {
                    throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
                }
                providerConfig.presets[name] = {
                    methods: definition.methods.concat(EXPOSED_METHODS),
                    optionsFactory: definition.options,
                    argOption: definition.argOption
                };
                return provider;
            }
            function factory($$interimElement, $animate, $injector) {
                var defaultMethods;
                var defaultOptions;
                var interimElementService = $$interimElement();
                var publicService = {
                    hide: interimElementService.hide,
                    cancel: interimElementService.cancel,
                    show: showInterimElement
                };
                defaultMethods = providerConfig.methods || [];
                defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
                angular.forEach(providerConfig.presets, function(definition, name) {
                    var presetDefaults = invokeFactory(definition.optionsFactory, {});
                    var presetMethods = (definition.methods || []).concat(defaultMethods);
                    angular.extend(presetDefaults, {
                        $type: name
                    });
                    function Preset(opts) {
                        this._options = angular.extend({}, presetDefaults, opts);
                    }
                    angular.forEach(presetMethods, function(name) {
                        Preset.prototype[name] = function(value) {
                            this._options[name] = value;
                            return this;
                        };
                    });
                    if (definition.argOption) {
                        var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
                        publicService[methodName] = function(arg) {
                            var config = publicService[name](arg);
                            return publicService.show(config);
                        };
                    }
                    publicService[name] = function(arg) {
                        if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                            return new Preset()[definition.argOption](arg);
                        } else {
                            return new Preset(arg);
                        }
                    };
                });
                return publicService;
                function showInterimElement(opts) {
                    if (opts && opts._options) opts = opts._options;
                    return interimElementService.show(angular.extend({}, defaultOptions, opts));
                }
                function invokeFactory(factory, defaultVal) {
                    var locals = {};
                    locals[interimFactoryName] = publicService;
                    return $injector.invoke(factory || function() {
                        return defaultVal;
                    }, {}, locals);
                }
            }
        }
        function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate, $interpolate, $mdCompiler, $mdTheming) {
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = startSymbol === "{{" && endSymbol === "}}", processTemplate = usesStandardSymbols ? angular.identity : replaceInterpolationSymbols;
            return function createInterimElementService() {
                var stack = [];
                var service;
                return service = {
                    show: show,
                    hide: hide,
                    cancel: cancel
                };
                function show(options) {
                    if (stack.length) {
                        service.cancel();
                    }
                    var interimElement = new InterimElement(options);
                    stack.push(interimElement);
                    return interimElement.show().then(function() {
                        return interimElement.deferred.promise;
                    });
                }
                function hide(response) {
                    var interimElement = stack.shift();
                    interimElement && interimElement.remove().then(function() {
                        interimElement.deferred.resolve(response);
                    });
                    return interimElement ? interimElement.deferred.promise : $q.when(response);
                }
                function cancel(reason) {
                    var interimElement = stack.shift();
                    interimElement && interimElement.remove().then(function() {
                        interimElement.deferred.reject(reason);
                    });
                    return interimElement ? interimElement.deferred.promise : $q.reject(reason);
                }
                function InterimElement(options) {
                    var self;
                    var hideTimeout, element;
                    options = options || {};
                    options = angular.extend({
                        scope: options.scope || $rootScope.$new(options.isolateScope),
                        onShow: function(scope, element, options) {
                            return $animate.enter(element, options.parent);
                        },
                        onRemove: function(scope, element, options) {
                            return element && $animate.leave(element) || $q.when();
                        }
                    }, options);
                    if (options.template) {
                        options.template = processTemplate(options.template);
                    }
                    return self = {
                        options: options,
                        deferred: $q.defer(),
                        show: function() {
                            return $mdCompiler.compile(options).then(function(compileData) {
                                angular.extend(compileData.locals, self.options);
                                if (angular.isString(options.parent)) {
                                    options.parent = angular.element($document[0].querySelector(options.parent));
                                } else if (!options.parent) {
                                    options.parent = $rootElement.find("body");
                                    if (!options.parent.length) options.parent = $rootElement;
                                }
                                element = compileData.link(options.scope);
                                if (options.themable) $mdTheming(element);
                                var ret = options.onShow(options.scope, element, options);
                                return $q.when(ret).then(function() {
                                    (options.onComplete || angular.noop)(options.scope, element, options);
                                    startHideTimeout();
                                });
                                function startHideTimeout() {
                                    if (options.hideDelay) {
                                        hideTimeout = $timeout(service.cancel, options.hideDelay);
                                    }
                                }
                            });
                        },
                        cancelTimeout: function() {
                            if (hideTimeout) {
                                $timeout.cancel(hideTimeout);
                                hideTimeout = undefined;
                            }
                        },
                        remove: function() {
                            self.cancelTimeout();
                            var ret = options.onRemove(options.scope, element, options);
                            return $q.when(ret).then(function() {
                                options.scope.$destroy();
                            });
                        }
                    };
                }
            };
            function replaceInterpolationSymbols(text) {
                if (!text || !angular.isString(text)) return text;
                return text.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }
        }
    }
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
    function ComponentRegistry($log, $q) {
        var self;
        var instances = [];
        var pendings = {};
        return self = {
            notFoundError: function(handle) {
                $log.error("No instance found for handle", handle);
            },
            getInstances: function() {
                return instances;
            },
            get: function(handle) {
                if (!isValidID(handle)) return null;
                var i, j, instance;
                for (i = 0, j = instances.length; i < j; i++) {
                    instance = instances[i];
                    if (instance.$$mdHandle === handle) {
                        return instance;
                    }
                }
                return null;
            },
            register: function(instance, handle) {
                if (!handle) return angular.noop;
                instance.$$mdHandle = handle;
                instances.push(instance);
                resolveWhen();
                return deregister;
                function deregister() {
                    var index = instances.indexOf(instance);
                    if (index !== -1) {
                        instances.splice(index, 1);
                    }
                }
                function resolveWhen() {
                    var dfd = pendings[handle];
                    if (dfd) {
                        dfd.resolve(instance);
                        delete pendings[handle];
                    }
                }
            },
            when: function(handle) {
                if (isValidID(handle)) {
                    var deferred = $q.defer();
                    var instance = self.get(handle);
                    if (instance) {
                        deferred.resolve(instance);
                    } else {
                        pendings[handle] = deferred;
                    }
                    return deferred.promise;
                }
                return $q.reject("Invalid `md-component-id` value.");
            }
        };
        function isValidID(handle) {
            return handle && handle !== "";
        }
    }
    ComponentRegistry.$inject = [ "$log", "$q" ];
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdInkRipple", InkRippleService).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective()).directive("mdNoBar", attrNoDirective()).directive("mdNoStretch", attrNoDirective());
    function InkRippleDirective($mdInkRipple) {
        return {
            controller: angular.noop,
            link: function(scope, element, attr) {
                if (attr.hasOwnProperty("mdInkRippleCheckbox")) {
                    $mdInkRipple.attachCheckboxBehavior(scope, element);
                } else {
                    $mdInkRipple.attachButtonBehavior(scope, element);
                }
            }
        };
    }
    InkRippleDirective.$inject = [ "$mdInkRipple" ];
    function InkRippleService($window, $timeout) {
        return {
            attachButtonBehavior: attachButtonBehavior,
            attachCheckboxBehavior: attachCheckboxBehavior,
            attachTabBehavior: attachTabBehavior,
            attach: attach
        };
        function attachButtonBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                isFAB: element.hasClass("md-fab"),
                isMenuItem: element.hasClass("md-menu-item"),
                center: false,
                dimBackground: true
            }, options));
        }
        function attachCheckboxBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                center: true,
                dimBackground: false
            }, options));
        }
        function attachTabBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: true
            }, options));
        }
        function attach(scope, element, options) {
            if (element.controller("mdNoInk")) return angular.noop;
            options = angular.extend({
                colorElement: element,
                mousedown: true,
                hover: true,
                focus: true,
                center: false,
                mousedownPauseTime: 150,
                dimBackground: false,
                outline: false,
                isFAB: false,
                isMenuItem: false
            }, options);
            var rippleContainer, rippleSize, controller = element.controller("mdInkRipple") || {}, counter = 0, ripples = [], states = [], isActiveExpr = element.attr("md-highlight"), isActive = false, isHeld = false, node = element[0], hammertime = new Hammer(node), color = parseColor(element.attr("md-ink-ripple")) || parseColor($window.getComputedStyle(options.colorElement[0]).color || "rgb(0, 0, 0)");
            scope._onInput = onInput;
            options.mousedown && hammertime.on("hammer.input", onInput);
            controller.createRipple = createRipple;
            if (isActiveExpr) {
                scope.$watch(isActiveExpr, function watchActive(newValue) {
                    isActive = newValue;
                    if (isActive && !ripples.length) {
                        $timeout(function() {
                            createRipple(0, 0);
                        }, 0, false);
                    }
                    angular.forEach(ripples, updateElement);
                });
            }
            return function detach() {
                hammertime.destroy();
                rippleContainer && rippleContainer.remove();
            };
            function parseColor(color) {
                if (!color) return;
                if (color.indexOf("rgba") === 0) return color.replace(/\d?\.?\d*\s*\)\s*$/, "0.1)");
                if (color.indexOf("rgb") === 0) return rgbToRGBA(color);
                if (color.indexOf("#") === 0) return hexToRGBA(color);
                function hexToRGBA(color) {
                    var hex = color.charAt(0) === "#" ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), grn = hex.substr(dig, dig), blu = hex.substr(dig * 2);
                    if (dig === 1) {
                        red += red;
                        grn += grn;
                        blu += blu;
                    }
                    return "rgba(" + parseInt(red, 16) + "," + parseInt(grn, 16) + "," + parseInt(blu, 16) + ",0.1)";
                }
                function rgbToRGBA(color) {
                    return color.replace(")", ", 0.1)").replace("(", "a(");
                }
            }
            function removeElement(elem, wait) {
                ripples.splice(ripples.indexOf(elem), 1);
                if (ripples.length === 0) {
                    rippleContainer && rippleContainer.css({
                        backgroundColor: ""
                    });
                }
                $timeout(function() {
                    elem.remove();
                }, wait, false);
            }
            function updateElement(elem) {
                var index = ripples.indexOf(elem), state = states[index] || {}, elemIsActive = ripples.length > 1 ? false : isActive, elemIsHeld = ripples.length > 1 ? false : isHeld;
                if (elemIsActive || state.animating || elemIsHeld) {
                    elem.addClass("md-ripple-visible");
                } else if (elem) {
                    elem.removeClass("md-ripple-visible");
                    if (options.outline) {
                        elem.css({
                            width: rippleSize + "px",
                            height: rippleSize + "px",
                            marginLeft: rippleSize * -1 + "px",
                            marginTop: rippleSize * -1 + "px"
                        });
                    }
                    removeElement(elem, options.outline ? 450 : 650);
                }
            }
            function createRipple(left, top) {
                color = parseColor(element.attr("md-ink-ripple")) || parseColor($window.getComputedStyle(options.colorElement[0]).color || "rgb(0, 0, 0)");
                var container = getRippleContainer(), size = getRippleSize(left, top), css = getRippleCss(size, left, top), elem = getRippleElement(css), index = ripples.indexOf(elem), state = states[index] || {};
                rippleSize = size;
                state.animating = true;
                $timeout(function() {
                    if (options.dimBackground) {
                        container.css({
                            backgroundColor: color
                        });
                    }
                    elem.addClass("md-ripple-placed md-ripple-scaled");
                    if (options.outline) {
                        elem.css({
                            borderWidth: size * .5 + "px",
                            marginLeft: size * -.5 + "px",
                            marginTop: size * -.5 + "px"
                        });
                    } else {
                        elem.css({
                            left: "50%",
                            top: "50%"
                        });
                    }
                    updateElement(elem);
                    $timeout(function() {
                        state.animating = false;
                        updateElement(elem);
                    }, options.outline ? 450 : 225, false);
                }, 0, false);
                return elem;
                function getRippleElement(css) {
                    var elem = angular.element('<div class="md-ripple" data-counter="' + counter++ + '">');
                    ripples.unshift(elem);
                    states.unshift({
                        animating: true
                    });
                    container.append(elem);
                    css && elem.css(css);
                    return elem;
                }
                function getRippleSize(left, top) {
                    var width = container.prop("offsetWidth"), height = container.prop("offsetHeight"), multiplier, size, rect;
                    if (options.isMenuItem) {
                        size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
                    } else if (options.outline) {
                        rect = node.getBoundingClientRect();
                        left -= rect.left;
                        top -= rect.top;
                        width = Math.max(left, width - left);
                        height = Math.max(top, height - top);
                        size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
                    } else {
                        multiplier = options.isFAB ? 1.1 : .8;
                        size = Math.max(width, height) * multiplier;
                    }
                    return size;
                }
                function getRippleCss(size, left, top) {
                    var rect, css = {
                        backgroundColor: rgbaToRGB(color),
                        borderColor: rgbaToRGB(color),
                        width: size + "px",
                        height: size + "px"
                    };
                    if (options.outline) {
                        css.width = 0;
                        css.height = 0;
                    } else {
                        css.marginLeft = css.marginTop = size * -.5 + "px";
                    }
                    if (options.center) {
                        css.left = css.top = "50%";
                    } else {
                        rect = node.getBoundingClientRect();
                        css.left = Math.round((left - rect.left) / container.prop("offsetWidth") * 100) + "%";
                        css.top = Math.round((top - rect.top) / container.prop("offsetHeight") * 100) + "%";
                    }
                    return css;
                    function rgbaToRGB(color) {
                        return color.replace("rgba", "rgb").replace(/,[^\)\,]+\)/, ")");
                    }
                }
                function getRippleContainer() {
                    if (rippleContainer) return rippleContainer;
                    var container = angular.element('<div class="md-ripple-container"></div>');
                    rippleContainer = container;
                    element.append(container);
                    return container;
                }
            }
            function onInput(ev) {
                var ripple, index;
                if (ev.eventType === Hammer.INPUT_START && ev.isFirst && isRippleAllowed()) {
                    ripple = createRipple(ev.center.x, ev.center.y);
                    isHeld = true;
                } else if (ev.eventType === Hammer.INPUT_END && ev.isFinal) {
                    isHeld = false;
                    index = ripples.length - 1;
                    ripple = ripples[index];
                    $timeout(function() {
                        updateElement(ripple);
                    }, 0, false);
                }
                function isRippleAllowed() {
                    var parent = node.parentNode;
                    var grandparent = parent && parent.parentNode;
                    var ancestor = grandparent && grandparent.parentNode;
                    return !isDisabled(node) && !isDisabled(parent) && !isDisabled(grandparent) && !isDisabled(ancestor);
                    function isDisabled(elem) {
                        return elem && elem.hasAttribute && elem.hasAttribute("disabled");
                    }
                }
            }
        }
    }
    InkRippleService.$inject = [ "$window", "$timeout" ];
    function attrNoDirective() {
        return function() {
            return {
                controller: angular.noop
            };
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.core.theming.palette", []).constant("$mdColorPalette", {
        red: {
            "50": "#ffebee",
            "100": "#ffcdd2",
            "200": "#ef9a9a",
            "300": "#e57373",
            "400": "#ef5350",
            "500": "#f44336",
            "600": "#e53935",
            "700": "#d32f2f",
            "800": "#c62828",
            "900": "#b71c1c",
            A100: "#ff8a80",
            A200: "#ff5252",
            A400: "#ff1744",
            A700: "#d50000",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100"
        },
        pink: {
            "50": "#fce4ec",
            "100": "#f8bbd0",
            "200": "#f48fb1",
            "300": "#f06292",
            "400": "#ec407a",
            "500": "#e91e63",
            "600": "#d81b60",
            "700": "#c2185b",
            "800": "#ad1457",
            "900": "#880e4f",
            A100: "#ff80ab",
            A200: "#ff4081",
            A400: "#f50057",
            A700: "#c51162",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100"
        },
        purple: {
            "50": "#f3e5f5",
            "100": "#e1bee7",
            "200": "#ce93d8",
            "300": "#ba68c8",
            "400": "#ab47bc",
            "500": "#9c27b0",
            "600": "#8e24aa",
            "700": "#7b1fa2",
            "800": "#6a1b9a",
            "900": "#4a148c",
            A100: "#ea80fc",
            A200: "#e040fb",
            A400: "#d500f9",
            A700: "#aa00ff",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100"
        },
        "deep-purple": {
            "50": "#ede7f6",
            "100": "#d1c4e9",
            "200": "#b39ddb",
            "300": "#9575cd",
            "400": "#7e57c2",
            "500": "#673ab7",
            "600": "#5e35b1",
            "700": "#512da8",
            "800": "#4527a0",
            "900": "#311b92",
            A100: "#b388ff",
            A200: "#7c4dff",
            A400: "#651fff",
            A700: "#6200ea",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100"
        },
        indigo: {
            "50": "#e8eaf6",
            "100": "#c5cae9",
            "200": "#9fa8da",
            "300": "#7986cb",
            "400": "#5c6bc0",
            "500": "#3f51b5",
            "600": "#3949ab",
            "700": "#303f9f",
            "800": "#283593",
            "900": "#1a237e",
            A100: "#8c9eff",
            A200: "#536dfe",
            A400: "#3d5afe",
            A700: "#304ffe",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100"
        },
        blue: {
            "50": "#e3f2fd",
            "100": "#bbdefb",
            "200": "#90caf9",
            "300": "#64b5f6",
            "400": "#42a5f5",
            "500": "#2196f3",
            "600": "#1e88e5",
            "700": "#1976d2",
            "800": "#1565c0",
            "900": "#0d47a1",
            A100: "#82b1ff",
            A200: "#448aff",
            A400: "#2979ff",
            A700: "#2962ff",
            contrastDefaultColor: "light",
            contrastDarkColors: "100 200 300 400 A100"
        },
        "light-blue": {
            "50": "#e1f5fe",
            "100": "#b3e5fc",
            "200": "#81d4fa",
            "300": "#4fc3f7",
            "400": "#29b6f6",
            "500": "#03a9f4",
            "600": "#039be5",
            "700": "#0288d1",
            "800": "#0277bd",
            "900": "#01579b",
            A100: "#80d8ff",
            A200: "#40c4ff",
            A400: "#00b0ff",
            A700: "#0091ea",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900 A700"
        },
        cyan: {
            "50": "#e0f7fa",
            "100": "#b2ebf2",
            "200": "#80deea",
            "300": "#4dd0e1",
            "400": "#26c6da",
            "500": "#00bcd4",
            "600": "#00acc1",
            "700": "#0097a7",
            "800": "#00838f",
            "900": "#006064",
            A100: "#84ffff",
            A200: "#18ffff",
            A400: "#00e5ff",
            A700: "#00b8d4",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900"
        },
        teal: {
            "50": "#e0f2f1",
            "100": "#b2dfdb",
            "200": "#80cbc4",
            "300": "#4db6ac",
            "400": "#26a69a",
            "500": "#009688",
            "600": "#00897b",
            "700": "#00796b",
            "800": "#00695c",
            "900": "#004d40",
            A100: "#a7ffeb",
            A200: "#64ffda",
            A400: "#1de9b6",
            A700: "#00bfa5",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900"
        },
        green: {
            "50": "#e8f5e9",
            "100": "#c8e6c9",
            "200": "#a5d6a7",
            "300": "#81c784",
            "400": "#66bb6a",
            "500": "#4caf50",
            "600": "#43a047",
            "700": "#388e3c",
            "800": "#2e7d32",
            "900": "#1b5e20",
            A100: "#b9f6ca",
            A200: "#69f0ae",
            A400: "#00e676",
            A700: "#00c853",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900"
        },
        "light-green": {
            "50": "#f1f8e9",
            "100": "#dcedc8",
            "200": "#c5e1a5",
            "300": "#aed581",
            "400": "#9ccc65",
            "500": "#8bc34a",
            "600": "#7cb342",
            "700": "#689f38",
            "800": "#558b2f",
            "900": "#33691e",
            A100: "#ccff90",
            A200: "#b2ff59",
            A400: "#76ff03",
            A700: "#64dd17",
            contrastDefaultColor: "dark",
            contrastLightColors: "800 900"
        },
        lime: {
            "50": "#f9fbe7",
            "100": "#f0f4c3",
            "200": "#e6ee9c",
            "300": "#dce775",
            "400": "#d4e157",
            "500": "#cddc39",
            "600": "#c0ca33",
            "700": "#afb42b",
            "800": "#9e9d24",
            "900": "#827717",
            A100: "#f4ff81",
            A200: "#eeff41",
            A400: "#c6ff00",
            A700: "#aeea00",
            contrastDefaultColor: "dark",
            contrastLightColors: "900"
        },
        yellow: {
            "50": "#fffde7",
            "100": "#fff9c4",
            "200": "#fff59d",
            "300": "#fff176",
            "400": "#ffee58",
            "500": "#ffeb3b",
            "600": "#fdd835",
            "700": "#fbc02d",
            "800": "#f9a825",
            "900": "#f57f17",
            A100: "#ffff8d",
            A200: "#ffff00",
            A400: "#ffea00",
            A700: "#ffd600",
            contrastDefaultColor: "dark"
        },
        amber: {
            "50": "#fff8e1",
            "100": "#ffecb3",
            "200": "#ffe082",
            "300": "#ffd54f",
            "400": "#ffca28",
            "500": "#ffc107",
            "600": "#ffb300",
            "700": "#ffa000",
            "800": "#ff8f00",
            "900": "#ff6f00",
            A100: "#ffe57f",
            A200: "#ffd740",
            A400: "#ffc400",
            A700: "#ffab00",
            contrastDefaultColor: "dark"
        },
        orange: {
            "50": "#fff3e0",
            "100": "#ffe0b2",
            "200": "#ffcc80",
            "300": "#ffb74d",
            "400": "#ffa726",
            "500": "#ff9800",
            "600": "#fb8c00",
            "700": "#f57c00",
            "800": "#ef6c00",
            "900": "#e65100",
            A100: "#ffd180",
            A200: "#ffab40",
            A400: "#ff9100",
            A700: "#ff6d00",
            contrastDefaultColor: "dark",
            contrastLightColors: "800 900"
        },
        "deep-orange": {
            "50": "#fbe9e7",
            "100": "#ffccbc",
            "200": "#ffab91",
            "300": "#ff8a65",
            "400": "#ff7043",
            "500": "#ff5722",
            "600": "#f4511e",
            "700": "#e64a19",
            "800": "#d84315",
            "900": "#bf360c",
            A100: "#ff9e80",
            A200: "#ff6e40",
            A400: "#ff3d00",
            A700: "#dd2c00",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100 A200"
        },
        brown: {
            "50": "#efebe9",
            "100": "#d7ccc8",
            "200": "#bcaaa4",
            "300": "#a1887f",
            "400": "#8d6e63",
            "500": "#795548",
            "600": "#6d4c41",
            "700": "#5d4037",
            "800": "#4e342e",
            "900": "#3e2723",
            A100: "#d7ccc8",
            A200: "#bcaaa4",
            A400: "#8d6e63",
            A700: "#5d4037",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200"
        },
        grey: {
            "0": "#ffffff",
            "50": "#fafafa",
            "100": "#f5f5f5",
            "200": "#eeeeee",
            "300": "#e0e0e0",
            "400": "#bdbdbd",
            "500": "#9e9e9e",
            "600": "#757575",
            "700": "#616161",
            "800": "#424242",
            "900": "#212121",
            "1000": "#000000",
            A100: "#ffffff",
            A200: "#eeeeee",
            A400: "#bdbdbd",
            A700: "#616161",
            contrastDefaultColor: "dark",
            contrastLightColors: "600 700 800 900"
        },
        "blue-grey": {
            "50": "#eceff1",
            "100": "#cfd8dc",
            "200": "#b0bec5",
            "300": "#90a4ae",
            "400": "#78909c",
            "500": "#607d8b",
            "600": "#546e7a",
            "700": "#455a64",
            "800": "#37474f",
            "900": "#263238",
            A100: "#cfd8dc",
            A200: "#b0bec5",
            A400: "#78909c",
            A700: "#455a64",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300"
        }
    });
})();

(function() {
    "use strict";
    angular.module("material.core.theming", [ "material.core.theming.palette" ]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).provider("$mdTheming", ThemingProvider).run(generateThemes);
    var PALETTES;
    var THEMES;
    var themingProvider;
    var generationIsDone;
    var DARK_FOREGROUND = {
        name: "dark",
        "1": "rgba(0,0,0,0.87)",
        "2": "rgba(0,0,0,0.54)",
        "3": "rgba(0,0,0,0.26)",
        "4": "rgba(0,0,0,0.12)"
    };
    var LIGHT_FOREGROUND = {
        name: "light",
        "1": "rgba(255,255,255,1.0)",
        "2": "rgba(255,255,255,0.7)",
        "3": "rgba(255,255,255,0.3)",
        "4": "rgba(255,255,255,0.12)"
    };
    var DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)";
    var LIGHT_SHADOW = "";
    var DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)");
    var LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)");
    var THEME_COLOR_TYPES = [ "primary", "accent", "warn", "background" ];
    var DEFAULT_COLOR_TYPE = "primary";
    var LIGHT_DEFAULT_HUES = {
        accent: {
            "default": "A700",
            "hue-1": "A200",
            "hue-2": "A400",
            "hue-3": "A100"
        }
    };
    var DARK_DEFAULT_HUES = {
        background: {
            "default": "500",
            "hue-1": "300",
            "hue-2": "600",
            "hue-3": "800"
        }
    };
    THEME_COLOR_TYPES.forEach(function(colorType) {
        var defaultDefaultHues = {
            "default": "500",
            "hue-1": "300",
            "hue-2": "800",
            "hue-3": "A100"
        };
        if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
        if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
    });
    var VALID_HUE_VALUES = [ "50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700" ];
    function ThemingProvider($mdColorPalette) {
        PALETTES = {};
        THEMES = {};
        var defaultTheme = "default";
        var alwaysWatchTheme = false;
        angular.extend(PALETTES, $mdColorPalette);
        ThemingService.$inject = [ "$rootScope" ];
        return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            setDefaultTheme: function(theme) {
                defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
                alwaysWatchTheme = alwaysWatch;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
        };
        function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
        }
        function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
        }
        function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
                return !map[field];
            });
            if (missingColors.length) {
                throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
            }
            return map;
        }
        function registerTheme(name, inheritFrom) {
            inheritFrom = inheritFrom || "default";
            if (THEMES[name]) return THEMES[name];
            var parentTheme = typeof inheritFrom === "string" ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
                angular.forEach(parentTheme.colors, function(color, colorType) {
                    theme.colors[colorType] = {
                        name: color.name,
                        hues: angular.extend({}, color.hues)
                    };
                });
            }
            THEMES[name] = theme;
            return theme;
        }
        function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
                isDark = arguments.length === 0 ? true : !!isDark;
                if (isDark === self.isDark) return;
                self.isDark = isDark;
                self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
                self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
                var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
                var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
                angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                    var color = self.colors[colorType];
                    var oldDefaults = oldDefaultHues[colorType];
                    if (color) {
                        for (var hueName in color.hues) {
                            if (color.hues[hueName] === oldDefaults[hueName]) {
                                color.hues[hueName] = newDefaults[hueName];
                            }
                        }
                    }
                });
                return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
                var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
                self[colorType + "Color"] = function setColorType(paletteName, hues) {
                    var color = self.colors[colorType] = {
                        name: paletteName,
                        hues: angular.extend({}, defaultHues, hues)
                    };
                    Object.keys(color.hues).forEach(function(name) {
                        if (!defaultHues[name]) {
                            throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")));
                        }
                    });
                    Object.keys(color.hues).map(function(key) {
                        return color.hues[key];
                    }).forEach(function(hueValue) {
                        if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                            throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")));
                        }
                    });
                    return self;
                };
            });
        }
        function ThemingService($rootScope) {
            applyTheme.inherit = function(el, parent) {
                var ctrl = parent.controller("mdTheme");
                var attrThemeValue = el.attr("md-theme-watch");
                if ((alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != "false") {
                    var deregisterWatch = $rootScope.$watch(function() {
                        return ctrl && ctrl.$mdTheme || defaultTheme;
                    }, changeTheme);
                    el.on("$destroy", deregisterWatch);
                } else {
                    var theme = ctrl && ctrl.$mdTheme || defaultTheme;
                    changeTheme(theme);
                }
                function changeTheme(theme) {
                    var oldTheme = el.data("$mdThemeName");
                    if (oldTheme) el.removeClass("md-" + oldTheme + "-theme");
                    el.addClass("md-" + theme + "-theme");
                    el.data("$mdThemeName", theme);
                }
            };
            return applyTheme;
            function applyTheme(scope, el) {
                if (el === undefined) {
                    el = scope;
                    scope = undefined;
                }
                if (scope === undefined) {
                    scope = $rootScope;
                }
                applyTheme.inherit(el, el);
            }
        }
    }
    ThemingProvider.$inject = [ "$mdColorPalette" ];
    function ThemingDirective($interpolate) {
        return {
            priority: 100,
            link: {
                pre: function(scope, el, attrs) {
                    var ctrl = {
                        $setTheme: function(theme) {
                            ctrl.$mdTheme = theme;
                        }
                    };
                    el.data("$mdThemeController", ctrl);
                    ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                    attrs.$observe("mdTheme", ctrl.$setTheme);
                }
            }
        };
    }
    ThemingDirective.$inject = [ "$interpolate" ];
    function ThemableDirective($mdTheming) {
        return $mdTheming;
    }
    ThemableDirective.$inject = [ "$mdTheming" ];
    function parseRules(theme, colorType, rules) {
        checkValidPalette(theme, colorType);
        rules = rules.replace(/THEME_NAME/g, theme.name);
        var generatedRules = [];
        var color = theme.colors[colorType];
        var themeNameRegex = new RegExp(".md-" + theme.name + "-theme", "g");
        var hueRegex = new RegExp("('|\")?{{\\s*(" + colorType + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g");
        var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?\s*\}\}'?"?/g;
        var palette = PALETTES[color.name];
        rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity) {
            if (colorType === "foreground") {
                if (hue == "shadow") {
                    return theme.foregroundShadow;
                } else {
                    return theme.foregroundPalette[hue] || theme.foregroundPalette["1"];
                }
            }
            if (hue.indexOf("hue") === 0) {
                hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || "").value, opacity);
        });
        angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
                return rgba(palette[hueValue][hueType === "color" ? "value" : "contrast"], opacity);
            });
            if (hueName !== "default") {
                newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName);
            }
            generatedRules.push(newRule);
        });
        return generatedRules.join("");
    }
    function generateThemes($injector) {
        var themeCss = $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
        angular.forEach(PALETTES, sanitizePalette);
        var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
        }).map(function(rule) {
            return rule.trim() + "}";
        });
        var rulesByType = {};
        THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = "";
        });
        var ruleMatchRegex = new RegExp("md-(" + THEME_COLOR_TYPES.join("|") + ")", "g");
        rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {
                if (rule.indexOf(".md-" + type) > -1) {
                    return rulesByType[type] += rule;
                }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
                if (rule.indexOf(type) > -1) {
                    return rulesByType[type] += rule;
                }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
        });
        var styleString = "";
        angular.forEach(THEMES, function(theme) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
                styleString += parseRules(theme, colorType, rulesByType[colorType] + "");
            });
        });
        if (!generationIsDone) {
            var style = document.createElement("style");
            style.innerHTML = styleString;
            var head = document.getElementsByTagName("head")[0];
            head.insertBefore(style, head.firstElementChild);
            generationIsDone = true;
        }
        function sanitizePalette(palette) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === "string") lightColors = lightColors.split(" ");
            if (typeof darkColors === "string") darkColors = darkColors.split(" ");
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
                if (angular.isObject(hueValue)) return;
                var rgbValue = colorToRgbaArray(hueValue);
                if (!rgbValue) {
                    throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
                }
                palette[hueName] = {
                    value: rgbValue,
                    contrast: getContrastColor()
                };
                function getContrastColor() {
                    if (defaultContrast === "light") {
                        return darkColors.indexOf(hueName) > -1 ? DARK_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                    } else {
                        return lightColors.indexOf(hueName) > -1 ? LIGHT_CONTRAST_COLOR : DARK_CONTRAST_COLOR;
                    }
                }
            });
        }
    }
    generateThemes.$inject = [ "$injector" ];
    function checkValidPalette(theme, colorType) {
        if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")));
        }
    }
    function colorToRgbaArray(clr) {
        if (angular.isArray(clr) && clr.length == 3) return clr;
        if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function(value) {
                return parseInt(value, 10);
            });
        }
        if (clr.charAt(0) == "#") clr = clr.substring(1);
        if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;
        var dig = clr.length / 3;
        var red = clr.substr(0, dig);
        var grn = clr.substr(dig, dig);
        var blu = clr.substr(dig * 2);
        if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
        }
        return [ parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16) ];
    }
    function rgba(rgbArray, opacity) {
        if (rgbArray.length == 4) opacity = rgbArray.pop();
        return opacity && opacity.length ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")";
    }
})();

(function() {
    "use strict";
    angular.module("material.components.backdrop", [ "material.core" ]).directive("mdBackdrop", BackdropDirective);
    function BackdropDirective($mdTheming) {
        return $mdTheming;
    }
    BackdropDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.bottomSheet", [ "material.core", "material.components.backdrop" ]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);
    function MdBottomSheetDirective() {
        return {
            restrict: "E"
        };
    }
    function MdBottomSheetProvider($$interimElementProvider) {
        bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$timeout", "$$rAF", "$compile", "$mdTheming", "$mdBottomSheet", "$rootElement" ];
        return $$interimElementProvider("$mdBottomSheet").setDefaults({
            options: bottomSheetDefaults
        });
        function bottomSheetDefaults($animate, $mdConstant, $timeout, $$rAF, $compile, $mdTheming, $mdBottomSheet, $rootElement) {
            var backdrop;
            return {
                themable: true,
                targetEvent: null,
                onShow: onShow,
                onRemove: onRemove,
                escapeToClose: true
            };
            function onShow(scope, element, options) {
                backdrop = $compile('<md-backdrop class="md-opaque md-bottom-sheet-backdrop">')(scope);
                backdrop.on("click touchstart", function() {
                    $timeout($mdBottomSheet.cancel);
                });
                $mdTheming.inherit(backdrop, options.parent);
                $animate.enter(backdrop, options.parent, null);
                var bottomSheet = new BottomSheet(element);
                options.bottomSheet = bottomSheet;
                options.targetEvent && angular.element(options.targetEvent.target).blur();
                $mdTheming.inherit(bottomSheet.element, options.parent);
                return $animate.enter(bottomSheet.element, options.parent).then(function() {
                    var focusable = angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector("[ng-click]"));
                    focusable.focus();
                    if (options.escapeToClose) {
                        options.rootElementKeyupCallback = function(e) {
                            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                $timeout($mdBottomSheet.cancel);
                            }
                        };
                        $rootElement.on("keyup", options.rootElementKeyupCallback);
                    }
                });
            }
            function onRemove(scope, element, options) {
                var bottomSheet = options.bottomSheet;
                $animate.leave(backdrop);
                return $animate.leave(bottomSheet.element).then(function() {
                    bottomSheet.cleanup();
                    options.targetEvent && angular.element(options.targetEvent.target).focus();
                });
            }
            function BottomSheet(element) {
                var MAX_OFFSET = 80;
                var WIGGLE_AMOUNT = 20;
                var CLOSING_VELOCITY = 10;
                var startY, lastY, velocity, transitionDelay, startTarget;
                element = element.eq(0);
                element.on("touchstart", onTouchStart).on("touchmove", onTouchMove).on("touchend", onTouchEnd);
                return {
                    element: element,
                    cleanup: function cleanup() {
                        element.off("touchstart", onTouchStart).off("touchmove", onTouchMove).off("touchend", onTouchEnd);
                    }
                };
                function onTouchStart(e) {
                    e.preventDefault();
                    startTarget = e.target;
                    startY = getY(e);
                    transitionDelay = element.css($mdConstant.CSS.TRANSITION_DURATION);
                    element.css($mdConstant.CSS.TRANSITION_DURATION, "0s");
                }
                function onTouchEnd(e) {
                    element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDelay);
                    var currentY = getY(e);
                    if (Math.abs(currentY - startY) < 5 && e.target == startTarget) {
                        angular.element(e.target).triggerHandler("click");
                    } else {
                        if (velocity > CLOSING_VELOCITY) {
                            $timeout($mdBottomSheet.cancel);
                        } else {
                            setTransformY(undefined);
                        }
                    }
                }
                function onTouchMove(e) {
                    var currentY = getY(e);
                    var delta = currentY - startY;
                    velocity = currentY - lastY;
                    lastY = currentY;
                    delta = adjustedDelta(delta);
                    setTransformY(delta + MAX_OFFSET);
                }
                function getY(e) {
                    var touch = e.touches && e.touches.length ? e.touches[0] : e.changedTouches[0];
                    return touch.clientY;
                }
                function setTransformY(amt) {
                    if (amt === null || amt === undefined) {
                        element.css($mdConstant.CSS.TRANSFORM, "");
                    } else {
                        element.css($mdConstant.CSS.TRANSFORM, "translate3d(0, " + amt + "px, 0)");
                    }
                }
                function adjustedDelta(delta) {
                    if (delta < 0 && delta < -MAX_OFFSET + WIGGLE_AMOUNT) {
                        delta = -delta;
                        var base = MAX_OFFSET - WIGGLE_AMOUNT;
                        delta = Math.max(-MAX_OFFSET, -Math.min(MAX_OFFSET - 5, base + WIGGLE_AMOUNT * (delta - base) / MAX_OFFSET) - delta / 50);
                    }
                    return delta;
                }
            }
        }
    }
    MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.button", [ "material.core" ]).directive("mdButton", MdButtonDirective);
    function MdButtonDirective($mdInkRipple, $mdTheming, $mdAria) {
        return {
            restrict: "E",
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
        };
        function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref);
        }
        function getTemplate(element, attr) {
            return isAnchor(attr) ? '<a class="md-button" ng-transclude></a>' : '<button class="md-button" ng-transclude></button>';
        }
        function postLink(scope, element, attr) {
            var node = element[0];
            $mdTheming(element);
            $mdInkRipple.attachButtonBehavior(scope, element);
            var elementHasText = node.textContent.trim();
            if (!elementHasText) {
                $mdAria.expect(element, "aria-label");
            }
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
                scope.$watch(attr.ngDisabled, function(isDisabled) {
                    element.attr("tabindex", isDisabled ? -1 : 0);
                });
            }
        }
    }
    MdButtonDirective.$inject = [ "$mdInkRipple", "$mdTheming", "$mdAria" ];
})();

(function() {
    "use strict";
    angular.module("material.components.card", [ "material.core" ]).directive("mdCard", mdCardDirective);
    function mdCardDirective($mdTheming) {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $mdTheming($element);
            }
        };
    }
    mdCardDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.checkbox", [ "material.core" ]).directive("mdCheckbox", MdCheckboxDirective);
    function MdCheckboxDirective(inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming, $mdUtil) {
        inputDirective = inputDirective[0];
        var CHECKED_CSS = "md-checked";
        return {
            restrict: "E",
            transclude: true,
            require: "?ngModel",
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + "</div>" + '<div ng-transclude class="md-label"></div>',
            compile: compile
        };
        function compile(tElement, tAttrs) {
            tAttrs.type = "checkbox";
            tAttrs.tabIndex = 0;
            tElement.attr("role", tAttrs.type);
            return function postLink(scope, element, attr, ngModelCtrl) {
                ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
                var checked = false;
                $mdTheming(element);
                $mdAria.expectWithText(tElement, "aria-label");
                inputDirective.link.pre(scope, {
                    on: angular.noop,
                    0: {}
                }, attr, [ ngModelCtrl ]);
                if (!attr.mdNoClick) {
                    element.on("click", listener);
                }
                element.on("keypress", keypressHandler);
                ngModelCtrl.$render = render;
                function keypressHandler(ev) {
                    if (ev.which === $mdConstant.KEY_CODE.SPACE) {
                        ev.preventDefault();
                        listener(ev);
                    }
                }
                function listener(ev) {
                    if (element[0].hasAttribute("disabled")) return;
                    scope.$apply(function() {
                        checked = !checked;
                        ngModelCtrl.$setViewValue(checked, ev && ev.type);
                        ngModelCtrl.$render();
                    });
                }
                function render() {
                    checked = ngModelCtrl.$viewValue;
                    if (checked) {
                        element.addClass(CHECKED_CSS);
                    } else {
                        element.removeClass(CHECKED_CSS);
                    }
                }
            };
        }
    }
    MdCheckboxDirective.$inject = [ "inputDirective", "$mdInkRipple", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil" ];
})();

(function() {
    "use strict";
    angular.module("material.components.content", [ "material.core" ]).directive("mdContent", mdContentDirective);
    function mdContentDirective($mdTheming) {
        return {
            restrict: "E",
            controller: [ "$scope", "$element", ContentController ],
            link: function($scope, $element, $attr) {
                $mdTheming($element);
                $scope.$broadcast("$mdContentLoaded", $element);
            }
        };
        function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
        }
    }
    mdContentDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.dialog", [ "material.core", "material.components.backdrop" ]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);
    function MdDialogDirective($$rAF, $mdTheming) {
        return {
            restrict: "E",
            link: function(scope, element, attr) {
                $mdTheming(element);
                $$rAF(function() {
                    var content = element[0].querySelector("md-content");
                    if (content && content.scrollHeight > content.clientHeight) {
                        element.addClass("md-content-overflow");
                    }
                });
            }
        };
    }
    MdDialogDirective.$inject = [ "$$rAF", "$mdTheming" ];
    function MdDialogProvider($$interimElementProvider) {
        var alertDialogMethods = [ "title", "content", "ariaLabel", "ok" ];
        advancedDialogOptions.$inject = [ "$mdDialog" ];
        dialogDefaultOptions.$inject = [ "$timeout", "$rootElement", "$compile", "$animate", "$mdAria", "$document", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$q", "$mdDialog" ];
        return $$interimElementProvider("$mdDialog").setDefaults({
            methods: [ "disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent" ],
            options: dialogDefaultOptions
        }).addPreset("alert", {
            methods: [ "title", "content", "ariaLabel", "ok" ],
            options: advancedDialogOptions
        }).addPreset("confirm", {
            methods: [ "title", "content", "ariaLabel", "ok", "cancel" ],
            options: advancedDialogOptions
        });
        function advancedDialogOptions($mdDialog) {
            return {
                template: [ '<md-dialog aria-label="{{ dialog.ariaLabel }}">', "<md-content>", "<h2>{{ dialog.title }}</h2>", "<p>{{ dialog.content }}</p>", "</md-content>", '<div class="md-actions">', '<md-button ng-if="dialog.$type == \'confirm\'" ng-click="dialog.abort()">', "{{ dialog.cancel }}", "</md-button>", '<md-button ng-click="dialog.hide()" class="md-primary">', "{{ dialog.ok }}", "</md-button>", "</div>", "</md-dialog>" ].join(""),
                controller: function mdDialogCtrl() {
                    this.hide = function() {
                        $mdDialog.hide(true);
                    };
                    this.abort = function() {
                        $mdDialog.cancel();
                    };
                },
                controllerAs: "dialog",
                bindToController: true
            };
        }
        function dialogDefaultOptions($timeout, $rootElement, $compile, $animate, $mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $$rAF, $q, $mdDialog) {
            return {
                hasBackdrop: true,
                isolateScope: true,
                onShow: onShow,
                onRemove: onRemove,
                clickOutsideToClose: true,
                escapeToClose: true,
                targetEvent: null,
                disableParentScroll: true,
                transformTemplate: function(template) {
                    return '<div class="md-dialog-container">' + template + "</div>";
                }
            };
            function onShow(scope, element, options) {
                options.parent = angular.element(options.parent);
                options.popInTarget = angular.element((options.targetEvent || {}).target);
                var closeButton = findCloseButton();
                configureAria(element.find("md-dialog"));
                if (options.hasBackdrop) {
                    options.backdrop = angular.element('<md-backdrop class="md-dialog-backdrop md-opaque">');
                    $mdTheming.inherit(options.backdrop, options.parent);
                    $animate.enter(options.backdrop, options.parent);
                }
                if (options.disableParentScroll) {
                    options.oldOverflowStyle = options.parent.css("overflow");
                    options.parent.css("overflow", "hidden");
                }
                return dialogPopIn(element, options.parent, options.popInTarget && options.popInTarget.length && options.popInTarget).then(function() {
                    if (options.escapeToClose) {
                        options.rootElementKeyupCallback = function(e) {
                            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                $timeout($mdDialog.cancel);
                            }
                        };
                        $rootElement.on("keyup", options.rootElementKeyupCallback);
                    }
                    if (options.clickOutsideToClose) {
                        options.dialogClickOutsideCallback = function(e) {
                            if (e.target === element[0]) {
                                $timeout($mdDialog.cancel);
                            }
                        };
                        element.on("click", options.dialogClickOutsideCallback);
                    }
                    closeButton.focus();
                });
                function findCloseButton() {
                    var closeButton = element[0].querySelector(".dialog-close");
                    if (!closeButton) {
                        var actionButtons = element[0].querySelectorAll(".md-actions button");
                        closeButton = actionButtons[actionButtons.length - 1];
                    }
                    return angular.element(closeButton);
                }
            }
            function onRemove(scope, element, options) {
                if (options.backdrop) {
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                    options.parent.css("overflow", options.oldOverflowStyle);
                    $document[0].removeEventListener("scroll", options.captureScroll, true);
                }
                if (options.escapeToClose) {
                    $rootElement.off("keyup", options.rootElementKeyupCallback);
                }
                if (options.clickOutsideToClose) {
                    element.off("click", options.dialogClickOutsideCallback);
                }
                return dialogPopOut(element, options.parent, options.popInTarget && options.popInTarget.length && options.popInTarget).then(function() {
                    options.scope.$destroy();
                    element.remove();
                    options.popInTarget && options.popInTarget.focus();
                });
            }
            function configureAria(element) {
                element.attr({
                    role: "dialog"
                });
                var dialogContent = element.find("md-content");
                if (dialogContent.length === 0) {
                    dialogContent = element;
                }
                $mdAria.expectAsync(element, "aria-label", function() {
                    var words = dialogContent.text().split(/\s+/);
                    if (words.length > 3) words = words.slice(0, 3).concat("...");
                    return words.join(" ");
                });
            }
            function dialogPopIn(container, parentElement, clickElement) {
                var dialogEl = container.find("md-dialog");
                parentElement.append(container);
                transformToClickElement(dialogEl, clickElement);
                $$rAF(function() {
                    dialogEl.addClass("transition-in").css($mdConstant.CSS.TRANSFORM, "");
                });
                return dialogTransitionEnd(dialogEl);
            }
            function dialogPopOut(container, parentElement, clickElement) {
                var dialogEl = container.find("md-dialog");
                dialogEl.addClass("transition-out").removeClass("transition-in");
                transformToClickElement(dialogEl, clickElement);
                return dialogTransitionEnd(dialogEl);
            }
            function transformToClickElement(dialogEl, clickElement) {
                if (clickElement) {
                    var clickRect = clickElement[0].getBoundingClientRect();
                    var dialogRect = dialogEl[0].getBoundingClientRect();
                    var scaleX = Math.min(.5, clickRect.width / dialogRect.width);
                    var scaleY = Math.min(.5, clickRect.height / dialogRect.height);
                    dialogEl.css($mdConstant.CSS.TRANSFORM, "translate3d(" + (-dialogRect.left + clickRect.left + clickRect.width / 2 - dialogRect.width / 2) + "px," + (-dialogRect.top + clickRect.top + clickRect.height / 2 - dialogRect.height / 2) + "px," + "0) scale(" + scaleX + "," + scaleY + ")");
                }
            }
            function dialogTransitionEnd(dialogEl) {
                var deferred = $q.defer();
                dialogEl.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                    if (ev.target === dialogEl[0]) {
                        dialogEl.off($mdConstant.CSS.TRANSITIONEND, finished);
                        deferred.resolve();
                    }
                }
                return deferred.promise;
            }
        }
    }
    MdDialogProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.divider", [ "material.core" ]).directive("mdDivider", MdDividerDirective);
    function MdDividerController() {}
    function MdDividerDirective($mdTheming) {
        return {
            restrict: "E",
            link: $mdTheming,
            controller: [ MdDividerController ]
        };
    }
    MdDividerDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.icon", [ "material.core" ]).directive("mdIcon", mdIconDirective);
    function mdIconDirective() {
        return {
            restrict: "E",
            template: '<object class="md-icon"></object>',
            compile: function(element, attr) {
                var object = angular.element(element[0].children[0]);
                if (angular.isDefined(attr.icon)) {
                    object.attr("data", attr.icon);
                }
            }
        };
    }
})();

(function() {
    angular.module("material.components.input", [ "material.core" ]).directive("mdInputContainer", mdInputContainerDirective).directive("label", labelDirective).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective);
    function mdInputContainerDirective($mdTheming) {
        ContainerCtrl.$inject = [ "$scope", "$element", "$mdUtil" ];
        return {
            restrict: "E",
            link: postLink,
            controller: ContainerCtrl
        };
        function postLink(scope, element, attr) {
            $mdTheming(element);
        }
        function ContainerCtrl($scope, $element, $mdUtil) {
            var self = this;
            self.element = $element;
            self.setFocused = function(isFocused) {
                $element.toggleClass("md-input-focused", !!isFocused);
            };
            self.setHasValue = function(hasValue) {
                $element.toggleClass("md-input-has-value", !!hasValue);
            };
            self.setInvalid = function(isInvalid) {
                $element.toggleClass("md-input-invalid", !!isInvalid);
            };
            $scope.$watch(function() {
                return self.label && self.input;
            }, function(hasLabelAndInput) {
                if (hasLabelAndInput && !self.label.attr("for")) {
                    self.label.attr("for", self.input.attr("id"));
                }
            });
        }
    }
    mdInputContainerDirective.$inject = [ "$mdTheming" ];
    function labelDirective() {
        return {
            restrict: "E",
            require: "^?mdInputContainer",
            link: function(scope, element, attr, containerCtrl) {
                if (!containerCtrl) return;
                containerCtrl.label = element;
                scope.$on("$destroy", function() {
                    containerCtrl.label = null;
                });
            }
        };
    }
    function inputTextareaDirective($mdUtil, $window, $compile, $animate) {
        return {
            restrict: "E",
            require: [ "^?mdInputContainer", "?ngModel" ],
            compile: compile
        };
        function compile(element) {
            element.addClass("md-input");
            return postLink;
        }
        function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            if (!containerCtrl) return;
            if (containerCtrl.input) {
                throw new Error("<md-input-container> can only have *one* <input> or <textarea> child element!");
            }
            containerCtrl.input = element;
            if (!element.attr("id")) {
                element.attr("id", "input_" + $mdUtil.nextUid());
            }
            if (element[0].tagName.toLowerCase() === "textarea") {
                setupTextarea();
            }
            var isEmpty = ngModelCtrl ? ngModelCtrl.$isEmpty : function() {
                return ("" + element.val()).length === 0;
            };
            if (ngModelCtrl) {
                scope.$watch(function() {
                    return ngModelCtrl.$dirty && ngModelCtrl.$invalid;
                }, containerCtrl.setInvalid);
                ngModelCtrl.$formatters.push(checkHasValue);
                ngModelCtrl.$parsers.push(checkHasValue);
            } else {
                checkHasValue();
            }
            element.on("input", checkHasValue);
            function checkHasValue(value) {
                containerCtrl.setHasValue(!isEmpty(value) || (element[0].validity || {}).badInput);
                return value;
            }
            element.on("focus", function(ev) {
                containerCtrl.setFocused(true);
            }).on("blur", function(ev) {
                containerCtrl.setFocused(false);
            });
            scope.$on("$destroy", function() {
                containerCtrl.setFocused(false);
                containerCtrl.setHasValue(false);
                containerCtrl.input = null;
            });
            function setupTextarea() {
                var node = element[0];
                var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
                function pipelineListener(value) {
                    onChangeTextarea();
                    return value;
                }
                if (ngModelCtrl) {
                    ngModelCtrl.$formatters.push(pipelineListener);
                    ngModelCtrl.$viewChangeListeners.push(pipelineListener);
                } else {
                    onChangeTextarea();
                }
                element.on("keydown input", onChangeTextarea);
                element.on("scroll", onScroll);
                angular.element($window).on("resize", onChangeTextarea);
                scope.$on("$destroy", function() {
                    angular.element($window).off("resize", onChangeTextarea);
                });
                function growTextarea() {
                    node.style.height = "auto";
                    var line = node.scrollHeight - node.offsetHeight;
                    node.scrollTop = 0;
                    var height = node.offsetHeight + (line > 0 ? line : 0);
                    node.style.height = height + "px";
                }
                function onScroll(e) {
                    node.scrollTop = 0;
                    var line = node.scrollHeight - node.offsetHeight;
                    var height = node.offsetHeight + line;
                    node.style.height = height + "px";
                }
            }
        }
    }
    inputTextareaDirective.$inject = [ "$mdUtil", "$window", "$compile", "$animate" ];
    function mdMaxlengthDirective() {
        return {
            restrict: "A",
            require: [ "ngModel", "^mdInputContainer" ],
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl = angular.element('<div class="md-char-counter">');
            attr.$set("ngTrim", "false");
            containerCtrl.element.append(charCountEl);
            ngModelCtrl.$formatters.push(renderCharCount);
            ngModelCtrl.$viewChangeListeners.push(renderCharCount);
            element.on("input keydown", renderCharCount);
            scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                    if (!charCountEl.parent().length) {
                        $animate.enter(charCountEl, containerCtrl.element, angular.element(containerCtrl.element[0].lastElementChild));
                    }
                    renderCharCount();
                } else {
                    $animate.leave(charCountEl);
                }
            });
            ngModelCtrl.$validators["md-maxlength"] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                    return true;
                }
                return (element.val() || modelValue || viewValue || "").length <= maxlength;
            };
            function renderCharCount(value) {
                charCountEl.text(element.val().length + "/" + maxlength);
                return value;
            }
        }
    }
})();

(function() {
    "use strict";
    angular.module("material.components.list", [ "material.core" ]).directive("mdList", mdListDirective).directive("mdItem", mdItemDirective);
    function mdListDirective() {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $element.attr({
                    role: "list"
                });
            }
        };
    }
    function mdItemDirective() {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $element.attr({
                    role: "listitem"
                });
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.progressCircular", [ "material.core" ]).directive("mdProgressCircular", MdProgressCircularDirective);
    function MdProgressCircularDirective($$rAF, $mdConstant, $mdTheming) {
        var fillRotations = new Array(101), fixRotations = new Array(101);
        for (var i = 0; i < 101; i++) {
            var percent = i / 100;
            var rotation = Math.floor(percent * 180);
            fillRotations[i] = "rotate(" + rotation.toString() + "deg)";
            fixRotations[i] = "rotate(" + (rotation * 2).toString() + "deg)";
        }
        return {
            restrict: "E",
            template: '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + "</div>" + '<div class="md-right">' + '<div class="md-half-circle"></div>' + "</div>" + "</div>" + "</div>",
            compile: compile
        };
        function compile(tElement, tAttrs, transclude) {
            tElement.attr("aria-valuemin", 0);
            tElement.attr("aria-valuemax", 100);
            tElement.attr("role", "progressbar");
            return postLink;
        }
        function postLink(scope, element, attr) {
            $mdTheming(element);
            var circle = element[0], fill = circle.querySelectorAll(".md-fill, .md-mask.md-full"), fix = circle.querySelectorAll(".md-fill.md-fix"), i, clamped, fillRotation, fixRotation;
            var diameter = attr.mdDiameter || 48;
            var scale = diameter / 48;
            circle.style[$mdConstant.CSS.TRANSFORM] = "scale(" + scale.toString() + ")";
            attr.$observe("value", function(value) {
                clamped = clamp(value);
                fillRotation = fillRotations[clamped];
                fixRotation = fixRotations[clamped];
                element.attr("aria-valuenow", clamped);
                for (i = 0; i < fill.length; i++) {
                    fill[i].style[$mdConstant.CSS.TRANSFORM] = fillRotation;
                }
                for (i = 0; i < fix.length; i++) {
                    fix[i].style[$mdConstant.CSS.TRANSFORM] = fixRotation;
                }
            });
        }
        function clamp(value) {
            if (value > 100) {
                return 100;
            }
            if (value < 0) {
                return 0;
            }
            return Math.ceil(value || 0);
        }
    }
    MdProgressCircularDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.progressLinear", [ "material.core" ]).directive("mdProgressLinear", MdProgressLinearDirective);
    function MdProgressLinearDirective($$rAF, $mdConstant, $mdTheming) {
        return {
            restrict: "E",
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + "</div>",
            compile: compile
        };
        function compile(tElement, tAttrs, transclude) {
            tElement.attr("aria-valuemin", 0);
            tElement.attr("aria-valuemax", 100);
            tElement.attr("role", "progressbar");
            return postLink;
        }
        function postLink(scope, element, attr) {
            $mdTheming(element);
            var bar1Style = element[0].querySelector(".md-bar1").style, bar2Style = element[0].querySelector(".md-bar2").style, container = angular.element(element[0].querySelector(".md-container"));
            attr.$observe("value", function(value) {
                if (attr.mdMode == "query") {
                    return;
                }
                var clamped = clamp(value);
                element.attr("aria-valuenow", clamped);
                bar2Style[$mdConstant.CSS.TRANSFORM] = transforms[clamped];
            });
            attr.$observe("mdBufferValue", function(value) {
                bar1Style[$mdConstant.CSS.TRANSFORM] = transforms[clamp(value)];
            });
            $$rAF(function() {
                container.addClass("md-ready");
            });
        }
        function clamp(value) {
            if (value > 100) {
                return 100;
            }
            if (value < 0) {
                return 0;
            }
            return Math.ceil(value || 0);
        }
    }
    MdProgressLinearDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
    var transforms = function() {
        var values = new Array(101);
        for (var i = 0; i < 101; i++) {
            values[i] = makeTransform(i);
        }
        return values;
        function makeTransform(value) {
            var scale = value / 100;
            var translateX = (value - 100) / 2;
            return "translateX(" + translateX.toString() + "%) scale(" + scale.toString() + ", 1)";
        }
    }();
})();

(function() {
    "use strict";
    angular.module("material.components.radioButton", [ "material.core" ]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);
    function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming) {
        RadioGroupController.prototype = createRadioGroupControllerProto();
        return {
            restrict: "E",
            controller: [ "$element", RadioGroupController ],
            require: [ "mdRadioGroup", "?ngModel" ],
            link: {
                pre: linkRadioGroup
            }
        };
        function linkRadioGroup(scope, element, attr, ctrls) {
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            function keydownListener(ev) {
                switch (ev.keyCode) {
                  case $mdConstant.KEY_CODE.LEFT_ARROW:
                  case $mdConstant.KEY_CODE.UP_ARROW:
                    ev.preventDefault();
                    rgCtrl.selectPrevious();
                    break;

                  case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  case $mdConstant.KEY_CODE.DOWN_ARROW:
                    ev.preventDefault();
                    rgCtrl.selectNext();
                    break;

                  case $mdConstant.KEY_CODE.ENTER:
                    var form = angular.element($mdUtil.getClosest(element[0], "form"));
                    if (form.length > 0) {
                        form.triggerHandler("submit");
                    }
                    break;
                }
            }
            rgCtrl.init(ngModelCtrl);
            element.attr({
                role: "radiogroup",
                tabIndex: element.attr("tabindex") || "0"
            }).on("keydown", keydownListener);
        }
        function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
        }
        function createRadioGroupControllerProto() {
            return {
                init: function(ngModelCtrl) {
                    this._ngModelCtrl = ngModelCtrl;
                    this._ngModelCtrl.$render = angular.bind(this, this.render);
                },
                add: function(rbRender) {
                    this._radioButtonRenderFns.push(rbRender);
                },
                remove: function(rbRender) {
                    var index = this._radioButtonRenderFns.indexOf(rbRender);
                    if (index !== -1) {
                        this._radioButtonRenderFns.splice(index, 1);
                    }
                },
                render: function() {
                    this._radioButtonRenderFns.forEach(function(rbRender) {
                        rbRender();
                    });
                },
                setViewValue: function(value, eventType) {
                    this._ngModelCtrl.$setViewValue(value, eventType);
                    this.render();
                },
                getViewValue: function() {
                    return this._ngModelCtrl.$viewValue;
                },
                selectNext: function() {
                    return changeSelectedButton(this.$element, 1);
                },
                selectPrevious: function() {
                    return changeSelectedButton(this.$element, -1);
                },
                setActiveDescendant: function(radioId) {
                    this.$element.attr("aria-activedescendant", radioId);
                }
            };
        }
        function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(Array.prototype.slice.call(parent[0].querySelectorAll("md-radio-button")), true);
            if (buttons.count()) {
                var validate = function(button) {
                    return !angular.element(button).attr("disabled");
                };
                var selected = parent[0].querySelector("md-radio-button.md-checked");
                var target = buttons[increment < 0 ? "previous" : "next"](selected, validate) || buttons.first();
                angular.element(target).triggerHandler("click");
            }
        }
    }
    mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming" ];
    function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
        var CHECKED_CSS = "md-checked";
        return {
            restrict: "E",
            require: "^mdRadioGroup",
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + "</div>" + '<div ng-transclude class="md-label"></div>',
            link: link
        };
        function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            rgCtrl.add(render);
            attr.$observe("value", render);
            element.on("click", listener).on("$destroy", function() {
                rgCtrl.remove(render);
            });
            function listener(ev) {
                if (element[0].hasAttribute("disabled")) return;
                scope.$apply(function() {
                    rgCtrl.setViewValue(attr.value, ev && ev.type);
                });
            }
            function render() {
                var checked = rgCtrl.getViewValue() == attr.value;
                if (checked === lastChecked) {
                    return;
                }
                lastChecked = checked;
                element.attr("aria-checked", checked);
                if (checked) {
                    element.addClass(CHECKED_CSS);
                    rgCtrl.setActiveDescendant(element.attr("id"));
                } else {
                    element.removeClass(CHECKED_CSS);
                }
            }
            function configureAria(element, scope) {
                scope.ariaId = buildAriaID();
                element.attr({
                    id: scope.ariaId,
                    role: "radio",
                    "aria-checked": "false"
                });
                $mdAria.expectWithText(element, "aria-label");
                function buildAriaID() {
                    return attr.id || "radio" + "_" + $mdUtil.nextUid();
                }
            }
        }
    }
    mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.sidenav", [ "material.core", "material.components.backdrop" ]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).controller("$mdSidenavController", SidenavController);
    function SidenavService($mdComponentRegistry, $q) {
        return function(handle) {
            var errorMsg = "SideNav '" + handle + "' is not available!";
            var instance = $mdComponentRegistry.get(handle);
            if (!instance) {
                $mdComponentRegistry.notFoundError(handle);
            }
            return {
                isOpen: function() {
                    return instance && instance.isOpen();
                },
                toggle: function() {
                    return instance ? instance.toggle() : $q.reject(errorMsg);
                },
                open: function() {
                    return instance ? instance.open() : $q.reject(errorMsg);
                },
                close: function() {
                    return instance ? instance.close() : $q.reject(errorMsg);
                }
            };
        };
    }
    SidenavService.$inject = [ "$mdComponentRegistry", "$q" ];
    function SidenavDirective($timeout, $animate, $parse, $mdMedia, $mdConstant, $compile, $mdTheming, $q, $document) {
        return {
            restrict: "E",
            scope: {
                isOpen: "=?mdIsOpen"
            },
            controller: "$mdSidenavController",
            compile: function(element) {
                element.addClass("md-closed");
                element.attr("tabIndex", "-1");
                return postLink;
            }
        };
        function postLink(scope, element, attr, sidenavCtrl) {
            var triggeringElement = null;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
                return isLockedOpenParsed(scope.$parent, {
                    $media: $mdMedia
                });
            };
            var backdrop = $compile('<md-backdrop class="md-sidenav-backdrop md-opaque ng-enter">')(scope);
            element.on("$destroy", sidenavCtrl.destroy);
            $mdTheming.inherit(backdrop, element);
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch("isOpen", updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
                if (isLocked === oldValue) {
                    element.toggleClass("md-locked-open", !!isLocked);
                } else {
                    $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
                }
                backdrop.toggleClass("md-locked-open", !!isLocked);
            }
            function updateIsOpen(isOpen) {
                var parent = element.parent();
                parent[isOpen ? "on" : "off"]("keydown", onKeyDown);
                backdrop[isOpen ? "on" : "off"]("click", close);
                if (isOpen) {
                    triggeringElement = $document[0].activeElement;
                }
                return promise = $q.all([ $animate[isOpen ? "enter" : "leave"](backdrop, parent), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed").then(function() {
                    if (scope.isOpen) {
                        element.focus();
                    }
                }) ]);
            }
            function toggleOpen(isOpen) {
                if (scope.isOpen == isOpen) {
                    return $q.when(true);
                } else {
                    var deferred = $q.defer();
                    scope.isOpen = isOpen;
                    $timeout(function() {
                        promise.then(function(result) {
                            if (!scope.isOpen) {
                                triggeringElement && triggeringElement.focus();
                                triggeringElement = null;
                            }
                            deferred.resolve(result);
                        });
                    }, 0, false);
                    return deferred.promise;
                }
            }
            function onKeyDown(ev) {
                var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE;
                return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                return sidenavCtrl.close();
            }
        }
    }
    SidenavDirective.$inject = [ "$timeout", "$animate", "$parse", "$mdMedia", "$mdConstant", "$compile", "$mdTheming", "$q", "$document" ];
    function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
        var self = this;
        self.$toggleOpen = function() {
            return $q.when($scope.isOpen);
        };
        self.isOpen = function() {
            return !!$scope.isOpen;
        };
        self.open = function() {
            return self.$toggleOpen(true);
        };
        self.close = function() {
            return self.$toggleOpen(false);
        };
        self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
        };
        self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
    }
    SidenavController.$inject = [ "$scope", "$element", "$attrs", "$mdComponentRegistry", "$q" ];
})();

(function() {
    "use strict";
    angular.module("material.components.slider", [ "material.core" ]).directive("mdSlider", SliderDirective);
    function SliderDirective($mdTheming) {
        return {
            scope: {},
            require: [ "?ngModel", "mdSlider" ],
            controller: SliderController,
            template: '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + "</div>" + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + "</div>" + '<div class="md-disabled-thumb"></div>' + "</div>",
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            $mdTheming(element);
            var ngModelCtrl = ctrls[0] || {
                $setViewValue: function(val) {
                    this.$viewValue = val;
                    this.$viewChangeListeners.forEach(function(cb) {
                        cb();
                    });
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: []
            };
            var sliderCtrl = ctrls[1];
            sliderCtrl.init(ngModelCtrl);
        }
    }
    SliderDirective.$inject = [ "$mdTheming" ];
    function SliderController($scope, $element, $attrs, $$rAF, $window, $mdAria, $mdUtil, $mdConstant) {
        this.init = function init(ngModelCtrl) {
            var thumb = angular.element($element[0].querySelector(".md-thumb"));
            var thumbText = angular.element($element[0].querySelector(".md-thumb-text"));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element($element[0].querySelector(".md-track-container"));
            var activeTrack = angular.element($element[0].querySelector(".md-track-fill"));
            var tickContainer = angular.element($element[0].querySelector(".md-track-ticks"));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5e3);
            $attrs.min ? $attrs.$observe("min", updateMin) : updateMin(0);
            $attrs.max ? $attrs.$observe("max", updateMax) : updateMax(100);
            $attrs.step ? $attrs.$observe("step", updateStep) : updateStep(1);
            var stopDisabledWatch = angular.noop;
            if ($attrs.ngDisabled) {
                stopDisabledWatch = $scope.$parent.$watch($attrs.ngDisabled, updateAriaDisabled);
            }
            $mdAria.expect($element, "aria-label");
            $element.attr("tabIndex", 0);
            $element.attr("role", "slider");
            $element.on("keydown", keydownListener);
            var hammertime = new Hammer($element[0], {
                recognizers: [ [ Hammer.Pan, {
                    direction: Hammer.DIRECTION_HORIZONTAL
                } ] ]
            });
            hammertime.on("hammer.input", onInput);
            hammertime.on("panstart", onPanStart);
            hammertime.on("pan", onPan);
            hammertime.on("panend", onPanEnd);
            function updateAll() {
                refreshSliderDimensions();
                ngModelRender();
                redrawTicks();
            }
            setTimeout(updateAll);
            var debouncedUpdateAll = $$rAF.debounce(updateAll);
            angular.element($window).on("resize", debouncedUpdateAll);
            $scope.$on("$destroy", function() {
                angular.element($window).off("resize", debouncedUpdateAll);
                hammertime.destroy();
                stopDisabledWatch();
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            function updateMin(value) {
                min = parseFloat(value);
                $element.attr("aria-valuemin", value);
                updateAll();
            }
            function updateMax(value) {
                max = parseFloat(value);
                $element.attr("aria-valuemax", value);
                updateAll();
            }
            function updateStep(value) {
                step = parseFloat(value);
                redrawTicks();
            }
            function updateAriaDisabled(isDisabled) {
                $element.attr("aria-disabled", !!isDisabled);
            }
            var tickCanvas, tickCtx;
            function redrawTicks() {
                if (!angular.isDefined($attrs.mdDiscrete)) return;
                var numSteps = Math.floor((max - min) / step);
                if (!tickCanvas) {
                    var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                    tickCanvas = angular.element('<canvas style="position:absolute;">');
                    tickCtx = tickCanvas[0].getContext("2d");
                    tickCtx.fillStyle = trackTicksStyle.backgroundColor || "black";
                    tickContainer.append(tickCanvas);
                }
                var dimensions = getSliderDimensions();
                tickCanvas[0].width = dimensions.width;
                tickCanvas[0].height = dimensions.height;
                var distance;
                for (var i = 0; i <= numSteps; i++) {
                    distance = Math.floor(dimensions.width * (i / numSteps));
                    tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
                }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
                sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
                throttledRefreshDimensions();
                return sliderDimensions;
            }
            function keydownListener(ev) {
                if ($element[0].hasAttribute("disabled")) {
                    return;
                }
                var changeAmount;
                if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                    changeAmount = -step;
                } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                    changeAmount = step;
                }
                if (changeAmount) {
                    if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                        changeAmount *= 4;
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                    $scope.$evalAsync(function() {
                        setModelValue(ngModelCtrl.$viewValue + changeAmount);
                    });
                }
            }
            function setModelValue(value) {
                ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
                if (isNaN(ngModelCtrl.$viewValue)) {
                    ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
                }
                var percent = (ngModelCtrl.$viewValue - min) / (max - min);
                $scope.modelValue = ngModelCtrl.$viewValue;
                $element.attr("aria-valuenow", ngModelCtrl.$viewValue);
                setSliderPercent(percent);
                thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value) {
                if (angular.isNumber(value)) {
                    return Math.max(min, Math.min(max, value));
                }
            }
            function stepValidator(value) {
                if (angular.isNumber(value)) {
                    return Math.round(value / step) * step;
                }
            }
            function setSliderPercent(percent) {
                activeTrack.css("width", percent * 100 + "%");
                thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + getSliderDimensions().width * percent + "px,0,0)");
                $element.toggleClass("md-min", percent === 0);
            }
            var isSliding = false;
            var isDiscrete = angular.isDefined($attrs.mdDiscrete);
            function onInput(ev) {
                if (!isSliding && ev.eventType === Hammer.INPUT_START && !$element[0].hasAttribute("disabled")) {
                    isSliding = true;
                    $element.addClass("active");
                    $element[0].focus();
                    refreshSliderDimensions();
                    onPan(ev);
                    ev.srcEvent.stopPropagation();
                } else if (isSliding && ev.eventType === Hammer.INPUT_END) {
                    if (isSliding && isDiscrete) onPanEnd(ev);
                    isSliding = false;
                    $element.removeClass("panning active");
                }
            }
            function onPanStart() {
                if (!isSliding) return;
                $element.addClass("panning");
            }
            function onPan(ev) {
                if (!isSliding) return;
                if (isDiscrete) adjustThumbPosition(ev.center.x); else doSlide(ev.center.x);
                ev.preventDefault();
                ev.srcEvent.stopPropagation();
            }
            function onPanEnd(ev) {
                if (isDiscrete && !$element[0].hasAttribute("disabled")) {
                    var exactVal = percentToValue(positionToPercent(ev.center.x));
                    var closestVal = minMaxValidator(stepValidator(exactVal));
                    setSliderPercent(valueToPercent(closestVal));
                    $$rAF(function() {
                        setModelValue(closestVal);
                    });
                    ev.preventDefault();
                    ev.srcEvent.stopPropagation();
                }
            }
            this._onInput = onInput;
            this._onPanStart = onPanStart;
            this._onPan = onPan;
            function doSlide(x) {
                $scope.$evalAsync(function() {
                    setModelValue(percentToValue(positionToPercent(x)));
                });
            }
            function adjustThumbPosition(x) {
                var exactVal = percentToValue(positionToPercent(x));
                var closestVal = minMaxValidator(stepValidator(exactVal));
                setSliderPercent(positionToPercent(x));
                thumbText.text(closestVal);
            }
            function positionToPercent(x) {
                return Math.max(0, Math.min(1, (x - sliderDimensions.left) / sliderDimensions.width));
            }
            function percentToValue(percent) {
                return min + percent * (max - min);
            }
            function valueToPercent(val) {
                return (val - min) / (max - min);
            }
        };
    }
    SliderController.$inject = [ "$scope", "$element", "$attrs", "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant" ];
})();

(function() {
    "use strict";
    angular.module("material.components.sticky", [ "material.core", "material.components.content" ]).factory("$mdSticky", MdSticky);
    function MdSticky($document, $mdConstant, $compile, $$rAF, $mdUtil) {
        var browserStickySupport = checkStickySupport();
        return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller("mdContent");
            if (!contentCtrl) return;
            if (browserStickySupport) {
                element.css({
                    position: browserStickySupport,
                    top: 0,
                    "z-index": 2
                });
            } else {
                var $$sticky = contentCtrl.$element.data("$$sticky");
                if (!$$sticky) {
                    $$sticky = setupSticky(contentCtrl);
                    contentCtrl.$element.data("$$sticky", $$sticky);
                }
                var deregister = $$sticky.add(element, stickyClone || element.clone());
                scope.$on("$destroy", deregister);
            }
        };
        function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.debounce(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on("$scrollstart", debouncedRefreshElements);
            contentEl.on("$scroll", onScroll);
            var self;
            return self = {
                prev: null,
                current: null,
                next: null,
                items: [],
                add: add,
                refreshElements: refreshElements
            };
            function add(element, stickyClone) {
                stickyClone.addClass("md-sticky-clone");
                var item = {
                    element: element,
                    clone: stickyClone
                };
                self.items.push(item);
                contentEl.parent().prepend(item.clone);
                debouncedRefreshElements();
                return function remove() {
                    self.items.forEach(function(item, index) {
                        if (item.element[0] === element[0]) {
                            self.items.splice(index, 1);
                            item.clone.remove();
                        }
                    });
                    debouncedRefreshElements();
                };
            }
            function refreshElements() {
                self.items.forEach(refreshPosition);
                self.items = self.items.sort(function(a, b) {
                    return a.top < b.top ? -1 : 1;
                });
                var item;
                var currentScrollTop = contentEl.prop("scrollTop");
                for (var i = self.items.length - 1; i >= 0; i--) {
                    if (currentScrollTop > self.items[i].top) {
                        item = self.items[i];
                        break;
                    }
                }
                setCurrentItem(item);
            }
            function refreshPosition(item) {
                var current = item.element[0];
                item.top = 0;
                item.left = 0;
                while (current && current !== contentEl[0]) {
                    item.top += current.offsetTop;
                    item.left += current.offsetLeft;
                    current = current.offsetParent;
                }
                item.height = item.element.prop("offsetHeight");
                item.clone.css("margin-left", item.left + "px");
            }
            function onScroll() {
                var scrollTop = contentEl.prop("scrollTop");
                var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
                onScroll.prevScrollTop = scrollTop;
                if (scrollTop === 0) {
                    setCurrentItem(null);
                } else if (isScrollingDown && self.next) {
                    if (self.next.top - scrollTop <= 0) {
                        setCurrentItem(self.next);
                    } else if (self.current) {
                        if (self.next.top - scrollTop <= self.next.height) {
                            translate(self.current, self.next.top - self.next.height - scrollTop);
                        } else {
                            translate(self.current, null);
                        }
                    }
                } else if (!isScrollingDown && self.current) {
                    if (scrollTop < self.current.top) {
                        setCurrentItem(self.prev);
                    }
                    if (self.current && self.next) {
                        if (scrollTop >= self.next.top - self.current.height) {
                            translate(self.current, self.next.top - scrollTop - self.current.height);
                        } else {
                            translate(self.current, null);
                        }
                    }
                }
            }
            function setCurrentItem(item) {
                if (self.current === item) return;
                if (self.current) {
                    translate(self.current, null);
                    setStickyState(self.current, null);
                }
                if (item) {
                    setStickyState(item, "active");
                }
                self.current = item;
                var index = self.items.indexOf(item);
                self.next = self.items[index + 1];
                self.prev = self.items[index - 1];
                setStickyState(self.next, "next");
                setStickyState(self.prev, "prev");
            }
            function setStickyState(item, state) {
                if (!item || item.state === state) return;
                if (item.state) {
                    item.clone.attr("sticky-prev-state", item.state);
                    item.element.attr("sticky-prev-state", item.state);
                }
                item.clone.attr("sticky-state", state);
                item.element.attr("sticky-state", state);
                item.state = state;
            }
            function translate(item, amount) {
                if (!item) return;
                if (amount === null || amount === undefined) {
                    if (item.translateY) {
                        item.translateY = null;
                        item.clone.css($mdConstant.CSS.TRANSFORM, "");
                    }
                } else {
                    item.translateY = amount;
                    item.clone.css($mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)");
                }
            }
        }
        function checkStickySupport($el) {
            var stickyProp;
            var testEl = angular.element("<div>");
            $document[0].body.appendChild(testEl[0]);
            var stickyProps = [ "sticky", "-webkit-sticky" ];
            for (var i = 0; i < stickyProps.length; ++i) {
                testEl.css({
                    position: stickyProps[i],
                    top: 0,
                    "z-index": 2
                });
                if (testEl.css("position") == stickyProps[i]) {
                    stickyProp = stickyProps[i];
                    break;
                }
            }
            testEl.remove();
            return stickyProp;
        }
        function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on("scroll touchmove", function() {
                if (!isScrolling) {
                    isScrolling = true;
                    $$rAF(loopScrollEvent);
                    element.triggerHandler("$scrollstart");
                }
                element.triggerHandler("$scroll");
                lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
                if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                    isScrolling = false;
                    element.triggerHandler("$scrollend");
                } else {
                    element.triggerHandler("$scroll");
                    $$rAF(loopScrollEvent);
                }
            }
        }
    }
    MdSticky.$inject = [ "$document", "$mdConstant", "$compile", "$$rAF", "$mdUtil" ];
})();

(function() {
    "use strict";
    angular.module("material.components.subheader", [ "material.core", "material.components.sticky" ]).directive("mdSubheader", MdSubheaderDirective);
    function MdSubheaderDirective($mdSticky, $compile, $mdTheming) {
        return {
            restrict: "E",
            replace: true,
            transclude: true,
            template: '<h2 class="md-subheader">' + '<span class="md-subheader-content"></span>' + "</h2>",
            compile: function(element, attr, transclude) {
                var outerHTML = element[0].outerHTML;
                return function postLink(scope, element, attr) {
                    $mdTheming(element);
                    function getContent(el) {
                        return angular.element(el[0].querySelector(".md-subheader-content"));
                    }
                    transclude(scope, function(clone) {
                        getContent(element).append(clone);
                    });
                    transclude(scope, function(clone) {
                        var stickyClone = $compile(angular.element(outerHTML))(scope);
                        $mdTheming(stickyClone);
                        getContent(stickyClone).append(clone);
                        $mdSticky(scope, element, stickyClone);
                    });
                };
            }
        };
    }
    MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.swipe", []).factory("$mdSwipe", MdSwipeFactory).directive("mdSwipeLeft", MdSwipeLeftDirective).directive("mdSwipeRight", MdSwipeRightDirective);
    function MdSwipeFactory() {
        var attachNoop = function() {
            return angular.noop;
        };
        return function SwipeService(scope, eventTypes) {
            if (!eventTypes) eventTypes = "swipeleft swiperight";
            return function configureFor(element, onSwipeCallback, attachLater) {
                var hammertime = new Hammer(element[0], {
                    recognizers: addRecognizers([], eventTypes)
                });
                if (!attachLater) attachSwipe();
                scope.$on("$destroy", function() {
                    hammertime.destroy();
                });
                return attachSwipe;
                function swipeHandler(ev) {
                    ev.srcEvent.stopPropagation();
                    if (angular.isFunction(onSwipeCallback)) {
                        scope.$apply(function() {
                            onSwipeCallback(ev);
                        });
                    }
                }
                function attachSwipe() {
                    hammertime.on(eventTypes, swipeHandler);
                    return function detachSwipe() {
                        hammertime.off(eventTypes);
                    };
                }
                function addRecognizers(list, events) {
                    var hasPanning = events.indexOf("pan") > -1;
                    var hasSwipe = events.indexOf("swipe") > -1;
                    if (hasPanning) {
                        list.push([ Hammer.Pan, {
                            direction: Hammer.DIRECTION_HORIZONTAL
                        } ]);
                    }
                    if (hasSwipe) {
                        list.push([ Hammer.Swipe, {
                            direction: Hammer.DIRECTION_HORIZONTAL
                        } ]);
                    }
                    return list;
                }
            };
        };
    }
    function MdSwipeLeftDirective($parse, $mdSwipe) {
        return {
            restrict: "A",
            link: swipePostLink($parse, $mdSwipe, "SwipeLeft")
        };
    }
    MdSwipeLeftDirective.$inject = [ "$parse", "$mdSwipe" ];
    function MdSwipeRightDirective($parse, $mdSwipe) {
        return {
            restrict: "A",
            link: swipePostLink($parse, $mdSwipe, "SwipeRight")
        };
    }
    MdSwipeRightDirective.$inject = [ "$parse", "$mdSwipe" ];
    function swipePostLink($parse, $mdSwipe, name) {
        return function(scope, element, attrs) {
            var direction = name.toLowerCase();
            var directiveName = "md" + name;
            var parentGetter = $parse(attrs[directiveName]) || angular.noop;
            var configureSwipe = $mdSwipe(scope, direction);
            var requestSwipe = function(locals) {
                parentGetter(scope, locals);
            };
            configureSwipe(element, function onHandleSwipe(ev) {
                if (ev.type == direction) {
                    requestSwipe();
                }
            });
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.switch", [ "material.core", "material.components.checkbox" ]).directive("mdSwitch", MdSwitch);
    function MdSwitch(mdCheckboxDirective, $mdTheming, $mdUtil, $document, $mdConstant, $parse, $$rAF) {
        var checkboxDirective = mdCheckboxDirective[0];
        return {
            restrict: "E",
            transclude: true,
            template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + "</div>" + "</div>" + '<div ng-transclude class="md-label">' + "</div>",
            require: "?ngModel",
            compile: compile
        };
        function compile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass("md-dragging");
            return function(scope, element, attr, ngModel) {
                ngModel = ngModel || $mdUtil.fakeNgModel();
                var disabledGetter = $parse(attr.ngDisabled);
                var thumbContainer = angular.element(element[0].querySelector(".md-thumb-container"));
                var switchContainer = angular.element(element[0].querySelector(".md-container"));
                $$rAF(function() {
                    element.removeClass("md-dragging");
                });
                attr.mdNoClick = true;
                checkboxLink(scope, element, attr, ngModel);
                $mdUtil.attachDragBehavior(scope, switchContainer);
                switchContainer.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                function onDragStart(ev, drag) {
                    if (disabledGetter(scope)) return ev.preventDefault();
                    drag.width = thumbContainer.prop("offsetWidth");
                    element.addClass("md-dragging");
                }
                function onDrag(ev, drag) {
                    var percent = drag.distance / drag.width;
                    var translate = ngModel.$viewValue ? 1 - percent : -percent;
                    translate = Math.max(0, Math.min(1, translate));
                    thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)");
                    drag.translate = translate;
                }
                function onDragEnd(ev, drag) {
                    if (disabledGetter(scope)) return false;
                    element.removeClass("md-dragging");
                    thumbContainer.css($mdConstant.CSS.TRANSFORM, "");
                    var isChanged = Math.abs(drag.distance || 0) < 2 || (ngModel.$viewValue ? drag.translate < .5 : drag.translate > .5);
                    if (isChanged) {
                        scope.$apply(function() {
                            ngModel.$setViewValue(!ngModel.$viewValue);
                            ngModel.$render();
                        });
                    }
                }
            };
        }
    }
    MdSwitch.$inject = [ "mdCheckboxDirective", "$mdTheming", "$mdUtil", "$document", "$mdConstant", "$parse", "$$rAF" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs", [ "material.core" ]);
})();

(function() {
    "use strict";
    angular.module("material.components.textField", [ "material.core" ]).directive("mdInputGroup", mdInputGroupDirective).directive("mdInput", mdInputDirective).directive("mdTextFloat", mdTextFloatDirective);
    function mdTextFloatDirective($mdTheming, $mdUtil, $parse, $log) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                fid: "@?mdFid",
                label: "@?",
                value: "=ngModel"
            },
            compile: function(element, attr) {
                $log.warn("<md-text-float> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                if (angular.isUndefined(attr.mdFid)) {
                    attr.mdFid = $mdUtil.nextUid();
                }
                return {
                    pre: function(scope, element, attrs) {
                        var disabledParsed = $parse(attrs.ngDisabled);
                        scope.isDisabled = function() {
                            return disabledParsed(scope.$parent);
                        };
                        scope.inputType = attrs.type || "text";
                    },
                    post: $mdTheming
                };
            },
            template: '<md-input-group tabindex="-1">' + ' <label for="{{fid}}" >{{label}}</label>' + ' <md-input id="{{fid}}" ng-disabled="isDisabled()" ng-model="value" type="{{inputType}}"></md-input>' + "</md-input-group>"
        };
    }
    mdTextFloatDirective.$inject = [ "$mdTheming", "$mdUtil", "$parse", "$log" ];
    function mdInputGroupDirective($log) {
        return {
            restrict: "CE",
            controller: [ "$element", function($element) {
                $log.warn("<md-input-group> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                this.setFocused = function(isFocused) {
                    $element.toggleClass("md-input-focused", !!isFocused);
                };
                this.setHasValue = function(hasValue) {
                    $element.toggleClass("md-input-has-value", hasValue);
                };
            } ]
        };
    }
    mdInputGroupDirective.$inject = [ "$log" ];
    function mdInputDirective($mdUtil, $log) {
        return {
            restrict: "E",
            replace: true,
            template: "<input >",
            require: [ "^?mdInputGroup", "?ngModel" ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[0]) return;
                $log.warn("<md-input> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                var inputGroupCtrl = ctrls[0];
                var ngModelCtrl = ctrls[1];
                scope.$watch(scope.isDisabled, function(isDisabled) {
                    element.attr("aria-disabled", !!isDisabled);
                    element.attr("tabindex", !!isDisabled);
                });
                element.attr("type", attr.type || element.parent().attr("type") || "text");
                if (ngModelCtrl) {
                    ngModelCtrl.$formatters.push(function(value) {
                        inputGroupCtrl.setHasValue(isNotEmpty(value));
                        return value;
                    });
                }
                element.on("input", function() {
                    inputGroupCtrl.setHasValue(isNotEmpty());
                }).on("focus", function(e) {
                    inputGroupCtrl.setFocused(true);
                }).on("blur", function(e) {
                    inputGroupCtrl.setFocused(false);
                    inputGroupCtrl.setHasValue(isNotEmpty());
                });
                scope.$on("$destroy", function() {
                    inputGroupCtrl.setFocused(false);
                    inputGroupCtrl.setHasValue(false);
                });
                function isNotEmpty(value) {
                    value = angular.isUndefined(value) ? element.val() : value;
                    return angular.isDefined(value) && value !== null && value.toString().trim() !== "";
                }
            }
        };
    }
    mdInputDirective.$inject = [ "$mdUtil", "$log" ];
})();

(function() {
    "use strict";
    angular.module("material.components.toast", [ "material.core", "material.components.swipe", "material.components.button" ]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);
    function MdToastDirective() {
        return {
            restrict: "E"
        };
    }
    function MdToastProvider($$interimElementProvider) {
        toastDefaultOptions.$inject = [ "$timeout", "$animate", "$mdSwipe", "$mdTheming", "$mdToast" ];
        return $$interimElementProvider("$mdToast").setDefaults({
            methods: [ "position", "hideDelay", "capsule" ],
            options: toastDefaultOptions
        }).addPreset("simple", {
            argOption: "content",
            methods: [ "content", "action", "highlightAction" ],
            options: [ "$mdToast", function($mdToast) {
                return {
                    template: [ "<md-toast ng-class=\"{'md-capsule': toast.capsule}\">", "<span flex>{{ toast.content }}</span>", '<md-button ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-action\': toast.highlightAction}">', "{{ toast.action }}", "</md-button>", "</md-toast>" ].join(""),
                    controller: function mdToastCtrl() {
                        this.resolve = function() {
                            $mdToast.hide();
                        };
                    },
                    controllerAs: "toast",
                    bindToController: true
                };
            } ]
        });
        function toastDefaultOptions($timeout, $animate, $mdSwipe, $mdTheming, $mdToast) {
            return {
                onShow: onShow,
                onRemove: onRemove,
                position: "bottom left",
                themable: true,
                hideDelay: 3e3
            };
            function onShow(scope, element, options) {
                element.addClass(options.position.split(" ").map(function(pos) {
                    return "md-" + pos;
                }).join(" "));
                options.parent.addClass(toastOpenClass(options.position));
                var configureSwipe = $mdSwipe(scope, "swipeleft swiperight");
                options.detachSwipe = configureSwipe(element, function(ev) {
                    element.addClass("md-" + ev.type);
                    $timeout($mdToast.cancel);
                });
                return $animate.enter(element, options.parent);
            }
            function onRemove(scope, element, options) {
                options.detachSwipe();
                options.parent.removeClass(toastOpenClass(options.position));
                return $animate.leave(element);
            }
            function toastOpenClass(position) {
                return "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom");
            }
        }
    }
    MdToastProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.toolbar", [ "material.core", "material.components.content" ]).directive("mdToolbar", mdToolbarDirective);
    function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming) {
        return {
            restrict: "E",
            controller: angular.noop,
            link: function(scope, element, attr) {
                $mdTheming(element);
                if (angular.isDefined(attr.mdScrollShrink)) {
                    setupScrollShrink();
                }
                function setupScrollShrink() {
                    var y = 0;
                    var prevScrollTop = 0;
                    var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5;
                    var toolbarHeight;
                    var contentElement;
                    var debouncedContentScroll = $$rAF.debounce(onContentScroll);
                    var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1e3);
                    scope.$on("$mdContentLoaded", onMdContentLoad);
                    function onMdContentLoad($event, newContentEl) {
                        if (element.parent()[0] === newContentEl.parent()[0]) {
                            if (contentElement) {
                                contentElement.off("scroll", debouncedContentScroll);
                            }
                            newContentEl.on("scroll", debouncedContentScroll);
                            newContentEl.attr("scroll-shrink", "true");
                            contentElement = newContentEl;
                            $$rAF(updateToolbarHeight);
                        }
                    }
                    function updateToolbarHeight() {
                        toolbarHeight = element.prop("offsetHeight");
                        contentElement.css("margin-top", -toolbarHeight * shrinkSpeedFactor + "px");
                        onContentScroll();
                    }
                    function onContentScroll(e) {
                        var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                        debouncedUpdateHeight();
                        y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                        element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + -y * shrinkSpeedFactor + "px,0)");
                        contentElement.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (toolbarHeight - y) * shrinkSpeedFactor + "px,0)");
                        prevScrollTop = scrollTop;
                    }
                }
            }
        };
    }
    mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tooltip", [ "material.core" ]).directive("mdTooltip", MdTooltipDirective);
    function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement) {
        var TOOLTIP_SHOW_DELAY = 400;
        var TOOLTIP_WINDOW_EDGE_SPACE = 8;
        return {
            restrict: "E",
            transclude: true,
            template: '<div class="md-background"></div>' + '<div class="md-content" ng-transclude></div>',
            scope: {
                visible: "=?mdVisible",
                delay: "=?mdDelay"
            },
            link: postLink
        };
        function postLink(scope, element, attr, contentCtrl) {
            $mdTheming(element);
            var parent = element.parent();
            var current = element.parent()[0];
            while (current && current !== $rootElement[0] && current !== document.body) {
                if (current.tagName && current.tagName.toLowerCase() == "md-content") break;
                current = current.parentNode;
            }
            var tooltipParent = angular.element(current || document.body);
            if (!angular.isDefined(attr.mdDelay)) {
                scope.delay = TOOLTIP_SHOW_DELAY;
            }
            element.detach();
            element.attr("role", "tooltip");
            element.attr("id", attr.id || "tooltip_" + $mdUtil.nextUid());
            parent.on("focus mouseenter touchstart", function() {
                setVisible(true);
            });
            parent.on("blur mouseleave touchend touchcancel", function() {
                if ($document[0].activeElement === parent[0]) return;
                setVisible(false);
            });
            scope.$watch("visible", function(isVisible) {
                if (isVisible) showTooltip(); else hideTooltip();
            });
            var debouncedOnResize = $$rAF.debounce(function windowResize() {
                if (scope.visible) positionTooltip();
            });
            angular.element($window).on("resize", debouncedOnResize);
            scope.$on("$destroy", function() {
                scope.visible = false;
                element.remove();
                angular.element($window).off("resize", debouncedOnResize);
            });
            function setVisible(value) {
                setVisible.value = !!value;
                if (!setVisible.queued) {
                    if (value) {
                        setVisible.queued = true;
                        $timeout(function() {
                            scope.visible = setVisible.value;
                            setVisible.queued = false;
                        }, scope.delay);
                    } else {
                        $timeout(function() {
                            scope.visible = false;
                        });
                    }
                }
            }
            function showTooltip() {
                element.removeClass("md-hide");
                parent.attr("aria-describedby", element.attr("id"));
                tooltipParent.append(element);
                positionTooltip();
                $$rAF(function() {
                    $$rAF(function() {
                        positionTooltip();
                        if (!scope.visible) return;
                        element.addClass("md-show");
                    });
                });
            }
            function hideTooltip() {
                element.removeClass("md-show").addClass("md-hide");
                parent.removeAttr("aria-describedby");
                $timeout(function() {
                    if (scope.visible) return;
                    element.detach();
                }, 200, false);
            }
            function positionTooltip() {
                var tipRect = $mdUtil.elementRect(element, tooltipParent);
                var parentRect = $mdUtil.elementRect(parent, tooltipParent);
                var tipDirection = "bottom";
                var newPosition = {
                    left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                    top: parentRect.top + parentRect.height
                };
                newPosition.left = Math.min(newPosition.left, tooltipParent.prop("scrollWidth") - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                if (newPosition.top + tipRect.height > tooltipParent.prop("scrollHeight")) {
                    newPosition.top = parentRect.top - tipRect.height;
                    tipDirection = "top";
                }
                element.css({
                    top: newPosition.top + "px",
                    left: newPosition.left + "px"
                });
                element.attr("width-32", Math.ceil(tipRect.width / 32));
                element.attr("md-direction", tipDirection);
            }
        }
    }
    MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement" ];
})();

(function() {
    "use strict";
    angular.module("material.components.whiteframe", []);
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabsInkBar", MdTabInkDirective);
    function MdTabInkDirective($$rAF) {
        var lastIndex = 0;
        return {
            restrict: "E",
            require: [ "^?mdNoBar", "^mdTabs" ],
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            if (ctrls[0]) return;
            var tabsCtrl = ctrls[1], debouncedUpdateBar = $$rAF.debounce(updateBar);
            tabsCtrl.inkBarElement = element;
            scope.$on("$mdTabsPaginationChanged", debouncedUpdateBar);
            function updateBar() {
                var selected = tabsCtrl.getSelectedItem();
                var hideInkBar = !selected || tabsCtrl.count() < 2;
                element.css("display", hideInkBar ? "none" : "block");
                if (hideInkBar) return;
                if (scope.pagination && scope.pagination.tabData) {
                    var index = tabsCtrl.getSelectedIndex();
                    var data = scope.pagination.tabData.tabs[index] || {
                        left: 0,
                        right: 0,
                        width: 0
                    };
                    var right = element.parent().prop("offsetWidth") - data.right;
                    var classNames = [ "md-transition-left", "md-transition-right", "md-no-transition" ];
                    var classIndex = lastIndex > index ? 0 : lastIndex < index ? 1 : 2;
                    element.removeClass(classNames.join(" ")).addClass(classNames[classIndex]).css({
                        left: data.left + 1 + "px",
                        right: right + "px"
                    });
                    lastIndex = index;
                }
            }
        }
    }
    MdTabInkDirective.$inject = [ "$$rAF" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabsPagination", TabPaginationDirective);
    function TabPaginationDirective($mdConstant, $window, $$rAF, $$q, $timeout, $mdMedia) {
        var PAGINATORS_WIDTH = 8 * 4 * 2;
        return {
            restrict: "A",
            require: "^mdTabs",
            link: postLink
        };
        function postLink(scope, element, attr, tabsCtrl) {
            var tabs = element[0].getElementsByTagName("md-tab");
            var debouncedUpdatePagination = $$rAF.debounce(updatePagination);
            var tabsParent = element.children();
            var state = scope.pagination = {
                page: -1,
                active: false,
                clickNext: function() {
                    userChangePage(+1);
                },
                clickPrevious: function() {
                    userChangePage(-1);
                }
            };
            scope.$on("$mdTabsChanged", debouncedUpdatePagination);
            angular.element($window).on("resize", debouncedUpdatePagination);
            scope.$on("$destroy", function() {
                angular.element($window).off("resize", debouncedUpdatePagination);
            });
            scope.$watch(function() {
                return tabsCtrl.tabToFocus;
            }, onTabFocus);
            function onTabFocus(tab, oldTab) {
                if (!tab) return;
                var pageIndex = getPageForTab(tab);
                if (!state.active || pageIndex === state.page) {
                    tab.element.focus();
                } else {
                    oldTab && oldTab.element.blur();
                    setPage(pageIndex).then(function() {
                        tab.element.focus();
                    });
                }
            }
            function userChangePage(increment) {
                var sizeData = state.tabData;
                var newPage = Math.max(0, Math.min(sizeData.pages.length - 1, state.page + increment));
                var newTabIndex = sizeData.pages[newPage][increment > 0 ? "firstTabIndex" : "lastTabIndex"];
                var newTab = tabsCtrl.itemAt(newTabIndex);
                onTabFocus(newTab);
            }
            function updatePagination() {
                if (!element.prop("offsetParent")) {
                    var watcher = waitForVisible();
                    return;
                }
                var tabs = element.find("md-tab");
                disablePagination();
                var sizeData = state.tabData = calculateTabData();
                var needPagination = state.active = sizeData.pages.length > 1;
                if (needPagination) {
                    enablePagination();
                }
                scope.$evalAsync(function() {
                    scope.$broadcast("$mdTabsPaginationChanged");
                });
                function enablePagination() {
                    tabsParent.css("width", "9999px");
                    angular.forEach(sizeData.tabs, function(tab) {
                        angular.element(tab.element).css("margin-left", tab.filler + "px");
                    });
                    setPage(getPageForTab(tabsCtrl.getSelectedItem()));
                }
                function disablePagination() {
                    slideTabButtons(0);
                    tabsParent.css("width", "");
                    tabs.css("width", "");
                    tabs.css("margin-left", "");
                    state.page = null;
                    state.active = false;
                }
                function waitForVisible() {
                    return watcher || scope.$watch(function() {
                        $timeout(function() {
                            if (element[0].offsetParent) {
                                if (angular.isFunction(watcher)) {
                                    watcher();
                                }
                                debouncedUpdatePagination();
                                watcher = null;
                            }
                        }, 0, false);
                    });
                }
            }
            function slideTabButtons(x) {
                if (tabsCtrl.pagingOffset === x) {
                    return $$q.when();
                }
                var deferred = $$q.defer();
                tabsCtrl.$$pagingOffset = x;
                tabsParent.css($mdConstant.CSS.TRANSFORM, "translate3d(" + x + "px,0,0)");
                tabsParent.on($mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd);
                return deferred.promise;
                function onTabsParentTransitionEnd(ev) {
                    if (ev.target === tabsParent[0]) {
                        tabsParent.off($mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd);
                        deferred.resolve();
                    }
                }
            }
            function shouldStretchTabs() {
                switch (scope.stretchTabs) {
                  case "never":
                    return false;

                  case "always":
                    return true;

                  default:
                    return $mdMedia("sm");
                }
            }
            function calculateTabData(noAdjust) {
                var clientWidth = element.parent().prop("offsetWidth");
                var tabsWidth = clientWidth - PAGINATORS_WIDTH - 1;
                var $tabs = angular.element(tabs);
                var totalWidth = 0;
                var max = 0;
                var tabData = [];
                var pages = [];
                var currentPage;
                $tabs.css("max-width", "");
                angular.forEach(tabs, function(tab, index) {
                    var tabWidth = Math.min(tabsWidth, tab.offsetWidth);
                    var data = {
                        element: tab,
                        left: totalWidth,
                        width: tabWidth,
                        right: totalWidth + tabWidth,
                        filler: 0
                    };
                    data.page = Math.ceil(data.right / (pages.length === 1 && index === tabs.length - 1 ? clientWidth : tabsWidth)) - 1;
                    if (data.page >= pages.length) {
                        data.filler = tabsWidth * data.page - data.left;
                        data.right += data.filler;
                        data.left += data.filler;
                        currentPage = {
                            left: data.left,
                            firstTabIndex: index,
                            lastTabIndex: index,
                            tabs: [ data ]
                        };
                        pages.push(currentPage);
                    } else {
                        currentPage.lastTabIndex = index;
                        currentPage.tabs.push(data);
                    }
                    totalWidth = data.right;
                    max = Math.max(max, tabWidth);
                    tabData.push(data);
                });
                $tabs.css("max-width", tabsWidth + "px");
                if (!noAdjust && shouldStretchTabs()) {
                    return adjustForStretchedTabs();
                } else {
                    return {
                        width: totalWidth,
                        max: max,
                        tabs: tabData,
                        pages: pages,
                        tabElements: tabs
                    };
                }
                function adjustForStretchedTabs() {
                    var canvasWidth = pages.length === 1 ? clientWidth : tabsWidth;
                    var tabsPerPage = Math.min(Math.floor(canvasWidth / max), tabs.length);
                    var tabWidth = Math.floor(canvasWidth / tabsPerPage);
                    $tabs.css("width", tabWidth + "px");
                    return calculateTabData(true);
                }
            }
            function getPageForTab(tab) {
                var tabIndex = tabsCtrl.indexOf(tab);
                if (tabIndex === -1) return 0;
                var sizeData = state.tabData;
                return sizeData ? sizeData.tabs[tabIndex].page : 0;
            }
            function setPage(page) {
                if (page === state.page) return;
                var lastPage = state.tabData.pages.length - 1;
                if (page < 0) page = 0;
                if (page > lastPage) page = lastPage;
                state.hasPrev = page > 0;
                state.hasNext = page < lastPage;
                state.page = page;
                scope.$broadcast("$mdTabsPaginationChanged");
                return slideTabButtons(-state.tabData.pages[page].left);
            }
        }
    }
    TabPaginationDirective.$inject = [ "$mdConstant", "$window", "$$rAF", "$$q", "$timeout", "$mdMedia" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").controller("$mdTab", TabItemController);
    function TabItemController($scope, $element, $attrs, $compile, $animate, $mdUtil, $parse, $timeout) {
        var self = this;
        self.contentContainer = angular.element('<div class="md-tab-content ng-hide">');
        self.hammertime = new Hammer(self.contentContainer[0]);
        self.element = $element;
        self.isDisabled = isDisabled;
        self.onAdd = onAdd;
        self.onRemove = onRemove;
        self.onSelect = onSelect;
        self.onDeselect = onDeselect;
        var disabledParsed = $parse($attrs.ngDisabled);
        function isDisabled() {
            return disabledParsed($scope.$parent);
        }
        function onAdd(contentArea, shouldDisconnectScope) {
            if (self.content.length) {
                self.contentContainer.append(self.content);
                self.contentScope = $scope.$parent.$new();
                contentArea.append(self.contentContainer);
                $compile(self.contentContainer)(self.contentScope);
                if (shouldDisconnectScope === true) {
                    $timeout(function() {
                        $mdUtil.disconnectScope(self.contentScope);
                    }, 0, false);
                }
            }
        }
        function onRemove() {
            self.hammertime.destroy();
            $animate.leave(self.contentContainer).then(function() {
                self.contentScope && self.contentScope.$destroy();
                self.contentScope = null;
            });
        }
        function toggleAnimationClass(rightToLeft) {
            self.contentContainer[rightToLeft ? "addClass" : "removeClass"]("md-transition-rtl");
        }
        function onSelect(rightToLeft) {
            $mdUtil.reconnectScope(self.contentScope);
            self.hammertime.on("swipeleft swiperight", $scope.onSwipe);
            $element.addClass("active");
            $element.attr("aria-selected", true);
            $element.attr("tabIndex", 0);
            toggleAnimationClass(rightToLeft);
            $animate.removeClass(self.contentContainer, "ng-hide");
            $scope.onSelect();
        }
        function onDeselect(rightToLeft) {
            $mdUtil.disconnectScope(self.contentScope);
            self.hammertime.off("swipeleft swiperight", $scope.onSwipe);
            $element.removeClass("active");
            $element.attr("aria-selected", false);
            $element.attr("tabIndex", -1);
            toggleAnimationClass(rightToLeft);
            $animate.addClass(self.contentContainer, "ng-hide");
            $scope.onDeselect();
        }
    }
    TabItemController.$inject = [ "$scope", "$element", "$attrs", "$compile", "$animate", "$mdUtil", "$parse", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTab", MdTabDirective);
    function MdTabDirective($mdInkRipple, $compile, $mdUtil, $mdConstant, $timeout) {
        return {
            restrict: "E",
            require: [ "mdTab", "^mdTabs" ],
            controller: "$mdTab",
            scope: {
                onSelect: "&mdOnSelect",
                onDeselect: "&mdOnDeselect",
                label: "@"
            },
            compile: compile
        };
        function compile(element, attr) {
            var tabLabel = element.find("md-tab-label");
            if (tabLabel.length) {
                tabLabel.remove();
            } else if (angular.isDefined(attr.label)) {
                tabLabel = angular.element("<md-tab-label>").html(attr.label);
            } else {
                tabLabel = angular.element("<md-tab-label>").append(element.contents().remove());
            }
            var tabContent = element.contents().remove();
            return function postLink(scope, element, attr, ctrls) {
                var tabItemCtrl = ctrls[0];
                var tabsCtrl = ctrls[1];
                scope.$watch(function() {
                    return attr.label;
                }, function() {
                    $timeout(function() {
                        tabsCtrl.scope.$broadcast("$mdTabsChanged");
                    }, 0, false);
                });
                transcludeTabContent();
                configureAria();
                var detachRippleFn = $mdInkRipple.attachTabBehavior(scope, element, {
                    colorElement: tabsCtrl.inkBarElement
                });
                tabsCtrl.add(tabItemCtrl);
                scope.$on("$destroy", function() {
                    detachRippleFn();
                    tabsCtrl.remove(tabItemCtrl);
                });
                element.on("$destroy", function() {
                    $timeout(function() {
                        tabsCtrl.scope.$broadcast("$mdTabsChanged");
                    }, 0, false);
                });
                if (!angular.isDefined(attr.ngClick)) {
                    element.on("click", defaultClickListener);
                }
                element.on("keydown", keydownListener);
                scope.onSwipe = onSwipe;
                if (angular.isNumber(scope.$parent.$index)) {
                    watchNgRepeatIndex();
                }
                if (angular.isDefined(attr.mdActive)) {
                    watchActiveAttribute();
                }
                watchDisabled();
                function transcludeTabContent() {
                    var label = tabLabel.clone();
                    element.append(label);
                    $compile(label)(scope.$parent);
                    tabItemCtrl.content = tabContent.clone();
                }
                function defaultClickListener() {
                    scope.$apply(function() {
                        tabsCtrl.select(tabItemCtrl);
                        tabsCtrl.focus(tabItemCtrl);
                    });
                }
                function keydownListener(ev) {
                    if (ev.keyCode == $mdConstant.KEY_CODE.SPACE || ev.keyCode == $mdConstant.KEY_CODE.ENTER) {
                        element.triggerHandler("click");
                        ev.preventDefault();
                    } else if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                        scope.$evalAsync(function() {
                            tabsCtrl.focus(tabsCtrl.previous(tabItemCtrl));
                        });
                    } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                        scope.$evalAsync(function() {
                            tabsCtrl.focus(tabsCtrl.next(tabItemCtrl));
                        });
                    }
                }
                function onSwipe(ev) {
                    scope.$apply(function() {
                        if (ev.type === "swipeleft") {
                            tabsCtrl.select(tabsCtrl.next());
                        } else {
                            tabsCtrl.select(tabsCtrl.previous());
                        }
                    });
                }
                function watchNgRepeatIndex() {
                    scope.$watch("$parent.$index", function $indexWatchAction(newIndex) {
                        tabsCtrl.move(tabItemCtrl, newIndex);
                    });
                }
                function watchActiveAttribute() {
                    var unwatch = scope.$parent.$watch("!!(" + attr.mdActive + ")", activeWatchAction);
                    scope.$on("$destroy", unwatch);
                    function activeWatchAction(isActive) {
                        var isSelected = tabsCtrl.getSelectedItem() === tabItemCtrl;
                        if (isActive && !isSelected) {
                            tabsCtrl.select(tabItemCtrl);
                        } else if (!isActive && isSelected) {
                            tabsCtrl.deselect(tabItemCtrl);
                        }
                    }
                }
                function watchDisabled() {
                    scope.$watch(tabItemCtrl.isDisabled, disabledWatchAction);
                    function disabledWatchAction(isDisabled) {
                        element.attr("aria-disabled", isDisabled);
                        var isSelected = tabsCtrl.getSelectedItem() === tabItemCtrl;
                        if (isSelected && isDisabled) {
                            tabsCtrl.select(tabsCtrl.next() || tabsCtrl.previous());
                        }
                    }
                }
                function configureAria() {
                    var tabId = attr.id || "tab_" + $mdUtil.nextUid();
                    element.attr({
                        id: tabId,
                        role: "tab",
                        tabIndex: -1
                    });
                    if (tabContent.length) {
                        var tabContentId = "content_" + tabId;
                        if (!element.attr("aria-controls")) {
                            element.attr("aria-controls", tabContentId);
                        }
                        tabItemCtrl.contentContainer.attr({
                            id: tabContentId,
                            role: "tabpanel",
                            "aria-labelledby": tabId
                        });
                    }
                }
            };
        }
    }
    MdTabDirective.$inject = [ "$mdInkRipple", "$compile", "$mdUtil", "$mdConstant", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").controller("$mdTabs", MdTabsController);
    function MdTabsController($scope, $element, $mdUtil, $timeout) {
        var tabsList = $mdUtil.iterator([], false);
        var self = this;
        self.$element = $element;
        self.scope = $scope;
        var contentArea = self.contentArea = angular.element($element[0].querySelector(".md-tabs-content"));
        var inRange = self.inRange = tabsList.inRange;
        var indexOf = self.indexOf = tabsList.indexOf;
        var itemAt = self.itemAt = tabsList.itemAt;
        self.count = tabsList.count;
        self.getSelectedItem = getSelectedItem;
        self.getSelectedIndex = getSelectedIndex;
        self.add = add;
        self.remove = remove;
        self.move = move;
        self.select = select;
        self.focus = focus;
        self.deselect = deselect;
        self.next = next;
        self.previous = previous;
        $scope.$on("$destroy", function() {
            deselect(getSelectedItem());
            for (var i = tabsList.count() - 1; i >= 0; i--) {
                remove(tabsList[i], true);
            }
        });
        function getSelectedItem() {
            return itemAt($scope.selectedIndex);
        }
        function getSelectedIndex() {
            return $scope.selectedIndex;
        }
        function add(tab, index) {
            tabsList.add(tab, index);
            if (!angular.isDefined(tab.element.attr("md-active")) && ($scope.selectedIndex === -1 || !angular.isNumber($scope.selectedIndex) || $scope.selectedIndex === self.indexOf(tab))) {
                tab.onAdd(self.contentArea, false);
                self.select(tab);
            } else {
                tab.onAdd(self.contentArea, true);
            }
            $scope.$broadcast("$mdTabsChanged");
        }
        function remove(tab, noReselect) {
            if (!tabsList.contains(tab)) return;
            if (noReselect) return;
            var isSelectedItem = getSelectedItem() === tab, newTab = previous() || next();
            deselect(tab);
            tabsList.remove(tab);
            tab.onRemove();
            $scope.$broadcast("$mdTabsChanged");
            if (isSelectedItem) {
                select(newTab);
            }
        }
        function move(tab, toIndex) {
            var isSelected = getSelectedItem() === tab;
            tabsList.remove(tab);
            tabsList.add(tab, toIndex);
            if (isSelected) select(tab);
            $scope.$broadcast("$mdTabsChanged");
        }
        function select(tab, rightToLeft) {
            if (!tab || tab.isSelected || tab.isDisabled()) return;
            if (!tabsList.contains(tab)) return;
            if (!angular.isDefined(rightToLeft)) {
                rightToLeft = indexOf(tab) < $scope.selectedIndex;
            }
            deselect(getSelectedItem(), rightToLeft);
            $scope.selectedIndex = indexOf(tab);
            tab.isSelected = true;
            tab.onSelect(rightToLeft);
            $scope.$broadcast("$mdTabsChanged");
        }
        function focus(tab) {
            self.tabToFocus = tab;
        }
        function deselect(tab, rightToLeft) {
            if (!tab || !tab.isSelected) return;
            if (!tabsList.contains(tab)) return;
            $scope.selectedIndex = -1;
            tab.isSelected = false;
            tab.onDeselect(rightToLeft);
        }
        function next(tab, filterFn) {
            return tabsList.next(tab || getSelectedItem(), filterFn || isTabEnabled);
        }
        function previous(tab, filterFn) {
            return tabsList.previous(tab || getSelectedItem(), filterFn || isTabEnabled);
        }
        function isTabEnabled(tab) {
            return tab && !tab.isDisabled();
        }
    }
    MdTabsController.$inject = [ "$scope", "$element", "$mdUtil", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabs", TabsDirective);
    function TabsDirective($mdTheming) {
        return {
            restrict: "E",
            controller: "$mdTabs",
            require: "mdTabs",
            transclude: true,
            scope: {
                selectedIndex: "=?mdSelected"
            },
            template: '<section class="md-header" ' + "ng-class=\"{'md-paginating': pagination.active}\">" + '<button class="md-paginator md-prev" ' + 'ng-if="pagination.active && pagination.hasPrev" ' + 'ng-click="pagination.clickPrevious()" ' + 'aria-hidden="true">' + "</button>" + '<div class="md-header-items-container" md-tabs-pagination>' + '<div class="md-header-items">' + "<md-tabs-ink-bar></md-tabs-ink-bar>" + "</div>" + "</div>" + '<button class="md-paginator md-next" ' + 'ng-if="pagination.active && pagination.hasNext" ' + 'ng-click="pagination.clickNext()" ' + 'aria-hidden="true">' + "</button>" + "</section>" + '<section class="md-tabs-content"></section>',
            link: postLink
        };
        function postLink(scope, element, attr, tabsCtrl, transclude) {
            scope.stretchTabs = attr.hasOwnProperty("mdStretchTabs") ? attr.mdStretchTabs || "always" : "auto";
            $mdTheming(element);
            configureAria();
            watchSelected();
            transclude(scope.$parent, function(clone) {
                angular.element(element[0].querySelector(".md-header-items")).append(clone);
            });
            function configureAria() {
                element.attr("role", "tablist");
            }
            function watchSelected() {
                scope.$watch("selectedIndex", function watchSelectedIndex(newIndex, oldIndex) {
                    if (oldIndex == newIndex) return;
                    var rightToLeft = oldIndex > newIndex;
                    tabsCtrl.deselect(tabsCtrl.itemAt(oldIndex), rightToLeft);
                    if (tabsCtrl.inRange(newIndex)) {
                        var newTab = tabsCtrl.itemAt(newIndex);
                        while (newTab && newTab.isDisabled()) {
                            newTab = newIndex > oldIndex ? tabsCtrl.next(newTab) : tabsCtrl.previous(newTab);
                        }
                        tabsCtrl.select(newTab, rightToLeft);
                    }
                });
            }
        }
    }
    TabsDirective.$inject = [ "$mdTheming" ];
})();

angular.module("material.core").constant("$MD_THEME_CSS", "md-backdrop.md-opaque.md-THEME_NAME-theme {  background-color: '{{foreground-4-0.5}}';  position: absolute; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }.md-button.md-THEME_NAME-theme {  border-radius: 3px; }  .md-button.md-THEME_NAME-theme:not([disabled]):hover, .md-button.md-THEME_NAME-theme:not([disabled]):focus {    background-color: '{{background-500-0.2}}'; }  .md-button.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {      color: '{{primary-contrast}}';      background-color: '{{primary-color}}'; }      .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):focus {        background-color: '{{primary-600}}'; }  .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%; }  .md-button.md-THEME_NAME-theme.md-raised, .md-button.md-THEME_NAME-theme.md-fab {    color: '{{background-contrast}}';    background-color: '{{background-500-0.185}}'; }    .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):focus {      background-color: '{{background-500-0.3}}'; }  .md-button.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {      color: '{{warn-contrast}}';      background-color: '{{warn-color}}'; }      .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):focus {        background-color: '{{warn-700}}'; }  .md-button.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {      color: '{{accent-contrast}}';      background-color: '{{accent-color}}'; }      .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):focus {        background-color: '{{accent-700}}'; }  .md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {    color: '{{foreground-3}}';    background-color: transparent;    cursor: not-allowed; }md-card.md-THEME_NAME-theme {  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-accent .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-accent.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-accent .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-accent.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-accent.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-content.md-THEME_NAME-theme {  background-color: '{{background-hue-3}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-hue-3}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme label {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, '{{foreground-4}}' 0%, '{{foreground-4}}' 33%, transparent 0%); }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient('{{warn-100}}' 0%, '{{warn-100}}' 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient('{{accent-100}}' 0%, '{{accent-100}}' 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-accent .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-accent.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-accent.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-accent .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {  border-color: '{{foreground-3}}'; }md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {  border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme:focus:not(:empty) {  border-color: '{{foreground-1}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  border-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-accent .md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme.md-accent .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme.md-accent .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme.md-accent .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme.md-accent .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-hue-3}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-accent .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-accent .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-switch.md-THEME_NAME-theme:focus .md-label:not(:empty) {  border-color: '{{foreground-1}}';  border-style: dotted; }md-tabs.md-THEME_NAME-theme .md-header {  background-color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent .md-header {  background-color: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tab:not([disabled]) {  color: '{{accent-100}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab:not([disabled]).active {    color: '{{accent-contrast}}'; }md-tabs.md-THEME_NAME-theme.md-warn .md-header {  background-color: '{{warn-color}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tab:not([disabled]) {  color: '{{warn-100}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab:not([disabled]).active {    color: '{{warn-contrast}}'; }md-tabs.md-THEME_NAME-theme md-tabs-ink-bar {  color: '{{primary-contrast}}';  background: '{{primary-contrast}}'; }md-tabs.md-THEME_NAME-theme md-tab {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme md-tab.active {    color: '{{primary-contrast}}'; }  md-tabs.md-THEME_NAME-theme md-tab[disabled] {    color: '{{foreground-4}}'; }  md-tabs.md-THEME_NAME-theme md-tab:focus {    color: '{{primary-contrast}}';    background-color: '{{primary-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme md-tab .md-ripple-container {    color: '{{primary-contrast}}'; }md-input-group.md-THEME_NAME-theme input, md-input-group.md-THEME_NAME-theme textarea {  text-shadow: '{{foreground-shadow}}'; }  md-input-group.md-THEME_NAME-theme input::-webkit-input-placeholder, md-input-group.md-THEME_NAME-theme input::-moz-placeholder, md-input-group.md-THEME_NAME-theme input:-moz-placeholder, md-input-group.md-THEME_NAME-theme input:-ms-input-placeholder, md-input-group.md-THEME_NAME-theme textarea::-webkit-input-placeholder, md-input-group.md-THEME_NAME-theme textarea::-moz-placeholder, md-input-group.md-THEME_NAME-theme textarea:-moz-placeholder, md-input-group.md-THEME_NAME-theme textarea:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-group.md-THEME_NAME-theme label {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-group.md-THEME_NAME-theme input, md-input-group.md-THEME_NAME-theme textarea {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused input, md-input-group.md-THEME_NAME-theme.md-input-focused textarea {  border-color: '{{primary-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused label {  color: '{{primary-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent input, md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent textarea {  border-color: '{{accent-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-has-value:not(.md-input-focused) label {  color: '{{foreground-2}}'; }md-input-group.md-THEME_NAME-theme .md-input[disabled] {  border-bottom-color: '{{foreground-4}}';  color: '{{foreground-3}}'; }md-toast.md-THEME_NAME-theme {  background-color: '{{foreground-1}}';  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-button {    color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-action {    color: '{{primary-A200}}'; }    md-toast.md-THEME_NAME-theme .md-action.md-accent {      color: '{{accent-A200}}'; }    md-toast.md-THEME_NAME-theme .md-action.md-warn {      color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme .md-button {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-background {    background-color: '{{foreground-2}}'; }");

(function(window, angular, undefined) {
    "use strict";
    angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
                element.data(NG_ANIMATE_CHILDREN, true);
            } else {
                scope.$watch(val, function(value) {
                    element.data(NG_ANIMATE_CHILDREN, !!value);
                });
            }
        };
    }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
        var bod = $document[0].body;
        return function(fn) {
            return $$rAF(function() {
                var a = bod.offsetWidth + 1;
                fn();
            });
        };
    } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
        var noop = angular.noop;
        var forEach = angular.forEach;
        var selectors = $animateProvider.$$selectors;
        var isArray = angular.isArray;
        var isString = angular.isString;
        var isObject = angular.isObject;
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_STATE = "$$ngAnimateState";
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        var NG_ANIMATE_CLASS_NAME = "ng-animate";
        var rootAnimateState = {
            running: true
        };
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function prepareElement(element) {
            return element && angular.element(element);
        }
        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element));
        }
        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2);
        }
        var $$jqLite;
        $provide.decorator("$animate", [ "$delegate", "$$q", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", "$templateRequest", "$$jqLite", function($delegate, $$q, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document, $templateRequest, $$$jqLite) {
            $$jqLite = $$$jqLite;
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
            var deregisterWatch = $rootScope.$watch(function() {
                return $templateRequest.totalPendingRequests;
            }, function(val, oldVal) {
                if (val !== 0) return;
                deregisterWatch();
                $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        rootAnimateState.running = false;
                    });
                });
            });
            var globalAnimationCounter = 0;
            var classNameFilter = $animateProvider.classNameFilter();
            var isAnimatableClassName = !classNameFilter ? function() {
                return true;
            } : function(className) {
                return classNameFilter.test(className);
            };
            function classBasedAnimationsBlocked(element, setter) {
                var data = element.data(NG_ANIMATE_STATE) || {};
                if (setter) {
                    data.running = true;
                    data.structural = true;
                    element.data(NG_ANIMATE_STATE, data);
                }
                return data.disabled || data.running && data.structural;
            }
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function() {
                    cancelFn = fn(function() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function parseAnimateOptions(options) {
                if (isObject(options)) {
                    if (options.tempClasses && isString(options.tempClasses)) {
                        options.tempClasses = options.tempClasses.split(/\s+/);
                    }
                    return options;
                }
            }
            function resolveElementClasses(element, cache, runningAnimations) {
                runningAnimations = runningAnimations || {};
                var lookup = {};
                forEach(runningAnimations, function(data, selector) {
                    forEach(selector.split(" "), function(s) {
                        lookup[s] = data;
                    });
                });
                var hasClasses = Object.create(null);
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                var toAdd = [], toRemove = [];
                forEach(cache && cache.classes || [], function(status, className) {
                    var hasClass = hasClasses[className];
                    var matchingAnimation = lookup[className] || {};
                    if (status === false) {
                        if (hasClass || matchingAnimation.event == "addClass") {
                            toRemove.push(className);
                        }
                    } else if (status === true) {
                        if (!hasClass || matchingAnimation.event == "removeClass") {
                            toAdd.push(className);
                        }
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.join(" "), toRemove.join(" ") ];
            }
            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                    if ($sniffer.transitions || $sniffer.animations) {
                        matches.push($injector.get(selectors[""]));
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass];
                        if (selectorFactoryName && !flagMap[klass]) {
                            matches.push($injector.get(selectorFactoryName));
                            flagMap[klass] = true;
                        }
                    }
                    return matches;
                }
            }
            function animationRunner(element, animationEvent, className, options) {
                var node = element[0];
                if (!node) {
                    return;
                }
                if (options) {
                    options.to = options.to || {};
                    options.from = options.from || {};
                }
                var classNameAdd;
                var classNameRemove;
                if (isArray(className)) {
                    classNameAdd = className[0];
                    classNameRemove = className[1];
                    if (!classNameAdd) {
                        className = classNameRemove;
                        animationEvent = "removeClass";
                    } else if (!classNameRemove) {
                        className = classNameAdd;
                        animationEvent = "addClass";
                    } else {
                        className = classNameAdd + " " + classNameRemove;
                    }
                }
                var isSetClassOperation = animationEvent == "setClass";
                var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass" || animationEvent == "animate";
                var currentClassName = element.attr("class");
                var classes = currentClassName + " " + className;
                if (!isAnimatableClassName(classes)) {
                    return;
                }
                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [];
                var animationLookup = (" " + classes).replace(/\s+/g, ".");
                forEach(lookup(animationLookup), function(animationFactory) {
                    var created = registerAnimation(animationFactory, animationEvent);
                    if (!created && isSetClassOperation) {
                        registerAnimation(animationFactory, "addClass");
                        registerAnimation(animationFactory, "removeClass");
                    }
                });
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event];
                    var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                    if (afterFn || beforeFn) {
                        if (event == "leave") {
                            beforeFn = afterFn;
                            afterFn = null;
                        }
                        after.push({
                            event: event,
                            fn: afterFn
                        });
                        before.push({
                            event: event,
                            fn: beforeFn
                        });
                        return true;
                    }
                }
                function run(fns, cancellations, allCompleteFn) {
                    var animations = [];
                    forEach(fns, function(animation) {
                        animation.fn && animations.push(animation);
                    });
                    var count = 0;
                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            (cancellations[index] || noop)();
                            if (++count < animations.length) return;
                            cancellations = null;
                        }
                        allCompleteFn();
                    }
                    forEach(animations, function(animation, index) {
                        var progress = function() {
                            afterAnimationComplete(index);
                        };
                        switch (animation.event) {
                          case "setClass":
                            cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));
                            break;

                          case "animate":
                            cancellations.push(animation.fn(element, className, options.from, options.to, progress));
                            break;

                          case "addClass":
                            cancellations.push(animation.fn(element, classNameAdd || className, progress, options));
                            break;

                          case "removeClass":
                            cancellations.push(animation.fn(element, classNameRemove || className, progress, options));
                            break;

                          default:
                            cancellations.push(animation.fn(element, progress, options));
                            break;
                        }
                    });
                    if (cancellations && cancellations.length === 0) {
                        allCompleteFn();
                    }
                }
                return {
                    node: node,
                    event: animationEvent,
                    className: className,
                    isClassBased: isClassBased,
                    isSetClassOperation: isSetClassOperation,
                    applyStyles: function() {
                        if (options) {
                            element.css(angular.extend(options.from || {}, options.to || {}));
                        }
                    },
                    before: function(allCompleteFn) {
                        beforeComplete = allCompleteFn;
                        run(before, beforeCancel, function() {
                            beforeComplete = noop;
                            allCompleteFn();
                        });
                    },
                    after: function(allCompleteFn) {
                        afterComplete = allCompleteFn;
                        run(after, afterCancel, function() {
                            afterComplete = noop;
                            allCompleteFn();
                        });
                    },
                    cancel: function() {
                        if (beforeCancel) {
                            forEach(beforeCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            beforeComplete(true);
                        }
                        if (afterCancel) {
                            forEach(afterCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            afterComplete(true);
                        }
                    }
                };
            }
            return {
                animate: function(element, from, to, className, options) {
                    className = className || "ng-inline-animate";
                    options = parseAnimateOptions(options) || {};
                    options.from = to ? from : null;
                    options.to = to ? to : from;
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("animate", className, stripCommentsFromElement(element), null, null, noop, options, done);
                    });
                },
                enter: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.enter(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("enter", "ng-enter", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                leave: function(element, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
                            $delegate.leave(element);
                        }, options, done);
                    });
                },
                move: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.move(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("move", "ng-move", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                setClass: function(element, add, remove, options) {
                    options = parseAnimateOptions(options);
                    var STORAGE_KEY = "$$animateClasses";
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    if (classBasedAnimationsBlocked(element)) {
                        return $delegate.$$setClassImmediately(element, add, remove, options);
                    }
                    var classes, cache = element.data(STORAGE_KEY);
                    var hasCache = !!cache;
                    if (!cache) {
                        cache = {};
                        cache.classes = {};
                    }
                    classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    forEach(add, function(c) {
                        if (c && c.length) {
                            classes[c] = true;
                        }
                    });
                    remove = isArray(remove) ? remove : remove.split(" ");
                    forEach(remove, function(c) {
                        if (c && c.length) {
                            classes[c] = false;
                        }
                    });
                    if (hasCache) {
                        if (options && cache.options) {
                            cache.options = angular.extend(cache.options || {}, options);
                        }
                        return cache.promise;
                    } else {
                        element.data(STORAGE_KEY, cache = {
                            classes: classes,
                            options: options
                        });
                    }
                    return cache.promise = runAnimationPostDigest(function(done) {
                        var parentElement = element.parent();
                        var elementNode = extractElementNode(element);
                        var parentNode = elementNode.parentNode;
                        if (!parentNode || parentNode["$$NG_REMOVED"] || elementNode["$$NG_REMOVED"]) {
                            done();
                            return;
                        }
                        var cache = element.data(STORAGE_KEY);
                        element.removeData(STORAGE_KEY);
                        var state = element.data(NG_ANIMATE_STATE) || {};
                        var classes = resolveElementClasses(element, cache, state.active);
                        return !classes ? done() : performAnimation("setClass", classes, element, parentElement, null, function() {
                            if (classes[0]) $delegate.$$addClassImmediately(element, classes[0]);
                            if (classes[1]) $delegate.$$removeClassImmediately(element, classes[1]);
                        }, cache.options, done);
                    });
                },
                cancel: function(promise) {
                    promise.$$cancelFn();
                },
                enabled: function(value, element) {
                    switch (arguments.length) {
                      case 2:
                        if (value) {
                            cleanup(element);
                        } else {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            data.disabled = true;
                            element.data(NG_ANIMATE_STATE, data);
                        }
                        break;

                      case 1:
                        rootAnimateState.disabled = !value;
                        break;

                      default:
                        value = !rootAnimateState.disabled;
                        break;
                    }
                    return !!value;
                }
            };
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {
                var noopCancel = noop;
                var runner = animationRunner(element, animationEvent, className, options);
                if (!runner) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                animationEvent = runner.event;
                className = runner.className;
                var elementEvents = angular.element._data(runner.node);
                elementEvents = elementEvents && elementEvents.events;
                if (!parentElement) {
                    parentElement = afterElement ? afterElement.parent() : element.parent();
                }
                if (animationsDisabled(element, parentElement)) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
                var runningAnimations = ngAnimateState.active || {};
                var totalActiveAnimations = ngAnimateState.totalActive || 0;
                var lastAnimation = ngAnimateState.last;
                var skipAnimation = false;
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = [];
                    if (!runner.isClassBased) {
                        if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
                            skipAnimation = true;
                        } else {
                            for (var klass in runningAnimations) {
                                animationsToCancel.push(runningAnimations[klass]);
                            }
                            ngAnimateState = {};
                            cleanup(element, true);
                        }
                    } else if (lastAnimation.event == "setClass") {
                        animationsToCancel.push(lastAnimation);
                        cleanup(element, className);
                    } else if (runningAnimations[className]) {
                        var current = runningAnimations[className];
                        if (current.event == animationEvent) {
                            skipAnimation = true;
                        } else {
                            animationsToCancel.push(current);
                            cleanup(element, className);
                        }
                    }
                    if (animationsToCancel.length > 0) {
                        forEach(animationsToCancel, function(operation) {
                            operation.cancel();
                        });
                    }
                }
                if (runner.isClassBased && !runner.isSetClassOperation && animationEvent != "animate" && !skipAnimation) {
                    skipAnimation = animationEvent == "addClass" == element.hasClass(className);
                }
                if (skipAnimation) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    fireDoneCallbackAsync();
                    return noopCancel;
                }
                runningAnimations = ngAnimateState.active || {};
                totalActiveAnimations = ngAnimateState.totalActive || 0;
                if (animationEvent == "leave") {
                    element.one("$destroy", function(e) {
                        var element = angular.element(this);
                        var state = element.data(NG_ANIMATE_STATE);
                        if (state) {
                            var activeLeaveAnimation = state.active["ng-leave"];
                            if (activeLeaveAnimation) {
                                activeLeaveAnimation.cancel();
                                cleanup(element, "ng-leave");
                            }
                        }
                    });
                }
                $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME);
                if (options && options.tempClasses) {
                    forEach(options.tempClasses, function(className) {
                        $$jqLite.addClass(element, className);
                    });
                }
                var localAnimationCount = globalAnimationCounter++;
                totalActiveAnimations++;
                runningAnimations[className] = runner;
                element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                });
                fireBeforeCallbackAsync();
                runner.before(function(cancelled) {
                    var data = element.data(NG_ANIMATE_STATE);
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent;
                    fireDOMOperation();
                    if (cancelled === true) {
                        closeAnimation();
                    } else {
                        fireAfterCallbackAsync();
                        runner.after(closeAnimation);
                    }
                });
                return runner.cancel;
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase;
                    if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
                        $$asyncCallback(function() {
                            element.triggerHandler(eventName, {
                                event: animationEvent,
                                className: className
                            });
                        });
                    }
                }
                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before");
                }
                function fireAfterCallbackAsync() {
                    fireDOMCallback("after");
                }
                function fireDoneCallbackAsync() {
                    fireDOMCallback("close");
                    doneCallback();
                }
                function fireDOMOperation() {
                    if (!fireDOMOperation.hasBeenRun) {
                        fireDOMOperation.hasBeenRun = true;
                        domOperation();
                    }
                }
                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        if (runner) {
                            runner.applyStyles();
                        }
                        closeAnimation.hasBeenRun = true;
                        if (options && options.tempClasses) {
                            forEach(options.tempClasses, function(className) {
                                $$jqLite.removeClass(element, className);
                            });
                        }
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data) {
                            if (runner && runner.isClassBased) {
                                cleanup(element, className);
                            } else {
                                $$asyncCallback(function() {
                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                    if (localAnimationCount == data.index) {
                                        cleanup(element, className, animationEvent);
                                    }
                                });
                                element.data(NG_ANIMATE_STATE, data);
                            }
                        }
                        fireDoneCallbackAsync();
                    }
                }
            }
            function cancelChildAnimations(element) {
                var node = extractElementNode(element);
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                    forEach(nodes, function(element) {
                        element = angular.element(element);
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data && data.active) {
                            forEach(data.active, function(runner) {
                                runner.cancel();
                            });
                        }
                    });
                }
            }
            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) {
                    if (!rootAnimateState.disabled) {
                        rootAnimateState.running = false;
                        rootAnimateState.structural = false;
                    }
                } else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {};
                    var removeAnimations = className === true;
                    if (!removeAnimations && data.active && data.active[className]) {
                        data.totalActive--;
                        delete data.active[className];
                    }
                    if (removeAnimations || !data.totalActive) {
                        $$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME);
                        element.removeData(NG_ANIMATE_STATE);
                    }
                }
            }
            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) {
                    return true;
                }
                if (isMatchingElement(element, $rootElement)) {
                    return rootAnimateState.running;
                }
                var allowChildAnimations, parentRunningAnimation, hasParent;
                do {
                    if (parentElement.length === 0) break;
                    var isRoot = isMatchingElement(parentElement, $rootElement);
                    var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                    if (state.disabled) {
                        return true;
                    }
                    if (isRoot) {
                        hasParent = true;
                    }
                    if (allowChildAnimations !== false) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                        if (angular.isDefined(animateChildrenFlag)) {
                            allowChildAnimations = animateChildrenFlag;
                        }
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
                } while (parentElement = parentElement.parent());
                return !hasParent || !allowChildAnimations && parentRunningAnimation;
            }
        } ]);
        $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-";
                TRANSITION_PROP = "WebkitTransition";
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
            } else {
                TRANSITION_PROP = "transition";
                TRANSITIONEND_EVENT = "transitionend";
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-";
                ANIMATION_PROP = "WebkitAnimation";
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
            } else {
                ANIMATION_PROP = "animation";
                ANIMATIONEND_EVENT = "animationend";
            }
            var DURATION_KEY = "Duration";
            var PROPERTY_KEY = "Property";
            var DELAY_KEY = "Delay";
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
            var ANIMATION_PLAYSTATE_KEY = "PlayState";
            var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey";
            var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data";
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
            var CLOSING_TIME_BUFFER = 1.5;
            var ONE_SECOND = 1e3;
            var lookupCache = {};
            var parentCounter = 0;
            var animationReflowQueue = [];
            var cancelAnimationReflow;
            function clearCacheAfterReflow() {
                if (!cancelAnimationReflow) {
                    cancelAnimationReflow = $$animateReflow(function() {
                        animationReflowQueue = [];
                        cancelAnimationReflow = null;
                        lookupCache = {};
                    });
                }
            }
            function afterReflow(element, callback) {
                if (cancelAnimationReflow) {
                    cancelAnimationReflow();
                }
                animationReflowQueue.push(callback);
                cancelAnimationReflow = $$animateReflow(function() {
                    forEach(animationReflowQueue, function(fn) {
                        fn();
                    });
                    animationReflowQueue = [];
                    cancelAnimationReflow = null;
                    lookupCache = {};
                });
            }
            var closingTimer = null;
            var closingTimestamp = 0;
            var animationElementQueue = [];
            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element);
                element = angular.element(node);
                animationElementQueue.push(element);
                var futureTimestamp = Date.now() + totalTime;
                if (futureTimestamp <= closingTimestamp) {
                    return;
                }
                $timeout.cancel(closingTimer);
                closingTimestamp = futureTimestamp;
                closingTimer = $timeout(function() {
                    closeAllAnimations(animationElementQueue);
                    animationElementQueue = [];
                }, totalTime, false);
            }
            function closeAllAnimations(elements) {
                forEach(elements, function(element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                    if (elementData) {
                        forEach(elementData.closeAnimationFns, function(fn) {
                            fn();
                        });
                    }
                });
            }
            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null;
                if (!data) {
                    var transitionDuration = 0;
                    var transitionDelay = 0;
                    var animationDuration = 0;
                    var animationDelay = 0;
                    forEach(element, function(element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {};
                            var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
                            transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
                            var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
                            var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
                            animationDelay = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                            if (aDuration > 0) {
                                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
                            }
                            animationDuration = Math.max(aDuration, animationDuration);
                        }
                    });
                    data = {
                        total: 0,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    };
                    if (cacheKey) {
                        lookupCache[cacheKey] = data;
                    }
                }
                return data;
            }
            function parseMaxTime(str) {
                var maxValue = 0;
                var values = isString(str) ? str.split(/\s*,\s*/) : [];
                forEach(values, function(value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue);
                });
                return maxValue;
            }
            function getCacheKey(element) {
                var parentElement = element.parent();
                var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                if (!parentID) {
                    parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
                    parentID = parentCounter;
                }
                return parentID + "-" + extractElementNode(element).getAttribute("class");
            }
            function animateSetup(animationEvent, element, className, styles) {
                var structural = [ "ng-enter", "ng-leave", "ng-move" ].indexOf(className) >= 0;
                var cacheKey = getCacheKey(element);
                var eventCacheKey = cacheKey + " " + className;
                var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
                var stagger = {};
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger";
                    var staggerCacheKey = cacheKey + " " + staggerClassName;
                    var applyClasses = !lookupCache[staggerCacheKey];
                    applyClasses && $$jqLite.addClass(element, staggerClassName);
                    stagger = getElementAnimationDetails(element, staggerCacheKey);
                    applyClasses && $$jqLite.removeClass(element, staggerClassName);
                }
                $$jqLite.addClass(element, className);
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var transitionDuration = timings.transitionDuration;
                var animationDuration = timings.animationDuration;
                if (structural && transitionDuration === 0 && animationDuration === 0) {
                    $$jqLite.removeClass(element, className);
                    return false;
                }
                var blockTransition = styles || structural && transitionDuration > 0;
                var blockAnimation = animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                var closeAnimationFns = formerData.closeAnimationFns || [];
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    stagger: stagger,
                    cacheKey: eventCacheKey,
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    blockTransition: blockTransition,
                    closeAnimationFns: closeAnimationFns
                });
                var node = extractElementNode(element);
                if (blockTransition) {
                    blockTransitions(node, true);
                    if (styles) {
                        element.css(styles);
                    }
                }
                if (blockAnimation) {
                    blockAnimations(node, true);
                }
                return true;
            }
            function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {
                var node = extractElementNode(element);
                var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
                    activeAnimationComplete();
                    return;
                }
                var activeClassName = "";
                var pendingClassName = "";
                forEach(className.split(" "), function(klass, i) {
                    var prefix = (i > 0 ? " " : "") + klass;
                    activeClassName += prefix + "-active";
                    pendingClassName += prefix + "-pending";
                });
                var style = "";
                var appliedStyles = [];
                var itemIndex = elementData.itemIndex;
                var stagger = elementData.stagger;
                var staggerTime = 0;
                if (itemIndex > 0) {
                    var transitionStaggerDelay = 0;
                    if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
                        transitionStaggerDelay = stagger.transitionDelay * itemIndex;
                    }
                    var animationStaggerDelay = 0;
                    if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                        animationStaggerDelay = stagger.animationDelay * itemIndex;
                        appliedStyles.push(CSS_PREFIX + "animation-play-state");
                    }
                    staggerTime = Math.round(Math.max(transitionStaggerDelay, animationStaggerDelay) * 100) / 100;
                }
                if (!staggerTime) {
                    $$jqLite.addClass(element, activeClassName);
                    if (elementData.blockTransition) {
                        blockTransitions(node, false);
                    }
                }
                var eventCacheKey = elementData.cacheKey + " " + activeClassName;
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                if (maxDuration === 0) {
                    $$jqLite.removeClass(element, activeClassName);
                    animateClose(element, className);
                    activeAnimationComplete();
                    return;
                }
                if (!staggerTime && styles) {
                    if (!timings.transitionDuration) {
                        element.css("transition", timings.animationDuration + "s linear all");
                        appliedStyles.push("transition");
                    }
                    element.css(styles);
                }
                var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
                var maxDelayTime = maxDelay * ONE_SECOND;
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || "";
                    if (oldStyle.charAt(oldStyle.length - 1) !== ";") {
                        oldStyle += ";";
                    }
                    node.setAttribute("style", oldStyle + " " + style);
                }
                var startTime = Date.now();
                var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT;
                var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
                var totalTime = (staggerTime + animationTime) * ONE_SECOND;
                var staggerTimeout;
                if (staggerTime > 0) {
                    $$jqLite.addClass(element, pendingClassName);
                    staggerTimeout = $timeout(function() {
                        staggerTimeout = null;
                        if (timings.transitionDuration > 0) {
                            blockTransitions(node, false);
                        }
                        if (timings.animationDuration > 0) {
                            blockAnimations(node, false);
                        }
                        $$jqLite.addClass(element, activeClassName);
                        $$jqLite.removeClass(element, pendingClassName);
                        if (styles) {
                            if (timings.transitionDuration === 0) {
                                element.css("transition", timings.animationDuration + "s linear all");
                            }
                            element.css(styles);
                            appliedStyles.push("transition");
                        }
                    }, staggerTime * ONE_SECOND, false);
                }
                element.on(css3AnimationEvents, onAnimationProgress);
                elementData.closeAnimationFns.push(function() {
                    onEnd();
                    activeAnimationComplete();
                });
                elementData.running++;
                animationCloseHandler(element, totalTime);
                return onEnd;
                function onEnd() {
                    element.off(css3AnimationEvents, onAnimationProgress);
                    $$jqLite.removeClass(element, activeClassName);
                    $$jqLite.removeClass(element, pendingClassName);
                    if (staggerTimeout) {
                        $timeout.cancel(staggerTimeout);
                    }
                    animateClose(element, className);
                    var node = extractElementNode(element);
                    for (var i in appliedStyles) {
                        node.style.removeProperty(appliedStyles[i]);
                    }
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        activeAnimationComplete();
                    }
                }
            }
            function blockTransitions(node, bool) {
                node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? "none" : "";
            }
            function blockAnimations(node, bool) {
                node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? "paused" : "";
            }
            function animateBefore(animationEvent, element, className, styles) {
                if (animateSetup(animationEvent, element, className, styles)) {
                    return function(cancelled) {
                        cancelled && animateClose(element, className);
                    };
                }
            }
            function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {
                if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
                    return animateRun(animationEvent, element, className, afterAnimationComplete, styles);
                } else {
                    animateClose(element, className);
                    afterAnimationComplete();
                }
            }
            function animate(animationEvent, element, className, animationComplete, options) {
                var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);
                if (!preReflowCancellation) {
                    clearCacheAfterReflow();
                    animationComplete();
                    return;
                }
                var cancel = preReflowCancellation;
                afterReflow(element, function() {
                    cancel = animateAfter(animationEvent, element, className, animationComplete, options.to);
                });
                return function(cancelled) {
                    (cancel || noop)(cancelled);
                };
            }
            function animateClose(element, className) {
                $$jqLite.removeClass(element, className);
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (data) {
                    if (data.running) {
                        data.running--;
                    }
                    if (!data.running || data.running === 0) {
                        element.removeData(NG_ANIMATE_CSS_DATA_KEY);
                    }
                }
            }
            return {
                animate: function(element, className, from, to, animationCompleted, options) {
                    options = options || {};
                    options.from = from;
                    options.to = to;
                    return animate("animate", element, className, animationCompleted, options);
                },
                enter: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("enter", element, "ng-enter", animationCompleted, options);
                },
                leave: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("leave", element, "ng-leave", animationCompleted, options);
                },
                move: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("move", element, "ng-move", animationCompleted, options);
                },
                beforeSetClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add");
                    var cancellationMethod = animateBefore("setClass", element, className, options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeAddClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeRemoveClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                setClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    remove = suffixClasses(remove, "-remove");
                    add = suffixClasses(add, "-add");
                    var className = remove + " " + add;
                    return animateAfter("setClass", element, className, animationCompleted, options.to);
                },
                addClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted, options.to);
                },
                removeClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted, options.to);
                }
            };
            function suffixClasses(classes, suffix) {
                var className = "";
                classes = isArray(classes) ? classes : classes.split(/\s+/);
                forEach(classes, function(klass, i) {
                    if (klass && klass.length > 0) {
                        className += (i > 0 ? " " : "") + klass + suffix;
                    }
                });
                return className;
            }
        } ]);
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var ngAriaModule = angular.module("ngAria", [ "ng" ]).provider("$aria", $AriaProvider);
    function $AriaProvider() {
        var config = {
            ariaHidden: true,
            ariaChecked: true,
            ariaDisabled: true,
            ariaRequired: true,
            ariaInvalid: true,
            ariaMultiline: true,
            ariaValue: true,
            tabindex: true,
            bindKeypress: true
        };
        this.config = function(newConfig) {
            config = angular.extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, negate) {
            return function(scope, elem, attr) {
                var ariaCamelName = attr.$normalize(ariaAttr);
                if (config[ariaCamelName] && !attr[ariaCamelName]) {
                    scope.$watch(attr[attrName], function(boolVal) {
                        if (negate) {
                            boolVal = !boolVal;
                        }
                        elem.attr(ariaAttr, boolVal);
                    });
                }
            };
        }
        this.$get = function() {
            return {
                config: function(key) {
                    return config[key];
                },
                $$watchExpr: watchExpr
            };
        };
    }
    ngAriaModule.directive("ngShow", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngShow", "aria-hidden", true);
    } ]).directive("ngHide", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngHide", "aria-hidden", false);
    } ]).directive("ngModel", [ "$aria", function($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem) {
            return $aria.config(normalizedAttr) && !elem.attr(attr);
        }
        function getShape(attr, elem) {
            var type = attr.type, role = attr.role;
            return (type || role) === "checkbox" || role === "menuitemcheckbox" ? "checkbox" : (type || role) === "radio" || role === "menuitemradio" ? "radio" : type === "range" || role === "progressbar" || role === "slider" ? "range" : (type || role) === "textbox" || elem[0].nodeName === "TEXTAREA" ? "multiline" : "";
        }
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elem, attr, ngModel) {
                var shape = getShape(attr, elem);
                var needsTabIndex = shouldAttachAttr("tabindex", "tabindex", elem);
                function ngAriaWatchModelValue() {
                    return ngModel.$modelValue;
                }
                function getRadioReaction() {
                    if (needsTabIndex) {
                        needsTabIndex = false;
                        return function ngAriaRadioReaction(newVal) {
                            var boolVal = newVal === attr.value;
                            elem.attr("aria-checked", boolVal);
                            elem.attr("tabindex", 0 - !boolVal);
                        };
                    } else {
                        return function ngAriaRadioReaction(newVal) {
                            elem.attr("aria-checked", newVal === attr.value);
                        };
                    }
                }
                function ngAriaCheckboxReaction(newVal) {
                    elem.attr("aria-checked", !!newVal);
                }
                switch (shape) {
                  case "radio":
                  case "checkbox":
                    if (shouldAttachAttr("aria-checked", "ariaChecked", elem)) {
                        scope.$watch(ngAriaWatchModelValue, shape === "radio" ? getRadioReaction() : ngAriaCheckboxReaction);
                    }
                    break;

                  case "range":
                    if ($aria.config("ariaValue")) {
                        if (attr.min && !elem.attr("aria-valuemin")) {
                            elem.attr("aria-valuemin", attr.min);
                        }
                        if (attr.max && !elem.attr("aria-valuemax")) {
                            elem.attr("aria-valuemax", attr.max);
                        }
                        if (!elem.attr("aria-valuenow")) {
                            scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                                elem.attr("aria-valuenow", newVal);
                            });
                        }
                    }
                    break;

                  case "multiline":
                    if (shouldAttachAttr("aria-multiline", "ariaMultiline", elem)) {
                        elem.attr("aria-multiline", true);
                    }
                    break;
                }
                if (needsTabIndex) {
                    elem.attr("tabindex", 0);
                }
                if (ngModel.$validators.required && shouldAttachAttr("aria-required", "ariaRequired", elem)) {
                    scope.$watch(function ngAriaRequiredWatch() {
                        return ngModel.$error.required;
                    }, function ngAriaRequiredReaction(newVal) {
                        elem.attr("aria-required", !!newVal);
                    });
                }
                if (shouldAttachAttr("aria-invalid", "ariaInvalid", elem)) {
                    scope.$watch(function ngAriaInvalidWatch() {
                        return ngModel.$invalid;
                    }, function ngAriaInvalidReaction(newVal) {
                        elem.attr("aria-invalid", !!newVal);
                    });
                }
            }
        };
    } ]).directive("ngDisabled", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngDisabled", "aria-disabled");
    } ]).directive("ngMessages", function() {
        return {
            restrict: "A",
            require: "?ngMessages",
            link: function(scope, elem, attr, ngMessages) {
                if (!elem.attr("aria-live")) {
                    elem.attr("aria-live", "assertive");
                }
            }
        };
    }).directive("ngClick", [ "$aria", "$parse", function($aria, $parse) {
        return {
            restrict: "A",
            compile: function(elem, attr) {
                var fn = $parse(attr.ngClick, null, true);
                return function(scope, elem, attr) {
                    if ($aria.config("tabindex") && !elem.attr("tabindex")) {
                        elem.attr("tabindex", 0);
                    }
                    if ($aria.config("bindKeypress") && !attr.ngKeypress) {
                        elem.on("keypress", function(event) {
                            if (event.keyCode === 32 || event.keyCode === 13) {
                                scope.$apply(callback);
                            }
                            function callback() {
                                fn(scope, {
                                    $event: event
                                });
                            }
                        });
                    }
                };
            }
        };
    } ]).directive("ngDblclick", [ "$aria", function($aria) {
        return function(scope, elem, attr) {
            if ($aria.config("tabindex") && !elem.attr("tabindex")) {
                elem.attr("tabindex", 0);
            }
        };
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, extend = angular.extend, toJson = angular.toJson, fromJson = angular.fromJson;
    function isStringNumber(num) {
        return /^-?\d+\.?\d*$/.test(num.replace(/["']/g, ""));
    }
    var angularLocalStorage = angular.module("LocalStorageModule", []);
    angularLocalStorage.provider("localStorageService", function() {
        this.prefix = "ls";
        this.storageType = "localStorage";
        this.cookie = {
            expiry: 30,
            path: "/"
        };
        this.notify = {
            setItem: true,
            removeItem: false
        };
        this.setPrefix = function(prefix) {
            this.prefix = prefix;
            return this;
        };
        this.setStorageType = function(storageType) {
            this.storageType = storageType;
            return this;
        };
        this.setStorageCookie = function(exp, path) {
            this.cookie = {
                expiry: exp,
                path: path
            };
            return this;
        };
        this.setStorageCookieDomain = function(domain) {
            this.cookie.domain = domain;
            return this;
        };
        this.setNotify = function(itemSet, itemRemove) {
            this.notify = {
                setItem: itemSet,
                removeItem: itemRemove
            };
            return this;
        };
        this.$get = [ "$rootScope", "$window", "$document", "$parse", function($rootScope, $window, $document, $parse) {
            var self = this;
            var prefix = self.prefix;
            var cookie = self.cookie;
            var notify = self.notify;
            var storageType = self.storageType;
            var webStorage;
            if (!$document) {
                $document = document;
            } else if ($document[0]) {
                $document = $document[0];
            }
            if (prefix.substr(-1) !== ".") {
                prefix = !!prefix ? prefix + "." : "";
            }
            var deriveQualifiedKey = function(key) {
                return prefix + key;
            };
            var browserSupportsLocalStorage = function() {
                try {
                    var supported = storageType in $window && $window[storageType] !== null;
                    var key = deriveQualifiedKey("__" + Math.round(Math.random() * 1e7));
                    if (supported) {
                        webStorage = $window[storageType];
                        webStorage.setItem(key, "");
                        webStorage.removeItem(key);
                    }
                    return supported;
                } catch (e) {
                    storageType = "cookie";
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToLocalStorage = function(key, value) {
                if (isUndefined(value)) {
                    value = null;
                } else if (isObject(value) || isArray(value) || isNumber(+value || value)) {
                    value = toJson(value);
                }
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: "cookie"
                        });
                    }
                    return addToCookies(key, value);
                }
                try {
                    if (isObject(value) || isArray(value)) {
                        value = toJson(value);
                    }
                    if (webStorage) {
                        webStorage.setItem(deriveQualifiedKey(key), value);
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: self.storageType
                        });
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return addToCookies(key, value);
                }
                return true;
            };
            var getFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return getFromCookies(key);
                }
                var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                if (!item || item === "null") {
                    return null;
                }
                if (item.charAt(0) === "{" || item.charAt(0) === "[" || isStringNumber(item)) {
                    return fromJson(item);
                }
                return item;
            };
            var removeFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    if (notify.removeItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: "cookie"
                        });
                    }
                    return removeFromCookies(key);
                }
                try {
                    webStorage.removeItem(deriveQualifiedKey(key));
                    if (notify.removeItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: self.storageType
                        });
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return removeFromCookies(key);
                }
                return true;
            };
            var getKeysForLocalStorage = function() {
                if (!browserSupportsLocalStorage) {
                    $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return false;
                }
                var prefixLength = prefix.length;
                var keys = [];
                for (var key in webStorage) {
                    if (key.substr(0, prefixLength) === prefix) {
                        try {
                            keys.push(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description);
                            return [];
                        }
                    }
                }
                return keys;
            };
            var clearAllFromLocalStorage = function(regularExpression) {
                regularExpression = regularExpression || "";
                var tempPrefix = prefix.slice(0, -1);
                var testRegex = new RegExp(tempPrefix + "." + regularExpression);
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return clearAllFromCookies();
                }
                var prefixLength = prefix.length;
                for (var key in webStorage) {
                    if (testRegex.test(key)) {
                        try {
                            removeFromLocalStorage(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                            return clearAllFromCookies();
                        }
                    }
                }
                return true;
            };
            var browserSupportsCookies = function() {
                try {
                    return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1);
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToCookies = function(key, value) {
                if (isUndefined(value)) {
                    return false;
                } else if (isArray(value) || isObject(value)) {
                    value = toJson(value);
                }
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                try {
                    var expiry = "", expiryDate = new Date(), cookieDomain = "";
                    if (value === null) {
                        expiryDate.setTime(expiryDate.getTime() + -1 * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                        value = "";
                    } else if (cookie.expiry !== 0) {
                        expiryDate.setTime(expiryDate.getTime() + cookie.expiry * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    }
                    if (!!key) {
                        var cookiePath = "; path=" + cookie.path;
                        if (cookie.domain) {
                            cookieDomain = "; domain=" + cookie.domain;
                        }
                        $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
                return true;
            };
            var getFromCookies = function(key) {
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                var cookies = $document.cookie && $document.cookie.split(";") || [];
                for (var i = 0; i < cookies.length; i++) {
                    var thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    if (thisCookie.indexOf(deriveQualifiedKey(key) + "=") === 0) {
                        var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                        try {
                            var obj = JSON.parse(storedValues);
                            return fromJson(obj);
                        } catch (e) {
                            return storedValues;
                        }
                    }
                }
                return null;
            };
            var removeFromCookies = function(key) {
                addToCookies(key, null);
            };
            var clearAllFromCookies = function() {
                var thisCookie = null, thisKey = null;
                var prefixLength = prefix.length;
                var cookies = $document.cookie.split(";");
                for (var i = 0; i < cookies.length; i++) {
                    thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                    removeFromCookies(key);
                }
            };
            var getStorageType = function() {
                return storageType;
            };
            var bindToScope = function(scope, key, def, lsKey) {
                lsKey = lsKey || key;
                var value = getFromLocalStorage(lsKey);
                if (value === null && isDefined(def)) {
                    value = def;
                } else if (isObject(value) && isObject(def)) {
                    value = extend(def, value);
                }
                $parse(key).assign(scope, value);
                return scope.$watch(key, function(newVal) {
                    addToLocalStorage(lsKey, newVal);
                }, isObject(scope[key]));
            };
            var lengthOfLocalStorage = function() {
                var count = 0;
                var storage = $window[storageType];
                for (var i = 0; i < storage.length; i++) {
                    if (storage.key(i).indexOf(prefix) === 0) {
                        count++;
                    }
                }
                return count;
            };
            return {
                isSupported: browserSupportsLocalStorage,
                getStorageType: getStorageType,
                set: addToLocalStorage,
                add: addToLocalStorage,
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                bind: bindToScope,
                deriveKey: deriveQualifiedKey,
                length: lengthOfLocalStorage,
                cookie: {
                    isSupported: browserSupportsCookies,
                    set: addToCookies,
                    add: addToCookies,
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            };
        } ];
    });
})(window, window.angular);

angular.module("xeditable", []).value("editableOptions", {
    theme: "default",
    buttons: "right",
    blurElem: "cancel",
    blurForm: "ignore",
    activate: "focus"
});

angular.module("xeditable").directive("editableBsdate", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBsdate",
        inputTpl: '<input type="text">'
    });
} ]);

angular.module("xeditable").directive("editableBstime", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBstime",
        inputTpl: "<timepicker></timepicker>",
        render: function() {
            this.parent.render.call(this);
            var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
            div.attr("ng-model", this.inputEl.attr("ng-model"));
            this.inputEl.removeAttr("ng-model");
            if (this.attrs.eNgChange) {
                div.attr("ng-change", this.inputEl.attr("ng-change"));
                this.inputEl.removeAttr("ng-change");
            }
            this.inputEl.wrap(div);
        }
    });
} ]);

angular.module("xeditable").directive("editableCheckbox", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableCheckbox",
        inputTpl: '<input type="checkbox">',
        render: function() {
            this.parent.render.call(this);
            if (this.attrs.eTitle) {
                this.inputEl.wrap("<label></label>");
                this.inputEl.after(angular.element("<span></span>").text(this.attrs.eTitle));
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableChecklist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        directiveName: "editableChecklist",
        inputTpl: "<span></span>",
        useCopy: true,
        render: function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="checkbox" checklist-model="$parent.$data" checklist-value="' + parsed.locals.valueFn + '">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        }
    });
} ]);

(function() {
    var types = "text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");
    angular.forEach(types, function(type) {
        var directiveName = "editable" + type.charAt(0).toUpperCase() + type.slice(1);
        angular.module("xeditable").directive(directiveName, [ "editableDirectiveFactory", function(editableDirectiveFactory) {
            return editableDirectiveFactory({
                directiveName: directiveName,
                inputTpl: '<input type="' + type + '">'
            });
        } ]);
    });
    angular.module("xeditable").directive("editableRange", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
        return editableDirectiveFactory({
            directiveName: "editableRange",
            inputTpl: '<input type="range" id="range" name="range">',
            render: function() {
                this.parent.render.call(this);
                this.inputEl.after("<output>{{$data}}</output>");
            }
        });
    } ]);
})();

angular.module("xeditable").directive("editableRadiolist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        directiveName: "editableRadiolist",
        inputTpl: "<span></span>",
        render: function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="radio" ng-model="$parent.$data" value="{{' + parsed.locals.valueFn + '}}">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableSelect", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableSelect",
        inputTpl: "<select></select>",
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                self.scope.$apply(function() {
                    self.scope.$form.$submit();
                });
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableTextarea", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableTextarea",
        inputTpl: "<textarea></textarea>",
        addListeners: function() {
            var self = this;
            self.parent.addListeners.call(self);
            if (self.single && self.buttons !== "no") {
                self.autosubmit();
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("keydown", function(e) {
                if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }
            });
        }
    });
} ]);

angular.module("xeditable").factory("editableController", [ "$q", "editableUtils", function($q, editableUtils) {
    EditableController.$inject = [ "$scope", "$attrs", "$element", "$parse", "editableThemes", "editableOptions", "$rootScope", "$compile", "$q" ];
    function EditableController($scope, $attrs, $element, $parse, editableThemes, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;
        var inWaiting;
        var self = this;
        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = "";
        self.theme = editableThemes[editableOptions.theme] || editableThemes["default"];
        self.parent = {};
        self.inputTpl = "";
        self.directiveName = "";
        self.useCopy = false;
        self.single = null;
        self.buttons = "right";
        self.init = function(single) {
            self.single = single;
            self.name = $attrs.eName || $attrs[self.directiveName];
            if ($attrs[self.directiveName]) {
                valueGetter = $parse($attrs[self.directiveName]);
            } else {
                throw "You should provide value for `" + self.directiveName + "` in editable element!";
            }
            if (!self.single) {
                self.buttons = "no";
            } else {
                self.buttons = self.attrs.buttons || editableOptions.buttons;
            }
            if ($attrs.eName) {
                self.scope.$watch("$data", function(newVal) {
                    self.scope.$form.$data[$attrs.eName] = newVal;
                });
            }
            if ($attrs.onshow) {
                self.onshow = function() {
                    return self.catchError($parse($attrs.onshow)($scope));
                };
            }
            if ($attrs.onhide) {
                self.onhide = function() {
                    return $parse($attrs.onhide)($scope);
                };
            }
            if ($attrs.oncancel) {
                self.oncancel = function() {
                    return $parse($attrs.oncancel)($scope);
                };
            }
            if ($attrs.onbeforesave) {
                self.onbeforesave = function() {
                    return self.catchError($parse($attrs.onbeforesave)($scope));
                };
            }
            if ($attrs.onaftersave) {
                self.onaftersave = function() {
                    return self.catchError($parse($attrs.onaftersave)($scope));
                };
            }
            $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
                self.handleEmpty();
            });
        };
        self.render = function() {
            var theme = self.theme;
            self.inputEl = angular.element(self.inputTpl);
            self.controlsEl = angular.element(theme.controlsTpl);
            self.controlsEl.append(self.inputEl);
            if (self.buttons !== "no") {
                self.buttonsEl = angular.element(theme.buttonsTpl);
                self.submitEl = angular.element(theme.submitTpl);
                self.cancelEl = angular.element(theme.cancelTpl);
                self.buttonsEl.append(self.submitEl).append(self.cancelEl);
                self.controlsEl.append(self.buttonsEl);
                self.inputEl.addClass("editable-has-buttons");
            }
            self.errorEl = angular.element(theme.errorTpl);
            self.controlsEl.append(self.errorEl);
            self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
            self.editorEl.append(self.controlsEl);
            for (var k in $attrs.$attr) {
                if (k.length <= 1) {
                    continue;
                }
                var transferAttr = false;
                var nextLetter = k.substring(1, 2);
                if (k.substring(0, 1) === "e" && nextLetter === nextLetter.toUpperCase()) {
                    transferAttr = k.substring(1);
                } else {
                    continue;
                }
                if (transferAttr === "Form" || transferAttr === "NgSubmit") {
                    continue;
                }
                transferAttr = transferAttr.substring(0, 1).toLowerCase() + editableUtils.camelToDash(transferAttr.substring(1));
                var attrValue = $attrs[k] === "" ? transferAttr : $attrs[k];
                self.inputEl.attr(transferAttr, attrValue);
            }
            self.inputEl.addClass("editable-input");
            self.inputEl.attr("ng-model", "$data");
            self.editorEl.addClass(editableUtils.camelToDash(self.directiveName));
            if (self.single) {
                self.editorEl.attr("editable-form", "$form");
                self.editorEl.attr("blur", self.attrs.blur || (self.buttons === "no" ? "cancel" : editableOptions.blurElem));
            }
            if (angular.isFunction(theme.postrender)) {
                theme.postrender.call(self);
            }
        };
        self.setLocalValue = function() {
            self.scope.$data = self.useCopy ? angular.copy(valueGetter($scope.$parent)) : valueGetter($scope.$parent);
        };
        self.show = function() {
            self.setLocalValue();
            self.render();
            $element.after(self.editorEl);
            $compile(self.editorEl)($scope);
            self.addListeners();
            $element.addClass("editable-hide");
            return self.onshow();
        };
        self.hide = function() {
            self.editorEl.remove();
            $element.removeClass("editable-hide");
            return self.onhide();
        };
        self.cancel = function() {
            self.oncancel();
        };
        self.addListeners = function() {
            self.inputEl.bind("keyup", function(e) {
                if (!self.single) {
                    return;
                }
                switch (e.keyCode) {
                  case 27:
                    self.scope.$apply(function() {
                        self.scope.$form.$cancel();
                    });
                    break;
                }
            });
            if (self.single && self.buttons === "no") {
                self.autosubmit();
            }
            self.editorEl.bind("click", function(e) {
                if (e.which !== 1) {
                    return;
                }
                if (self.scope.$form.$visible) {
                    self.scope.$form._clicked = true;
                }
            });
        };
        self.setWaiting = function(value) {
            if (value) {
                inWaiting = !self.inputEl.attr("disabled") && !self.inputEl.attr("ng-disabled") && !self.inputEl.attr("ng-enabled");
                if (inWaiting) {
                    self.inputEl.attr("disabled", "disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").attr("disabled", "disabled");
                    }
                }
            } else {
                if (inWaiting) {
                    self.inputEl.removeAttr("disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").removeAttr("disabled");
                    }
                }
            }
        };
        self.activate = function() {
            setTimeout(function() {
                var el = self.inputEl[0];
                if (editableOptions.activate === "focus" && el.focus) {
                    el.focus();
                }
                if (editableOptions.activate === "select" && el.select) {
                    el.select();
                }
            }, 0);
        };
        self.setError = function(msg) {
            if (!angular.isObject(msg)) {
                $scope.$error = msg;
                self.error = msg;
            }
        };
        self.catchError = function(result, noPromise) {
            if (angular.isObject(result) && noPromise !== true) {
                $q.when(result).then(angular.bind(this, function(r) {
                    this.catchError(r, true);
                }), angular.bind(this, function(r) {
                    this.catchError(r, true);
                }));
            } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
                this.setError(result.data);
                result = result.data;
            } else if (angular.isString(result)) {
                this.setError(result);
            }
            return result;
        };
        self.save = function() {
            valueGetter.assign($scope.$parent, angular.copy(self.scope.$data));
        };
        self.handleEmpty = function() {
            var val = valueGetter($scope.$parent);
            var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
            $element.toggleClass("editable-empty", isEmpty);
        };
        self.autosubmit = angular.noop;
        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
    }
    return EditableController;
} ]);

angular.module("xeditable").factory("editableDirectiveFactory", [ "$parse", "$compile", "editableThemes", "$rootScope", "$document", "editableController", "editableFormController", function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController) {
    return function(overwrites) {
        return {
            restrict: "A",
            scope: true,
            require: [ overwrites.directiveName, "?^form" ],
            controller: editableController,
            link: function(scope, elem, attrs, ctrl) {
                var eCtrl = ctrl[0];
                var eFormCtrl;
                var hasForm = false;
                if (ctrl[1]) {
                    eFormCtrl = ctrl[1];
                    hasForm = true;
                } else if (attrs.eForm) {
                    var getter = $parse(attrs.eForm)(scope);
                    if (getter) {
                        eFormCtrl = getter;
                        hasForm = true;
                    } else {
                        for (var i = 0; i < $document[0].forms.length; i++) {
                            if ($document[0].forms[i].name === attrs.eForm) {
                                eFormCtrl = null;
                                hasForm = true;
                                break;
                            }
                        }
                    }
                }
                angular.forEach(overwrites, function(v, k) {
                    if (eCtrl[k] !== undefined) {
                        eCtrl.parent[k] = eCtrl[k];
                    }
                });
                angular.extend(eCtrl, overwrites);
                eCtrl.init(!hasForm);
                scope.$editable = eCtrl;
                elem.addClass("editable");
                if (hasForm) {
                    if (eFormCtrl) {
                        scope.$form = eFormCtrl;
                        if (!scope.$form.$addEditable) {
                            throw "Form with editable elements should have `editable-form` attribute.";
                        }
                        scope.$form.$addEditable(eCtrl);
                    } else {
                        $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                        $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                        $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                        scope.$form = null;
                    }
                } else {
                    scope.$form = editableFormController();
                    scope.$form.$addEditable(eCtrl);
                    if (attrs.eForm) {
                        scope.$parent[attrs.eForm] = scope.$form;
                    }
                    if (!attrs.eForm) {
                        elem.addClass("editable-click");
                        elem.bind("click", function(e) {
                            e.preventDefault();
                            e.editable = eCtrl;
                            scope.$apply(function() {
                                scope.$form.$show();
                            });
                        });
                    }
                }
            }
        };
    };
} ]);

angular.module("xeditable").factory("editableFormController", [ "$parse", "$document", "$rootScope", "editablePromiseCollection", "editableUtils", function($parse, $document, $rootScope, editablePromiseCollection, editableUtils) {
    var shown = [];
    $document.bind("click", function(e) {
        if (e.which !== 1) {
            return;
        }
        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {
            if (shown[i]._clicked) {
                shown[i]._clicked = false;
                continue;
            }
            if (shown[i].$waiting) {
                continue;
            }
            if (shown[i]._blur === "cancel") {
                toCancel.push(shown[i]);
            }
            if (shown[i]._blur === "submit") {
                toSubmit.push(shown[i]);
            }
        }
        if (toCancel.length || toSubmit.length) {
            $rootScope.$apply(function() {
                angular.forEach(toCancel, function(v) {
                    v.$cancel();
                });
                angular.forEach(toSubmit, function(v) {
                    v.$submit();
                });
            });
        }
    });
    var base = {
        $addEditable: function(editable) {
            this.$editables.push(editable);
            editable.elem.bind("$destroy", angular.bind(this, this.$removeEditable, editable));
            if (!editable.scope.$form) {
                editable.scope.$form = this;
            }
            if (this.$visible) {
                editable.catchError(editable.show());
            }
        },
        $removeEditable: function(editable) {
            for (var i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i] === editable) {
                    this.$editables.splice(i, 1);
                    return;
                }
            }
        },
        $show: function() {
            if (this.$visible) {
                return;
            }
            this.$visible = true;
            var pc = editablePromiseCollection();
            pc.when(this.$onshow());
            this.$setError(null, "");
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.show());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$activate),
                onFalse: angular.bind(this, this.$activate),
                onString: angular.bind(this, this.$activate)
            });
            setTimeout(angular.bind(this, function() {
                this._clicked = false;
                if (editableUtils.indexOf(shown, this) === -1) {
                    shown.push(this);
                }
            }), 0);
        },
        $activate: function(name) {
            var i;
            if (this.$editables.length) {
                if (angular.isString(name)) {
                    for (i = 0; i < this.$editables.length; i++) {
                        if (this.$editables[i].name === name) {
                            this.$editables[i].activate();
                            return;
                        }
                    }
                }
                for (i = 0; i < this.$editables.length; i++) {
                    if (this.$editables[i].error) {
                        this.$editables[i].activate();
                        return;
                    }
                }
                this.$editables[0].activate();
            }
        },
        $hide: function() {
            if (!this.$visible) {
                return;
            }
            this.$visible = false;
            this.$onhide();
            angular.forEach(this.$editables, function(editable) {
                editable.hide();
            });
            editableUtils.arrayRemove(shown, this);
        },
        $cancel: function() {
            if (!this.$visible) {
                return;
            }
            this.$oncancel();
            angular.forEach(this.$editables, function(editable) {
                editable.cancel();
            });
            this.$hide();
        },
        $setWaiting: function(value) {
            this.$waiting = !!value;
            angular.forEach(this.$editables, function(editable) {
                editable.setWaiting(!!value);
            });
        },
        $setError: function(name, msg) {
            angular.forEach(this.$editables, function(editable) {
                if (!name || editable.name === name) {
                    editable.setError(msg);
                }
            });
        },
        $submit: function() {
            if (this.$waiting) {
                return;
            }
            this.$setError(null, "");
            var pc = editablePromiseCollection();
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onbeforesave());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, checkSelf, true),
                onFalse: angular.bind(this, checkSelf, false),
                onString: angular.bind(this, this.$activate)
            });
            function checkSelf(childrenTrue) {
                var pc = editablePromiseCollection();
                pc.when(this.$onbeforesave());
                pc.then({
                    onWait: angular.bind(this, this.$setWaiting),
                    onTrue: childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
                    onFalse: angular.bind(this, this.$hide),
                    onString: angular.bind(this, this.$activate)
                });
            }
        },
        $save: function() {
            angular.forEach(this.$editables, function(editable) {
                editable.save();
            });
            var pc = editablePromiseCollection();
            pc.when(this.$onaftersave());
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onaftersave());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$hide),
                onFalse: angular.bind(this, this.$hide),
                onString: angular.bind(this, this.$activate)
            });
        },
        $onshow: angular.noop,
        $oncancel: angular.noop,
        $onhide: angular.noop,
        $onbeforesave: angular.noop,
        $onaftersave: angular.noop
    };
    return function() {
        return angular.extend({
            $editables: [],
            $visible: false,
            $waiting: false,
            $data: {},
            _clicked: false,
            _blur: null
        }, base);
    };
} ]);

angular.module("xeditable").directive("editableForm", [ "$rootScope", "$parse", "editableFormController", "editableOptions", function($rootScope, $parse, editableFormController, editableOptions) {
    return {
        restrict: "A",
        require: [ "form" ],
        compile: function() {
            return {
                pre: function(scope, elem, attrs, ctrl) {
                    var form = ctrl[0];
                    var eForm;
                    if (attrs.editableForm) {
                        if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                            eForm = scope[attrs.editableForm];
                            angular.extend(form, eForm);
                        } else {
                            eForm = editableFormController();
                            scope[attrs.editableForm] = eForm;
                            angular.extend(eForm, form);
                        }
                    } else {
                        eForm = editableFormController();
                        angular.extend(form, eForm);
                    }
                    var buf = $rootScope.$$editableBuffer;
                    var name = form.$name;
                    if (name && buf && buf[name]) {
                        angular.forEach(buf[name], function(editable) {
                            eForm.$addEditable(editable);
                        });
                        delete buf[name];
                    }
                },
                post: function(scope, elem, attrs, ctrl) {
                    var eForm;
                    if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                        eForm = scope[attrs.editableForm];
                    } else {
                        eForm = ctrl[0];
                    }
                    if (attrs.onshow) {
                        eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
                    }
                    if (attrs.onhide) {
                        eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
                    }
                    if (attrs.oncancel) {
                        eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
                    }
                    if (attrs.shown && $parse(attrs.shown)(scope)) {
                        eForm.$show();
                    }
                    eForm._blur = attrs.blur || editableOptions.blurForm;
                    if (!attrs.ngSubmit && !attrs.submit) {
                        if (attrs.onbeforesave) {
                            eForm.$onbeforesave = function() {
                                return $parse(attrs.onbeforesave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        if (attrs.onaftersave) {
                            eForm.$onaftersave = function() {
                                return $parse(attrs.onaftersave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        elem.bind("submit", function(event) {
                            event.preventDefault();
                            scope.$apply(function() {
                                eForm.$submit();
                            });
                        });
                    }
                    elem.bind("click", function(e) {
                        if (e.which !== 1) {
                            return;
                        }
                        if (eForm.$visible) {
                            eForm._clicked = true;
                        }
                    });
                }
            };
        }
    };
} ]);

angular.module("xeditable").factory("editablePromiseCollection", [ "$q", function($q) {
    function promiseCollection() {
        return {
            promises: [],
            hasFalse: false,
            hasString: false,
            when: function(result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else {
                    return;
                }
            },
            then: function(callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onWait = callbacks.onWait || angular.noop;
                var self = this;
                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(function(results) {
                        onWait(false);
                        angular.forEach(results, function(result) {
                            self.when(result, true);
                        });
                        applyCallback();
                    }, function(error) {
                        onWait(false);
                        onString();
                    });
                } else {
                    applyCallback();
                }
                function applyCallback() {
                    if (!self.hasString && !self.hasFalse) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else {
                        onString();
                    }
                }
            }
        };
    }
    return promiseCollection;
} ]);

angular.module("xeditable").factory("editableUtils", [ function() {
    return {
        indexOf: function(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },
        arrayRemove: function(array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },
        camelToDash: function(str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            });
        },
        dashToCamel: function(str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, "Moz$1");
        }
    };
} ]);

angular.module("xeditable").factory("editableNgOptionsParser", [ function() {
    var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;
    function parser(optionsExp) {
        var match;
        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
            throw "ng-options parse error";
        }
        var displayFn = match[2] || match[1], valueName = match[4] || match[6], keyName = match[5], groupByFn = match[3] || "", valueFn = match[2] ? match[1] : valueName, valuesFn = match[7], track = match[8], trackFn = track ? match[8] : null;
        var ngRepeat;
        if (keyName === undefined) {
            ngRepeat = valueName + " in " + valuesFn;
            if (track !== undefined) {
                ngRepeat += " track by " + trackFn;
            }
        } else {
            ngRepeat = "(" + keyName + ", " + valueName + ") in " + valuesFn;
        }
        return {
            ngRepeat: ngRepeat,
            locals: {
                valueName: valueName,
                keyName: keyName,
                valueFn: valueFn,
                displayFn: displayFn
            }
        };
    }
    return parser;
} ]);

angular.module("xeditable").factory("editableThemes", function() {
    var themes = {
        "default": {
            formTpl: '<form class="editable-wrap"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<span class="editable-controls"></span>',
            inputTpl: "",
            errorTpl: '<div class="editable-error" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit">save</button>',
            cancelTpl: '<button type="button" ng-click="$form.$cancel()">cancel</button>'
        },
        bs2: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',
            cancelTpl: '<button type="button" class="btn" ng-click="$form.$cancel()">' + '<span class="icon-remove"></span>' + "</button>"
        },
        bs3: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',
            cancelTpl: '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + '<span class="glyphicon glyphicon-remove"></span>' + "</button>",
            buttonsClass: "",
            inputClass: "",
            postrender: function() {
                switch (this.directiveName) {
                  case "editableText":
                  case "editableSelect":
                  case "editableTextarea":
                  case "editableEmail":
                  case "editableTel":
                  case "editableNumber":
                  case "editableUrl":
                  case "editableSearch":
                  case "editableDate":
                  case "editableDatetime":
                  case "editableTime":
                  case "editableMonth":
                  case "editableWeek":
                    this.inputEl.addClass("form-control");
                    if (this.theme.inputClass) {
                        if (this.inputEl.attr("multiple") && (this.theme.inputClass === "input-sm" || this.theme.inputClass === "input-lg")) {
                            break;
                        }
                        this.inputEl.addClass(this.theme.inputClass);
                    }
                    break;
                }
                if (this.buttonsEl && this.theme.buttonsClass) {
                    this.buttonsEl.find("button").addClass(this.theme.buttonsClass);
                }
            }
        }
    };
    return themes;
});

(function(window, angular, undefined) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join("");
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," + "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," + "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," + "stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width");
    var svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent," + "attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color," + "color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family," + "font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name," + "gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints," + "keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits," + "markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position," + "overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY," + "repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh," + "stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke," + "stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit," + "stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2," + "underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version," + "viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role," + "xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2," + "zoomAndPan");
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) obj[items[i]] = true;
        return obj;
    }
    function htmlParser(html, handler) {
        if (typeof html !== "string") {
            if (html === null || typeof html === "undefined") {
                html = "";
            } else {
                html = "" + html;
            }
        }
        var index, chars, match, stack = [], last = html, text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = "";
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("<!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], "");
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += "<";
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos = 0, i;
            tagName = angular.lowercase(tagName);
            if (tagName) for (pos = stack.length - 1; pos >= 0; pos--) if (stack[pos] == tagName) break;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");
    var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    function decodeEntities(value) {
        if (!value) {
            return "";
        }
        var parts = spaceRe.exec(value);
        var spaceBefore = parts[1];
        var spaceAfter = parts[3];
        var content = parts[2];
        if (content) {
            hiddenPre.innerHTML = content.replace(/</g, "&lt;");
            content = "textContent" in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText;
        }
        return spaceBefore + content + spaceAfter;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out("<");
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = tag === "img" && lkey === "src" || lkey === "background";
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(" ");
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? "/>" : ">");
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out("</");
                    out(tag);
                    out(">");
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/, MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? "http://" : "mailto:") + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a ");
                if (angular.isDefined(target)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, "&quot;"), '">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);

"format global";

"deps angular";

"deps moment";

(function() {
    "use strict";
    function angularMoment(angular, moment) {
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: "",
            format: null
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: false,
            serverTime: null,
            titleFormat: null
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", "angularMomentConfig", function($window, moment, amMoment, amTimeAgoConfig, angularMomentConfig) {
            return function(scope, element, attr) {
                var activeTimeout = null;
                var currentValue;
                var currentFormat = angularMomentConfig.format;
                var withoutSuffix = amTimeAgoConfig.withoutSuffix;
                var titleFormat = amTimeAgoConfig.titleFormat;
                var localDate = new Date().getTime();
                var preprocess = angularMomentConfig.preprocess;
                var modelName = attr.amTimeAgo.replace(/^::/, "");
                var isBindOnce = attr.amTimeAgo.indexOf("::") === 0;
                var isTimeElement = "TIME" === element[0].nodeName.toUpperCase();
                var unwatchChanges;
                function getNow() {
                    var now;
                    if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime();
                        var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else {
                        now = moment();
                    }
                    return now;
                }
                function cancelTimer() {
                    if (activeTimeout) {
                        $window.clearTimeout(activeTimeout);
                        activeTimeout = null;
                    }
                }
                function updateTime(momentInstance) {
                    element.text(momentInstance.from(getNow(), withoutSuffix));
                    if (titleFormat && !element.attr("title")) {
                        element.attr("title", momentInstance.local().format(titleFormat));
                    }
                    if (!isBindOnce) {
                        var howOld = Math.abs(getNow().diff(momentInstance, "minute"));
                        var secondsUntilUpdate = 3600;
                        if (howOld < 1) {
                            secondsUntilUpdate = 1;
                        } else if (howOld < 60) {
                            secondsUntilUpdate = 30;
                        } else if (howOld < 180) {
                            secondsUntilUpdate = 300;
                        }
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, secondsUntilUpdate * 1e3);
                    }
                }
                function updateDateTimeAttr(value) {
                    if (isTimeElement) {
                        element.attr("datetime", value);
                    }
                }
                function updateMoment() {
                    cancelTimer();
                    if (currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue, preprocess, currentFormat);
                        updateTime(momentValue);
                        updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                unwatchChanges = scope.$watch(modelName, function(value) {
                    if (typeof value === "undefined" || value === null || value === "") {
                        cancelTimer();
                        if (currentValue) {
                            element.text("");
                            updateDateTimeAttr("");
                            currentValue = null;
                        }
                        return;
                    }
                    currentValue = value;
                    updateMoment();
                    if (value !== undefined && isBindOnce) {
                        unwatchChanges();
                    }
                });
                if (angular.isDefined(attr.amWithoutSuffix)) {
                    scope.$watch(attr.amWithoutSuffix, function(value) {
                        if (typeof value === "boolean") {
                            withoutSuffix = value;
                            updateMoment();
                        } else {
                            withoutSuffix = amTimeAgoConfig.withoutSuffix;
                        }
                    });
                }
                attr.$observe("amFormat", function(format) {
                    if (typeof format !== "undefined") {
                        currentFormat = format;
                        updateMoment();
                    }
                });
                attr.$observe("amPreprocess", function(newValue) {
                    preprocess = newValue;
                    updateMoment();
                });
                scope.$on("$destroy", function() {
                    cancelTimer();
                });
                scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            var that = this;
            this.preprocessors = {
                utc: moment.utc,
                unix: moment.unix
            };
            this.changeLocale = function(locale) {
                var result = (moment.locale || moment.lang)(locale);
                if (angular.isDefined(locale)) {
                    $rootScope.$broadcast("amMoment:localeChanged");
                    $rootScope.$broadcast("amMoment:languageChange");
                }
                return result;
            };
            this.changeLanguage = function(lang) {
                $log.warn("angular-moment: Usage of amMoment.changeLanguage() is deprecated. Please use changeLocale()");
                return that.changeLocale(lang);
            };
            this.preprocessDate = function(value, preprocess, format) {
                if (angular.isUndefined(preprocess)) {
                    preprocess = angularMomentConfig.preprocess;
                }
                if (this.preprocessors[preprocess]) {
                    return this.preprocessors[preprocess](value, format);
                }
                if (preprocess) {
                    $log.warn("angular-moment: Ignoring unsupported value for preprocess: " + preprocess);
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return moment(parseInt(value, 10));
                }
                return moment(value, format);
            };
            this.applyTimezone = function(aMoment) {
                var timezone = angularMomentConfig.timezone;
                if (aMoment && timezone) {
                    if (aMoment.tz) {
                        aMoment = aMoment.tz(timezone);
                    } else {
                        $log.warn("angular-moment: timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js?");
                    }
                }
                return aMoment;
            };
        } ]).filter("amCalendar", [ "moment", "amMoment", function(moment, amMoment) {
            return function(value, preprocess) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).calendar();
            };
        } ]).filter("amDateFormat", [ "moment", "amMoment", function(moment, amMoment) {
            return function(value, format, preprocess) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).format(format);
            };
        } ]).filter("amDurationFormat", [ "moment", function(moment) {
            return function(value, format, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment.duration(value, format).humanize(suffix);
            };
        } ]).filter("amTimeAgo", [ "moment", "amMoment", function(moment, amMoment) {
            return function(value, preprocess, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).fromNow(suffix);
            };
        } ]);
    }
    if (typeof define === "function" && define.amd) {
        define("angular-moment", [ "angular", "moment" ], angularMoment);
    } else if (typeof module !== "undefined" && module && module.exports) {
        angularMoment(angular, require("moment"));
    } else {
        angularMoment(angular, window.moment);
    }
})();

angular.module("QuickList", []);

angular.module("QuickList").value("quickRepeatList", {});

angular.module("QuickList").directive("quickNgRepeat", [ "$parse", "$animate", "quickRepeatList", function($parse, $animate, quick_repeat_list) {
    var NG_REMOVED = "$$NG_REMOVED";
    var ngRepeatMinErr = "err";
    var uid = [ "0", "0", "0" ];
    var list_id = window.list_id = function() {
        var i = 0;
        return function() {
            return "list_" + ++i;
        };
    }();
    function hashKey(obj) {
        var objType = typeof obj, key;
        if (objType == "object" && obj !== null) {
            if (typeof (key = obj.$$hashKey) == "function") {
                key = obj.$$hashKey();
            } else if (key === undefined) {
                key = obj.$$hashKey = nextUid();
            }
        } else {
            key = obj;
        }
        return objType + ":" + key;
    }
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }
    function nextUid() {
        var index = uid.length;
        var digit;
        while (index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit == 57) {
                uid[index] = "A";
                return uid.join("");
            }
            if (digit == 90) {
                uid[index] = "0";
            } else {
                uid[index] = String.fromCharCode(digit + 1);
                return uid.join("");
            }
        }
        uid.unshift("0");
        return uid.join("");
    }
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return angular.isArray(obj) || !angular.isFunction(obj) && (length === 0 || typeof length === "number" && length > 0 && length - 1 in obj);
    }
    return {
        transclude: "element",
        priority: 1e3,
        terminal: true,
        compile: function(element, attr, linker) {
            return function($scope, $element, $attr) {
                var expression = $attr.quickNgRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/), trackByExp, trackByExpGetter, trackByIdFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, hashFnLocals = {
                    $id: hashKey
                };
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                lhs = match[1];
                rhs = match[2];
                trackByExp = match[4];
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                    trackByIdFn = function(key, value, index) {
                        if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                        hashFnLocals[valueIdentifier] = value;
                        hashFnLocals.$index = index;
                        return trackByExpGetter($scope, hashFnLocals);
                    };
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                valueIdentifier = match[3] || match[1];
                keyIdentifier = match[2];
                var lastBlockMap = {};
                var list_name = $attr.quickRepeatList || list_id();
                $scope.$watch(rhs, quick_repeat_list[list_name] = function(collection) {
                    var index, length, previousNode = $element[0], nextNode, nextBlockMap = {}, arrayLength, childScope, key, value, trackById, collectionKeys, block, nextBlockOrder = [];
                    if (isArrayLike(collection)) {
                        collectionKeys = collection;
                        trackByIdFn = trackByIdFn || trackByIdArrayFn;
                    } else {
                        trackByIdFn = trackByIdFn || trackByIdObjFn;
                        collectionKeys = [];
                        for (key in collection) {
                            if (collection.hasOwnProperty(key) && key.charAt(0) != "$") {
                                collectionKeys.push(key);
                            }
                        }
                        collectionKeys.sort();
                    }
                    arrayLength = collectionKeys.length;
                    length = nextBlockOrder.length = collectionKeys.length;
                    for (index = 0; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        trackById = trackByIdFn(key, value, index);
                        if (lastBlockMap.hasOwnProperty(trackById)) {
                            block = lastBlockMap[trackById];
                            delete lastBlockMap[trackById];
                            nextBlockMap[trackById] = block;
                            nextBlockOrder[index] = block;
                        } else if (nextBlockMap.hasOwnProperty(trackById)) {
                            angular.forEach(nextBlockOrder, function(block) {
                                if (block && block.startNode) lastBlockMap[block.id] = block;
                            });
                            throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                        } else {
                            nextBlockOrder[index] = {
                                id: trackById
                            };
                            nextBlockMap[trackById] = false;
                        }
                    }
                    for (key in lastBlockMap) {
                        if (lastBlockMap.hasOwnProperty(key)) {
                            block = lastBlockMap[key];
                            $animate.leave(block.elements);
                            angular.forEach(block.elements, function(element) {
                                element[NG_REMOVED] = true;
                            });
                            block.scope.$destroy();
                        }
                    }
                    for (index = 0, length = collectionKeys.length; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        block = nextBlockOrder[index];
                        if (block.startNode) {
                            childScope = block.scope;
                            nextNode = previousNode;
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode[NG_REMOVED]);
                            if (block.startNode == nextNode) {} else {
                                $animate.move(block.elements, null, angular.element(previousNode));
                            }
                            previousNode = block.endNode;
                        } else {
                            childScope = $scope.$new();
                        }
                        childScope[valueIdentifier] = value;
                        if (keyIdentifier) childScope[keyIdentifier] = key;
                        childScope.$index = index;
                        childScope.$first = index === 0;
                        childScope.$last = index === arrayLength - 1;
                        childScope.$middle = !(childScope.$first || childScope.$last);
                        childScope.$odd = !(childScope.$even = index % 2 == 0);
                        if (!block.startNode) {
                            linker(childScope, function(clone) {
                                $animate.enter(clone, null, angular.element(previousNode));
                                previousNode = clone;
                                block.scope = childScope;
                                block.startNode = clone[0];
                                block.elements = clone;
                                block.endNode = clone[clone.length - 1];
                                nextBlockMap[block.id] = block;
                            });
                            if (childScope.$$phase !== "$digest") {
                                childScope.$digest();
                            }
                        }
                    }
                    lastBlockMap = nextBlockMap;
                });
            };
        }
    };
} ]);